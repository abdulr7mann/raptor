import logging
import time
from datetime import datetime, timezone
from typing import Any

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

from api_pentest.core.models import Evidence

logger = logging.getLogger(__name__)


class PentestHttpClient:
    """HTTP client wrapper that captures full request/response evidence."""

    def __init__(
        self,
        timeout: int = 30,
        max_retries: int = 0,
        verify_ssl: bool = False,
        follow_redirects: bool = True,
    ):
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.follow_redirects = follow_redirects

        self.session = requests.Session()
        self.session.verify = verify_ssl

        if max_retries > 0:
            retry_strategy = Retry(
                total=max_retries,
                backoff_factor=0.5,
                status_forcelist=[502, 503, 504],
            )
            adapter = HTTPAdapter(max_retries=retry_strategy)
            self.session.mount("https://", adapter)
            self.session.mount("http://", adapter)

        # Suppress SSL warnings if verification is disabled
        if not verify_ssl:
            import urllib3
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    def request(
        self,
        method: str,
        url: str,
        headers: dict[str, str] | None = None,
        body: Any = None,
        auth_token: str | None = None,
        timeout: int | None = None,
        follow_redirects: bool | None = None,
    ) -> Evidence:
        """Make an HTTP request and return Evidence with full request/response capture."""
        req_headers = dict(headers) if headers else {}

        if auth_token:
            req_headers["Authorization"] = auth_token

        if "User-Agent" not in req_headers:
            req_headers["User-Agent"] = "API-Pentest-Toolkit/1.0"

        # Determine body handling
        json_body = None
        data_body = None
        if body is not None:
            if isinstance(body, (dict, list)):
                json_body = body
                if "Content-Type" not in req_headers:
                    req_headers["Content-Type"] = "application/json"
            elif isinstance(body, str):
                data_body = body
            else:
                data_body = str(body)

        effective_timeout = timeout or self.timeout
        effective_redirects = follow_redirects if follow_redirects is not None else self.follow_redirects

        timestamp = datetime.now(timezone.utc).isoformat()
        start = time.time()

        evidence = Evidence(
            request_method=method.upper(),
            request_url=url,
            request_headers=req_headers,
            request_body=body,
            timestamp=timestamp,
        )

        try:
            response = self.session.request(
                method=method.upper(),
                url=url,
                headers=req_headers,
                json=json_body,
                data=data_body,
                timeout=effective_timeout,
                allow_redirects=effective_redirects,
            )

            elapsed_ms = (time.time() - start) * 1000

            evidence.response_status = response.status_code
            evidence.response_headers = dict(response.headers)
            evidence.response_time_ms = elapsed_ms

            try:
                evidence.response_body = response.text
            except Exception:
                evidence.response_body = "<binary or undecodable response>"

            logger.debug(
                f"{method.upper()} {url} -> {response.status_code} ({elapsed_ms:.0f}ms)"
            )

        except requests.exceptions.Timeout:
            evidence.response_status = 0
            evidence.response_body = "REQUEST_TIMEOUT"
            evidence.response_time_ms = (time.time() - start) * 1000
            logger.warning(f"{method.upper()} {url} -> TIMEOUT")

        except requests.exceptions.ConnectionError as e:
            evidence.response_status = 0
            evidence.response_body = f"CONNECTION_ERROR: {e}"
            evidence.response_time_ms = (time.time() - start) * 1000
            logger.warning(f"{method.upper()} {url} -> CONNECTION_ERROR: {e}")

        except requests.exceptions.RequestException as e:
            evidence.response_status = 0
            evidence.response_body = f"REQUEST_ERROR: {e}"
            evidence.response_time_ms = (time.time() - start) * 1000
            logger.warning(f"{method.upper()} {url} -> ERROR: {e}")

        return evidence

    def request_raw(
        self,
        method: str,
        url: str,
        headers: dict[str, str] | None = None,
        body: Any = None,
        auth_token: str | None = None,
    ) -> requests.Response | None:
        """Make a raw request, returning the Response object directly."""
        req_headers = dict(headers) if headers else {}
        if auth_token:
            req_headers["Authorization"] = auth_token

        json_body = None
        data_body = None
        if body is not None:
            if isinstance(body, (dict, list)):
                json_body = body
            else:
                data_body = body if isinstance(body, str) else str(body)

        try:
            return self.session.request(
                method=method.upper(),
                url=url,
                headers=req_headers,
                json=json_body,
                data=data_body,
                timeout=self.timeout,
                allow_redirects=self.follow_redirects,
            )
        except requests.exceptions.RequestException as e:
            logger.warning(f"Raw request failed: {method.upper()} {url} -> {e}")
            return None

    def close(self):
        """Close the session."""
        self.session.close()
