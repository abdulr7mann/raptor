import json
import logging
import re
from typing import Any

from api_pentest.core.models import BodyMode, Endpoint

logger = logging.getLogger(__name__)


class OpenAPIParser:
    """
    Parser for Swagger 2.0, OpenAPI 3.0, and OpenAPI 3.1 specifications.

    Uses prance for $ref resolution when available, falls back to manual parsing.
    """

    ADMIN_PATTERNS = re.compile(
        r"/(admin|internal|debug|management|actuator|swagger|graphql|metrics|health)",
        re.IGNORECASE,
    )

    def __init__(self, data: dict, base_url_override: str | None = None):
        self.raw_data = data
        self.data = data
        self.base_url_override = base_url_override
        self.warnings: list[str] = []
        self._is_swagger2 = "swagger" in data and str(data["swagger"]).startswith("2")
        self._base_url = ""
        self._security_schemes: dict[str, Any] = {}

    def parse(self) -> list[Endpoint]:
        """Parse the spec and return Endpoint objects."""
        self._resolve_refs()
        self._base_url = self._extract_base_url()
        self._security_schemes = self._extract_security_schemes()
        global_security = self.data.get("security", [])

        endpoints: list[Endpoint] = []
        paths = self.data.get("paths", {})

        for path, path_item in paths.items():
            if not isinstance(path_item, dict):
                continue

            path_params = path_item.get("parameters", [])

            for method in ("get", "post", "put", "delete", "patch", "head", "options"):
                operation = path_item.get(method)
                if not operation or not isinstance(operation, dict):
                    continue

                endpoint = self._parse_operation(
                    path=path,
                    method=method.upper(),
                    operation=operation,
                    path_level_params=path_params,
                    global_security=global_security,
                )
                endpoints.append(endpoint)

        logger.info(f"Parsed {len(endpoints)} endpoints from OpenAPI spec")
        return endpoints

    def _resolve_refs(self):
        """Try to resolve $ref references using prance."""
        try:
            import prance

            spec_string = json.dumps(self.raw_data)
            parser = prance.ResolvingParser(spec_string=spec_string, lazy=True)
            parser.parse()
            self.data = parser.specification
            logger.info("Resolved $ref references with prance")
        except ImportError:
            self.warnings.append(
                "prance not installed; $ref references will not be resolved. "
                "Install with: pip install prance[openapi-spec-validator]"
            )
            self.data = self.raw_data
        except Exception as e:
            self.warnings.append(f"prance resolution failed: {e}; using raw spec")
            self.data = self.raw_data

    def _extract_base_url(self) -> str:
        """Extract base URL from spec."""
        if self.base_url_override:
            return self.base_url_override.rstrip("/")

        if self._is_swagger2:
            schemes = self.data.get("schemes", ["https"])
            host = self.data.get("host", "localhost")
            base_path = self.data.get("basePath", "")
            scheme = schemes[0] if schemes else "https"
            url = f"{scheme}://{host}{base_path}"
            return url.rstrip("/")
        else:
            servers = self.data.get("servers", [])
            if servers and isinstance(servers[0], dict):
                url = servers[0].get("url", "")

                variables = servers[0].get("variables", {})
                for var_name, var_config in variables.items():
                    if isinstance(var_config, dict):
                        default = var_config.get("default", "")
                        url = url.replace(f"{{{var_name}}}", str(default))

                if url.startswith("/"):
                    url = f"https://localhost{url}"

                return url.rstrip("/")

        return "https://localhost"

    def _extract_security_schemes(self) -> dict[str, Any]:
        """Extract security scheme definitions."""
        if self._is_swagger2:
            return self.data.get("securityDefinitions", {})
        else:
            components = self.data.get("components", {})
            return components.get("securitySchemes", {})

    def _parse_operation(
        self,
        path: str,
        method: str,
        operation: dict,
        path_level_params: list,
        global_security: list,
    ) -> Endpoint:
        """Parse a single path+method operation into an Endpoint."""
        url = f"{self._base_url}{path}"

        operation_id = operation.get("operationId", "")
        summary = operation.get("summary", "")
        name = operation_id or summary or f"{method} {path}"
        tags = operation.get("tags", [])
        deprecated = operation.get("deprecated", False)

        all_params = list(path_level_params) + operation.get("parameters", [])
        headers, query_params, path_params, body, body_mode = self._parse_parameters(
            all_params, operation
        )

        op_security = operation.get("security", global_security)
        security_schemes = []
        explicitly_public = False

        if op_security is not None:
            if isinstance(op_security, list) and len(op_security) == 0:
                explicitly_public = True
            else:
                for sec_req in op_security:
                    if isinstance(sec_req, dict):
                        security_schemes.extend(sec_req.keys())

        pentest_tags = list(tags)
        if deprecated:
            pentest_tags.append("deprecated")
        if explicitly_public:
            pentest_tags.append("public-no-auth")
        if self.ADMIN_PATTERNS.search(path):
            pentest_tags.append("admin-pattern")

        url = self._fill_path_params(url, all_params)

        return Endpoint(
            method=method,
            url=url,
            name=name,
            folder_path="/".join(tags) if tags else "",
            headers=headers,
            body=body,
            body_mode=body_mode,
            auth_type="oauth2" if any("oauth" in s.lower() for s in security_schemes) else "",
            path_params=path_params,
            query_params=query_params,
            tags=pentest_tags,
            is_deprecated=deprecated,
            security_schemes=security_schemes,
        )

    def _parse_parameters(
        self, params: list, operation: dict
    ) -> tuple[dict, dict, list, Any, BodyMode]:
        """Parse parameters into headers, query params, path params, and body."""
        headers: dict[str, str] = {}
        query_params: dict[str, str] = {}
        path_params: list[str] = []
        body = None
        body_mode = BodyMode.NONE

        for param in params:
            if not isinstance(param, dict):
                continue

            location = param.get("in", "")
            param_name = param.get("name", "")
            schema = param.get("schema", {})
            example = self._get_example_value(param_name, schema, param)

            if location == "header":
                headers[param_name] = str(example)
            elif location == "query":
                query_params[param_name] = str(example)
            elif location == "path":
                path_params.append(param_name)
            elif location == "body":
                body = self._generate_body_from_schema(schema)
                body_mode = BodyMode.RAW

        request_body = operation.get("requestBody", {})
        if request_body and isinstance(request_body, dict):
            content = request_body.get("content", {})

            if "application/json" in content:
                media = content["application/json"]
                schema = media.get("schema", {})
                body = self._generate_body_from_schema(schema)
                body_mode = BodyMode.RAW
                headers.setdefault("Content-Type", "application/json")
            elif "application/x-www-form-urlencoded" in content:
                media = content["application/x-www-form-urlencoded"]
                schema = media.get("schema", {})
                body = self._generate_body_from_schema(schema)
                body_mode = BodyMode.URLENCODED
                headers.setdefault("Content-Type", "application/x-www-form-urlencoded")
            elif "multipart/form-data" in content:
                media = content["multipart/form-data"]
                schema = media.get("schema", {})
                body = self._generate_body_from_schema(schema)
                body_mode = BodyMode.FORMDATA
            elif content:
                first_type = next(iter(content))
                media = content[first_type]
                schema = media.get("schema", {})
                body = self._generate_body_from_schema(schema)
                body_mode = BodyMode.RAW
                headers.setdefault("Content-Type", first_type)

        return headers, query_params, path_params, body, body_mode

    def _generate_body_from_schema(self, schema: dict) -> Any:
        """Generate a sample request body from a JSON Schema."""
        if not schema or not isinstance(schema, dict):
            return None

        if "example" in schema:
            return schema["example"]

        schema_type = schema.get("type", "object")

        if schema_type == "object":
            properties = schema.get("properties", {})
            result = {}
            for prop_name, prop_schema in properties.items():
                if isinstance(prop_schema, dict):
                    result[prop_name] = self._schema_example_value(prop_name, prop_schema)
            return result if result else {"key": "value"}

        if schema_type == "array":
            items_schema = schema.get("items", {})
            if isinstance(items_schema, dict):
                return [self._schema_example_value("item", items_schema)]
            return ["example"]

        return self._schema_example_value("value", schema)

    def _schema_example_value(self, name: str, schema: dict) -> Any:
        """Generate an example value from a schema property."""
        if "example" in schema:
            return schema["example"]
        if "default" in schema:
            return schema["default"]
        if "enum" in schema and schema["enum"]:
            return schema["enum"][0]

        schema_type = schema.get("type", "string")
        schema_format = schema.get("format", "")

        if schema_type == "string":
            format_map = {
                "email": "test@example.com",
                "date": "2024-01-01",
                "date-time": "2024-01-01T00:00:00Z",
                "uuid": "550e8400-e29b-41d4-a716-446655440000",
                "uri": "https://example.com",
                "url": "https://example.com",
                "password": "TestPass123!",
            }
            if schema_format in format_map:
                return format_map[schema_format]
            return f"test_{name}"

        if schema_type == "integer":
            return 1
        if schema_type == "number":
            return 1.0
        if schema_type == "boolean":
            return True
        if schema_type == "array":
            items = schema.get("items", {})
            return [self._schema_example_value(name, items)] if isinstance(items, dict) else ["example"]
        if schema_type == "object":
            return self._generate_body_from_schema(schema)

        return "test"

    def _get_example_value(self, name: str, schema: dict, param: dict) -> Any:
        """Get an example value for a parameter."""
        if "example" in param:
            return param["example"]
        if isinstance(schema, dict):
            return self._schema_example_value(name, schema)
        return "test"

    def _fill_path_params(self, url: str, params: list) -> str:
        """Replace {param} placeholders with example values."""
        for param in params:
            if not isinstance(param, dict):
                continue
            if param.get("in") != "path":
                continue

            name = param.get("name", "")
            schema = param.get("schema", {})
            example = self._get_example_value(name, schema, param)
            url = url.replace(f"{{{name}}}", str(example))

        # Fill any remaining path params with defaults
        url = re.sub(r"\{(\w+)\}", r"1", url)
        return url
