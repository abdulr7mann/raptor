import base64
import copy
import json
import logging
import time
from typing import Any

import requests

from api_pentest.core.models import TokenContext

logger = logging.getLogger(__name__)


class OAuth2Handler:
    """Handles OAuth2 token lifecycle and JWT manipulation for attack scenarios."""

    def __init__(
        self,
        token_url: str,
        client_id: str = "",
        client_secret: str = "",
        grant_type: str = "client_credentials",
        username: str = "",
        password: str = "",
        scopes: list[str] | None = None,
    ):
        self.token_url = token_url
        self.client_id = client_id
        self.client_secret = client_secret
        self.grant_type = grant_type
        self.username = username
        self.password = password
        self.scopes = scopes or []
        self._current_token: TokenContext | None = None
        self._previous_tokens: list[TokenContext] = []

    def acquire_token(self, force_refresh: bool = False) -> TokenContext | None:
        """Acquire an OAuth2 token. Returns cached token if still valid."""
        if self._current_token and not self._current_token.is_expired and not force_refresh:
            return self._current_token

        try:
            # Try standard OAuth2 form-encoded first
            data = {"grant_type": self.grant_type}

            if self.grant_type == "client_credentials":
                data["client_id"] = self.client_id
                data["client_secret"] = self.client_secret
            elif self.grant_type == "password":
                data["client_id"] = self.client_id
                data["client_secret"] = self.client_secret
                data["username"] = self.username
                data["password"] = self.password

            if self.scopes:
                data["scope"] = " ".join(self.scopes)

            response = requests.post(
                self.token_url,
                data=data,
                timeout=30,
                verify=False,
            )

            token_data = {}
            if response.status_code == 200:
                token_data = response.json()

            # If standard OAuth2 failed or returned no access_token,
            # try JSON login (for APIs like VAmPI that use custom login endpoints)
            if not token_data.get("access_token") and not token_data.get("auth_token"):
                json_body = {"username": self.username, "password": self.password}
                response = requests.post(
                    self.token_url,
                    json=json_body,
                    timeout=30,
                    verify=False,
                )

                if response.status_code != 200:
                    logger.error(
                        f"Token acquisition failed: {response.status_code} - {response.text[:500]}"
                    )
                    return None
                token_data = response.json()

            if not token_data:
                logger.error("Token acquisition returned empty response")
                return None

            # Support both 'access_token' (OAuth2) and 'auth_token' (custom APIs)
            access_token = token_data.get("access_token") or token_data.get("auth_token", "")

            if self._current_token:
                self._previous_tokens.append(self._current_token)

            token_ctx = TokenContext(
                access_token=access_token,
                refresh_token=token_data.get("refresh_token", ""),
                token_type=token_data.get("token_type", "Bearer"),
                expires_at=time.time() + token_data.get("expires_in", 3600),
                scopes=token_data.get("scope", "").split() if token_data.get("scope") else self.scopes,
            )

            self._decode_jwt(token_ctx)
            self._current_token = token_ctx
            logger.info("Token acquired successfully")
            return token_ctx

        except Exception as e:
            logger.error(f"Token acquisition error: {e}")
            return None

    def refresh_token(self, token: TokenContext) -> TokenContext | None:
        """Refresh an OAuth2 token using the refresh_token grant."""
        if not token.refresh_token:
            logger.warning("No refresh token available")
            return None

        try:
            data = {
                "grant_type": "refresh_token",
                "refresh_token": token.refresh_token,
                "client_id": self.client_id,
                "client_secret": self.client_secret,
            }

            response = requests.post(self.token_url, data=data, timeout=30, verify=False)
            if response.status_code != 200:
                logger.error(f"Token refresh failed: {response.status_code}")
                return None

            token_data = response.json()

            self._previous_tokens.append(copy.deepcopy(token))

            new_token = TokenContext(
                access_token=token_data.get("access_token", ""),
                refresh_token=token_data.get("refresh_token", token.refresh_token),
                token_type=token_data.get("token_type", "Bearer"),
                expires_at=time.time() + token_data.get("expires_in", 3600),
                scopes=token_data.get("scope", "").split() if token_data.get("scope") else token.scopes,
            )

            self._decode_jwt(new_token)
            self._current_token = new_token
            return new_token

        except Exception as e:
            logger.error(f"Token refresh error: {e}")
            return None

    def get_previous_token(self) -> TokenContext | None:
        """Return the most recently replaced token (for replay attacks)."""
        if self._previous_tokens:
            return self._previous_tokens[-1]
        return None

    # -------------------------------------------------------------------------
    # JWT Manipulation Methods (for attack scenarios)
    # -------------------------------------------------------------------------

    @staticmethod
    def _b64url_encode(data: bytes) -> str:
        return base64.urlsafe_b64encode(data).rstrip(b"=").decode("utf-8")

    @staticmethod
    def _b64url_decode(s: str) -> bytes:
        padding = 4 - len(s) % 4
        if padding != 4:
            s += "=" * padding
        return base64.urlsafe_b64decode(s)

    @staticmethod
    def _decode_jwt(token: TokenContext):
        """Decode JWT without verification to extract header and claims."""
        parts = token.access_token.split(".")
        if len(parts) < 2:
            return

        token.raw_jwt = token.access_token

        try:
            header_bytes = OAuth2Handler._b64url_decode(parts[0])
            token.decoded_header = json.loads(header_bytes)
        except Exception:
            token.decoded_header = {}

        try:
            payload_bytes = OAuth2Handler._b64url_decode(parts[1])
            token.decoded_claims = json.loads(payload_bytes)
        except Exception:
            token.decoded_claims = {}

    @staticmethod
    def forge_alg_none(token: TokenContext) -> str:
        """Create a JWT with alg set to 'none' and signature stripped."""
        parts = token.access_token.split(".")
        if len(parts) < 2:
            return token.access_token

        try:
            header = json.loads(OAuth2Handler._b64url_decode(parts[0]))
        except Exception:
            return token.access_token

        header["alg"] = "none"
        new_header = OAuth2Handler._b64url_encode(json.dumps(header, separators=(",", ":")).encode())
        return f"{new_header}.{parts[1]}."

    @staticmethod
    def tamper_claims(token: TokenContext, new_claims: dict[str, Any]) -> str:
        """Alter JWT claims while keeping original signature."""
        parts = token.access_token.split(".")
        if len(parts) < 3:
            return token.access_token

        try:
            payload = json.loads(OAuth2Handler._b64url_decode(parts[1]))
        except Exception:
            return token.access_token

        payload.update(new_claims)
        new_payload = OAuth2Handler._b64url_encode(
            json.dumps(payload, separators=(",", ":")).encode()
        )
        return f"{parts[0]}.{new_payload}.{parts[2]}"

    @staticmethod
    def force_expired(token: TokenContext) -> str:
        """Create a JWT with exp set to a past timestamp."""
        return OAuth2Handler.tamper_claims(token, {"exp": int(time.time()) - 86400})

    @staticmethod
    def flip_signature(token: TokenContext) -> str:
        """Corrupt the JWT signature by flipping bits."""
        parts = token.access_token.split(".")
        if len(parts) < 3 or not parts[2]:
            return token.access_token

        try:
            sig_bytes = bytearray(OAuth2Handler._b64url_decode(parts[2]))
        except Exception:
            return token.access_token

        for i in range(min(4, len(sig_bytes))):
            sig_bytes[i] ^= 0xFF

        corrupted_sig = OAuth2Handler._b64url_encode(bytes(sig_bytes))
        return f"{parts[0]}.{parts[1]}.{corrupted_sig}"

    @staticmethod
    def strip_signature(token: TokenContext) -> str:
        """Remove the signature entirely."""
        parts = token.access_token.split(".")
        if len(parts) < 2:
            return token.access_token
        return f"{parts[0]}.{parts[1]}."

    @staticmethod
    def malformed_tokens() -> list[str]:
        """Return a list of malformed tokens for access control tests."""
        return [
            "",
            "invalid",
            "Bearer",
            "Bearer ",
            "Bearer invalid",
            "Bearer null",
            "Basic dGVzdDp0ZXN0",
            "eyJhbGciOiJub25lIn0.eyJ0ZXN0IjoidGVzdCJ9.",
        ]
