"""
Advanced response analyzer for false positive reduction.

This module provides ResponseAnalyzer which goes beyond HTTP status codes
to determine the true success/failure state of API responses. Many APIs
return HTTP 200 with error bodies, or include status fields that contradict
the HTTP status.

Features:
- Multi-signal success/failure detection
- Error pattern recognition
- Behavioral anomaly detection
- Baseline comparison
- WAF/security filter detection

Usage:
    from api_pentest.core.response_analyzer import ResponseAnalyzer, ResponseVerdict

    analyzer = ResponseAnalyzer()

    # Analyze a single response
    verdict = analyzer.analyze(evidence)
    if verdict.is_success:
        print("True success")
    elif verdict.is_error:
        print(f"Error detected: {verdict.error_type}")

    # Compare against baseline
    verdict = analyzer.compare(test_evidence, baseline_evidence)
    if verdict.is_anomaly:
        print(f"Behavioral change: {verdict.differences}")
"""

import hashlib
import json
import logging
import re
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, TYPE_CHECKING

if TYPE_CHECKING:
    from api_pentest.core.models import Evidence

logger = logging.getLogger(__name__)


class ErrorType(Enum):
    """Types of errors detected in responses."""
    NONE = auto()
    AUTHENTICATION = auto()      # 401, auth required
    AUTHORIZATION = auto()       # 403, forbidden
    NOT_FOUND = auto()           # 404, resource missing
    VALIDATION = auto()          # 400, bad input
    RATE_LIMITED = auto()        # 429, too many requests
    SERVER_ERROR = auto()        # 5xx errors
    APPLICATION_ERROR = auto()   # App-level error in body
    TIMEOUT = auto()             # Request timeout
    CONNECTION = auto()          # Connection failed
    WAF_BLOCKED = auto()         # WAF/security filter
    UNKNOWN = auto()


class ResponseSignal(Enum):
    """Signals used to determine response status."""
    HTTP_STATUS = "http_status"
    JSON_STATUS_FIELD = "json_status_field"
    ERROR_MESSAGE = "error_message"
    CONTENT_LENGTH = "content_length"
    RESPONSE_TIME = "response_time"
    CONTENT_TYPE = "content_type"
    HEADER_INDICATOR = "header_indicator"
    BODY_STRUCTURE = "body_structure"


@dataclass
class ResponseVerdict:
    """Analysis result for a response."""
    is_success: bool
    is_error: bool
    is_anomaly: bool = False
    confidence: float = 0.0  # 0.0-1.0
    error_type: ErrorType = ErrorType.NONE
    signals: dict[ResponseSignal, Any] = field(default_factory=dict)
    differences: list[str] = field(default_factory=list)
    description: str = ""


@dataclass
class ResponseFingerprint:
    """Fingerprint of a response for comparison."""
    status_code: int
    content_type: str
    content_length: int
    response_time_ms: float
    body_hash: str
    json_keys: set[str]
    status_field_value: Any
    error_field_value: Any
    has_data: bool


class ResponseAnalyzer:
    """Analyzes API responses to determine true success/failure state.

    Uses multiple signals beyond HTTP status to detect:
    - HTTP 200 with error body (false success)
    - HTTP 400 with success body (false error)
    - WAF blocks disguised as normal responses
    - Rate limiting without 429 status
    - Application-level errors
    """

    # Common status field names in responses
    STATUS_FIELDS = frozenset({
        "status", "success", "ok", "error", "code", "result",
        "succeeded", "failed", "message", "msg", "errcode",
        "error_code", "errorCode", "statusCode", "status_code",
        "ret", "retcode", "ret_code", "response_code",
    })

    # Values indicating success
    SUCCESS_VALUES = frozenset({
        True, "true", "ok", "success", "succeeded", 0, "0",
        200, "200", 1, "1", "yes",
    })

    # Values indicating failure
    ERROR_VALUES = frozenset({
        False, "false", "error", "failed", "failure", "fail",
        -1, "-1", "no", "invalid", "unauthorized", "forbidden",
    })

    # Error message patterns
    ERROR_PATTERNS = [
        # Authentication/Authorization
        (r'\b(unauthorized|unauthenticated|not\s+authenticated)\b', ErrorType.AUTHENTICATION),
        (r'\b(forbidden|access\s+denied|permission\s+denied)\b', ErrorType.AUTHORIZATION),
        (r'\b(invalid\s+token|token\s+expired|session\s+expired)\b', ErrorType.AUTHENTICATION),

        # Validation
        (r'\b(invalid|validation|required|missing|bad\s+request)\b', ErrorType.VALIDATION),
        (r'\b(must\s+be|should\s+be|cannot\s+be|is\s+not)\b', ErrorType.VALIDATION),

        # Not Found
        (r'\b(not\s+found|does\s+not\s+exist|no\s+such|unknown)\b', ErrorType.NOT_FOUND),
        (r'\b(resource|user|item|record)\s+not\s+found\b', ErrorType.NOT_FOUND),

        # Rate Limiting
        (r'\b(rate\s+limit|too\s+many\s+requests|throttl|quota)\b', ErrorType.RATE_LIMITED),
        (r'\bretry[\s-]?after\b', ErrorType.RATE_LIMITED),

        # Server Errors
        (r'\b(internal\s+server\s+error|server\s+error|unexpected\s+error)\b', ErrorType.SERVER_ERROR),
        (r'\b(exception|traceback|stack\s+trace)\b', ErrorType.SERVER_ERROR),

        # WAF/Security
        (r'\b(blocked|security|firewall|waf|protection)\b', ErrorType.WAF_BLOCKED),
        (r'\b(suspicious|malicious|attack|threat)\b', ErrorType.WAF_BLOCKED),

        # Generic errors
        (r'\b(error|failed|failure|problem|issue)\b', ErrorType.APPLICATION_ERROR),
    ]

    # WAF detection patterns
    WAF_PATTERNS = [
        r'cloudflare',
        r'akamai',
        r'incapsula',
        r'sucuri',
        r'mod_security',
        r'web\s*application\s*firewall',
        r'request\s+blocked',
        r'access\s+denied.*security',
    ]

    def __init__(self):
        """Initialize ResponseAnalyzer."""
        self._error_patterns = [
            (re.compile(pattern, re.IGNORECASE), error_type)
            for pattern, error_type in self.ERROR_PATTERNS
        ]
        self._waf_patterns = [
            re.compile(pattern, re.IGNORECASE)
            for pattern in self.WAF_PATTERNS
        ]

    def analyze(self, evidence: "Evidence") -> ResponseVerdict:
        """Analyze a response to determine true success/failure state.

        Args:
            evidence: Evidence object from HTTP response

        Returns:
            ResponseVerdict with analysis results
        """
        signals: dict[ResponseSignal, Any] = {}
        error_type = ErrorType.NONE
        is_success = False
        is_error = False

        # Signal 1: HTTP Status Code
        status = evidence.response_status
        signals[ResponseSignal.HTTP_STATUS] = status

        if status == 0:
            return ResponseVerdict(
                is_success=False,
                is_error=True,
                confidence=1.0,
                error_type=ErrorType.TIMEOUT if "timeout" in str(evidence.response_body).lower() else ErrorType.CONNECTION,
                signals=signals,
                description="Request failed (no response)",
            )

        # Initial assessment from HTTP status
        if 200 <= status < 300:
            is_success = True
        elif status == 401:
            is_error = True
            error_type = ErrorType.AUTHENTICATION
        elif status == 403:
            is_error = True
            error_type = ErrorType.AUTHORIZATION
        elif status == 404:
            is_error = True
            error_type = ErrorType.NOT_FOUND
        elif status == 429:
            is_error = True
            error_type = ErrorType.RATE_LIMITED
        elif 400 <= status < 500:
            is_error = True
            error_type = ErrorType.VALIDATION
        elif status >= 500:
            is_error = True
            error_type = ErrorType.SERVER_ERROR

        # Signal 2: Content-Type
        content_type = self._get_content_type(evidence)
        signals[ResponseSignal.CONTENT_TYPE] = content_type

        # Signal 3: Parse body for status fields
        body = evidence.response_body or ""
        json_data = self._try_parse_json(body)

        if json_data:
            status_value = self._find_status_field(json_data)
            signals[ResponseSignal.JSON_STATUS_FIELD] = status_value

            if status_value is not None:
                str_value = str(status_value).lower()
                if status_value in self.SUCCESS_VALUES or str_value in [str(v).lower() for v in self.SUCCESS_VALUES]:
                    # JSON says success
                    if not is_success:
                        is_success = True
                        is_error = False
                        error_type = ErrorType.NONE
                elif status_value in self.ERROR_VALUES or str_value in [str(v).lower() for v in self.ERROR_VALUES]:
                    # JSON says error
                    is_success = False
                    is_error = True
                    if error_type == ErrorType.NONE:
                        error_type = ErrorType.APPLICATION_ERROR

        # Signal 4: Error message patterns
        body_lower = body.lower()
        detected_error = self._detect_error_pattern(body_lower)
        if detected_error != ErrorType.NONE:
            signals[ResponseSignal.ERROR_MESSAGE] = detected_error.name
            if error_type == ErrorType.NONE or error_type == ErrorType.APPLICATION_ERROR:
                error_type = detected_error
            if detected_error not in (ErrorType.NONE, ErrorType.UNKNOWN):
                is_error = True
                is_success = False

        # Signal 5: WAF detection
        if self._detect_waf(evidence):
            signals[ResponseSignal.HEADER_INDICATOR] = "WAF"
            error_type = ErrorType.WAF_BLOCKED
            is_error = True
            is_success = False

        # Signal 6: Content length anomalies
        content_length = len(body)
        signals[ResponseSignal.CONTENT_LENGTH] = content_length

        # Very short responses with 200 status might be errors
        if is_success and content_length < 20 and not json_data:
            # Suspicious - might be an error page
            pass  # Lower confidence but don't override

        # Signal 7: Response time
        response_time = evidence.response_time_ms if hasattr(evidence, 'response_time_ms') else 0
        signals[ResponseSignal.RESPONSE_TIME] = response_time

        # Calculate confidence
        confidence = self._calculate_confidence(signals, is_success, is_error)

        return ResponseVerdict(
            is_success=is_success,
            is_error=is_error,
            confidence=confidence,
            error_type=error_type,
            signals=signals,
            description=self._describe_verdict(is_success, is_error, error_type, signals),
        )

    def fingerprint(self, evidence: "Evidence") -> ResponseFingerprint:
        """Create a fingerprint of a response for comparison.

        Args:
            evidence: Evidence object

        Returns:
            ResponseFingerprint
        """
        body = evidence.response_body or ""
        json_data = self._try_parse_json(body)

        json_keys = set()
        status_value = None
        error_value = None
        has_data = False

        if json_data:
            json_keys = self._get_json_keys(json_data)
            status_value = self._find_status_field(json_data)
            error_value = self._find_error_field(json_data)
            has_data = "data" in json_data or "result" in json_data or "items" in json_data

        return ResponseFingerprint(
            status_code=evidence.response_status,
            content_type=self._get_content_type(evidence),
            content_length=len(body),
            response_time_ms=getattr(evidence, 'response_time_ms', 0),
            body_hash=hashlib.md5(body.encode()).hexdigest()[:16],
            json_keys=json_keys,
            status_field_value=status_value,
            error_field_value=error_value,
            has_data=has_data,
        )

    def compare(
        self,
        test_evidence: "Evidence",
        baseline_evidence: "Evidence",
        timing_threshold: float = 3.0,
    ) -> ResponseVerdict:
        """Compare test response against baseline to detect anomalies.

        Args:
            test_evidence: Response to test
            baseline_evidence: Expected/baseline response
            timing_threshold: Multiplier for timing anomaly (default: 3x)

        Returns:
            ResponseVerdict with comparison results
        """
        test_fp = self.fingerprint(test_evidence)
        baseline_fp = self.fingerprint(baseline_evidence)

        differences = []
        is_anomaly = False

        # Compare status codes
        if test_fp.status_code != baseline_fp.status_code:
            differences.append(f"Status: {baseline_fp.status_code} -> {test_fp.status_code}")
            is_anomaly = True

        # Compare content type
        if test_fp.content_type != baseline_fp.content_type:
            differences.append(f"Content-Type changed")
            is_anomaly = True

        # Compare JSON structure
        if test_fp.json_keys != baseline_fp.json_keys:
            added = test_fp.json_keys - baseline_fp.json_keys
            removed = baseline_fp.json_keys - test_fp.json_keys
            if added:
                differences.append(f"New fields: {added}")
                is_anomaly = True
            if removed:
                differences.append(f"Missing fields: {removed}")
                is_anomaly = True

        # Compare status field value
        if test_fp.status_field_value != baseline_fp.status_field_value:
            differences.append(f"Status field: {baseline_fp.status_field_value} -> {test_fp.status_field_value}")
            is_anomaly = True

        # Compare timing
        if baseline_fp.response_time_ms > 0:
            timing_ratio = test_fp.response_time_ms / baseline_fp.response_time_ms
            if timing_ratio > timing_threshold:
                differences.append(f"Timing anomaly: {timing_ratio:.1f}x slower")
                is_anomaly = True

        # Compare content length (significant change)
        if baseline_fp.content_length > 0:
            length_ratio = test_fp.content_length / baseline_fp.content_length
            if length_ratio < 0.5 or length_ratio > 2.0:
                differences.append(f"Content length: {baseline_fp.content_length} -> {test_fp.content_length}")
                is_anomaly = True

        # Compare body hash
        if test_fp.body_hash != baseline_fp.body_hash:
            differences.append("Response body changed")
            # Don't mark as anomaly just for body change (expected in many cases)

        # Get analysis of test response
        test_verdict = self.analyze(test_evidence)

        return ResponseVerdict(
            is_success=test_verdict.is_success,
            is_error=test_verdict.is_error,
            is_anomaly=is_anomaly,
            confidence=test_verdict.confidence,
            error_type=test_verdict.error_type,
            signals=test_verdict.signals,
            differences=differences,
            description=self._describe_comparison(differences, is_anomaly),
        )

    def is_true_success(self, evidence: "Evidence") -> bool:
        """Quick check if response represents true success.

        Args:
            evidence: Evidence to check

        Returns:
            True if response indicates genuine success
        """
        verdict = self.analyze(evidence)
        return verdict.is_success and verdict.confidence >= 0.7

    def is_true_error(self, evidence: "Evidence") -> bool:
        """Quick check if response represents true error.

        Args:
            evidence: Evidence to check

        Returns:
            True if response indicates genuine error
        """
        verdict = self.analyze(evidence)
        return verdict.is_error and verdict.confidence >= 0.7

    def _get_content_type(self, evidence: "Evidence") -> str:
        """Extract content type from headers."""
        for name, value in evidence.response_headers.items():
            if name.lower() == "content-type":
                return value.split(";")[0].strip().lower()
        return ""

    def _try_parse_json(self, body: str) -> dict | list | None:
        """Try to parse body as JSON."""
        try:
            return json.loads(body)
        except (json.JSONDecodeError, TypeError):
            return None

    def _find_status_field(self, data: dict | list) -> Any:
        """Find status field value in JSON data."""
        if isinstance(data, dict):
            for field in self.STATUS_FIELDS:
                if field in data:
                    return data[field]
                # Try case-insensitive
                for key in data:
                    if key.lower() == field.lower():
                        return data[key]
        return None

    def _find_error_field(self, data: dict | list) -> Any:
        """Find error field value in JSON data."""
        if isinstance(data, dict):
            error_fields = ["error", "errors", "error_message", "errorMessage", "message", "msg"]
            for field in error_fields:
                if field in data and data[field]:
                    return data[field]
        return None

    def _get_json_keys(self, data: dict | list, prefix: str = "") -> set[str]:
        """Recursively get all JSON keys."""
        keys = set()
        if isinstance(data, dict):
            for key, value in data.items():
                full_key = f"{prefix}.{key}" if prefix else key
                keys.add(full_key)
                if isinstance(value, (dict, list)):
                    keys.update(self._get_json_keys(value, full_key))
        elif isinstance(data, list) and data:
            if isinstance(data[0], dict):
                keys.update(self._get_json_keys(data[0], f"{prefix}[]"))
        return keys

    def _detect_error_pattern(self, text: str) -> ErrorType:
        """Detect error type from text patterns."""
        for pattern, error_type in self._error_patterns:
            if pattern.search(text):
                return error_type
        return ErrorType.NONE

    def _detect_waf(self, evidence: "Evidence") -> bool:
        """Detect if response is from a WAF."""
        # Check headers
        waf_headers = ["cf-ray", "x-sucuri-id", "x-akamai-transformed", "x-cdn"]
        for header in evidence.response_headers:
            if header.lower() in waf_headers:
                return True

        # Check body
        body = evidence.response_body or ""
        for pattern in self._waf_patterns:
            if pattern.search(body):
                return True

        return False

    def _calculate_confidence(
        self,
        signals: dict[ResponseSignal, Any],
        is_success: bool,
        is_error: bool,
    ) -> float:
        """Calculate confidence in the verdict."""
        confidence = 0.5  # Start at 50%

        # HTTP status alignment
        status = signals.get(ResponseSignal.HTTP_STATUS, 0)
        if is_success and 200 <= status < 300:
            confidence += 0.2
        elif is_error and status >= 400:
            confidence += 0.2

        # JSON status field alignment
        json_status = signals.get(ResponseSignal.JSON_STATUS_FIELD)
        if json_status is not None:
            if is_success and json_status in self.SUCCESS_VALUES:
                confidence += 0.2
            elif is_error and json_status in self.ERROR_VALUES:
                confidence += 0.2
            elif is_success and json_status in self.ERROR_VALUES:
                confidence -= 0.2  # Contradiction
            elif is_error and json_status in self.SUCCESS_VALUES:
                confidence -= 0.2

        # Error message detected
        if signals.get(ResponseSignal.ERROR_MESSAGE):
            if is_error:
                confidence += 0.1
            else:
                confidence -= 0.1

        return min(1.0, max(0.0, confidence))

    def _describe_verdict(
        self,
        is_success: bool,
        is_error: bool,
        error_type: ErrorType,
        signals: dict,
    ) -> str:
        """Generate human-readable description."""
        if is_success:
            return f"Success (HTTP {signals.get(ResponseSignal.HTTP_STATUS, '?')})"
        elif is_error:
            return f"Error: {error_type.name} (HTTP {signals.get(ResponseSignal.HTTP_STATUS, '?')})"
        else:
            return "Indeterminate response"

    def _describe_comparison(self, differences: list[str], is_anomaly: bool) -> str:
        """Generate comparison description."""
        if not differences:
            return "Response matches baseline"
        elif is_anomaly:
            return f"Anomaly detected: {', '.join(differences)}"
        else:
            return f"Minor differences: {', '.join(differences)}"


# Singleton instance for convenience
_analyzer = ResponseAnalyzer()


def analyze_response(evidence: "Evidence") -> ResponseVerdict:
    """Quick analysis of a response.

    Args:
        evidence: Evidence to analyze

    Returns:
        ResponseVerdict
    """
    return _analyzer.analyze(evidence)


def is_success(evidence: "Evidence") -> bool:
    """Quick check if response is successful.

    Args:
        evidence: Evidence to check

    Returns:
        True if successful
    """
    return _analyzer.is_true_success(evidence)


def is_error(evidence: "Evidence") -> bool:
    """Quick check if response is an error.

    Args:
        evidence: Evidence to check

    Returns:
        True if error
    """
    return _analyzer.is_true_error(evidence)
