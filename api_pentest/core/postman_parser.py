import json
import logging
import re
from typing import Any

from api_pentest.core.models import BodyMode, Endpoint

logger = logging.getLogger(__name__)


class PostmanParser:
    """
    Custom parser for Postman Collection v2.0 and v2.1.

    Handles key differences between versions:
    - v2.0: auth params are flat objects, URL is a plain string
    - v2.1: auth params are [{key, value, type}] arrays, URL is a structured object
    """

    VARIABLE_PATTERN = re.compile(r"\{\{([^}]+)\}\}")

    def __init__(self, data: dict, environment_data: dict | None = None):
        self.data = data
        self.env_data = environment_data
        self.warnings: list[str] = []
        self._variables: dict[str, str] = {}
        self._is_v21 = self._detect_version()

    def _detect_version(self) -> bool:
        """Detect if this is v2.1 (vs v2.0)."""
        schema = self.data.get("info", {}).get("schema", "")
        return "v2.1" in str(schema)

    def parse(self) -> list[Endpoint]:
        """Parse the collection and return a list of Endpoint objects."""
        self._load_variables()
        items = self.data.get("item", [])
        collection_auth = self.data.get("auth")

        endpoints: list[Endpoint] = []
        self._walk_items(items, endpoints, folder_path="", parent_auth=collection_auth)

        logger.info(f"Parsed {len(endpoints)} endpoints from Postman collection")
        return endpoints

    def _load_variables(self):
        """Load variables from collection and environment."""
        for var in self.data.get("variable", []):
            key = var.get("key", "")
            value = var.get("value", "")
            if key:
                self._variables[key] = str(value) if value is not None else ""

        if self.env_data:
            for var in self.env_data.get("values", []):
                if var.get("enabled", True):
                    key = var.get("key", "")
                    value = var.get("value", "")
                    if key:
                        self._variables[key] = str(value) if value is not None else ""

    def _resolve_variables(self, text: str) -> str:
        """Replace {{variable}} placeholders with their values."""
        if not text or "{{" not in text:
            return text

        unresolved = []

        def replacer(match):
            var_name = match.group(1)
            if var_name in self._variables:
                return self._variables[var_name]
            if var_name.startswith("$"):
                return self._dynamic_variable(var_name)
            unresolved.append(var_name)
            return match.group(0)

        result = self.VARIABLE_PATTERN.sub(replacer, text)
        if unresolved:
            self.warnings.append(f"Unresolved variables: {', '.join(set(unresolved))}")
        return result

    @staticmethod
    def _dynamic_variable(name: str) -> str:
        """Generate Postman dynamic variable values."""
        import uuid
        import random
        import string
        from datetime import datetime, timezone

        mapping = {
            "$guid": str(uuid.uuid4()),
            "$timestamp": str(int(datetime.now(timezone.utc).timestamp())),
            "$isoTimestamp": datetime.now(timezone.utc).isoformat(),
            "$randomInt": str(random.randint(0, 1000)),
            "$randomFirstName": "TestUser",
            "$randomLastName": "TestLast",
            "$randomEmail": f"test{''.join(random.choices(string.digits, k=4))}@example.com",
            "$randomUUID": str(uuid.uuid4()),
        }
        return mapping.get(name, f"{{{{{name}}}}}")

    def _resolve_deep(self, obj: Any) -> Any:
        """Recursively resolve variables in strings, dicts, and lists."""
        if isinstance(obj, str):
            return self._resolve_variables(obj)
        if isinstance(obj, dict):
            return {k: self._resolve_deep(v) for k, v in obj.items()}
        if isinstance(obj, list):
            return [self._resolve_deep(item) for item in obj]
        return obj

    def _walk_items(
        self,
        items: list,
        endpoints: list[Endpoint],
        folder_path: str,
        parent_auth: dict | None,
    ):
        """Recursively walk Postman collection items."""
        for item in items:
            if not isinstance(item, dict):
                continue

            if "item" in item and "request" not in item:
                folder_name = item.get("name", "")
                new_path = f"{folder_path}/{folder_name}" if folder_path else folder_name
                folder_auth = item.get("auth") or parent_auth
                self._walk_items(item["item"], endpoints, new_path, folder_auth)
            else:
                endpoint = self._parse_request_item(item, folder_path, parent_auth)
                if endpoint:
                    endpoints.append(endpoint)

    def _parse_request_item(
        self, item: dict, folder_path: str, parent_auth: dict | None
    ) -> Endpoint | None:
        """Parse a single Postman request item into an Endpoint."""
        name = item.get("name", "")
        request = item.get("request")

        if request is None:
            return None

        if isinstance(request, str):
            return Endpoint(
                method="GET",
                url=self._resolve_variables(request),
                name=name,
                folder_path=folder_path,
            )

        method = request.get("method", "GET").upper()
        url = self._parse_url(request.get("url", ""))
        headers = self._parse_headers(request.get("header", []))
        body, body_mode = self._parse_body(request.get("body"))

        request_auth = request.get("auth")
        effective_auth = request_auth if request_auth else parent_auth
        auth_type, auth_config = self._parse_auth(effective_auth)

        unresolved = []
        for match in self.VARIABLE_PATTERN.finditer(url):
            var = match.group(1)
            if var not in self._variables and not var.startswith("$"):
                unresolved.append(var)

        path_params = re.findall(r":(\w+)", url)
        query_params = self._extract_query_params(request.get("url", ""))

        return Endpoint(
            method=method,
            url=url,
            name=name,
            folder_path=folder_path,
            headers=headers,
            body=body,
            body_mode=body_mode,
            auth_type=auth_type,
            auth_config=auth_config,
            path_params=path_params,
            query_params=query_params,
            unresolved_variables=unresolved,
        )

    def _parse_url(self, url_data: Any) -> str:
        """Parse URL from string (v2.0) or structured object (v2.1)."""
        if isinstance(url_data, str):
            return self._resolve_variables(url_data)

        if isinstance(url_data, dict):
            raw = url_data.get("raw", "")
            if raw:
                return self._resolve_variables(raw)

            protocol = url_data.get("protocol", "https")
            host = url_data.get("host", [])
            if isinstance(host, list):
                host = ".".join(host)
            path = url_data.get("path", [])
            if isinstance(path, list):
                path = "/".join(path)

            url = f"{protocol}://{host}"
            if path:
                url += f"/{path}"

            query = url_data.get("query", [])
            if query:
                params = []
                for q in query:
                    if isinstance(q, dict) and not q.get("disabled", False):
                        k = q.get("key", "")
                        v = q.get("value", "")
                        if k:
                            params.append(f"{k}={v}")
                if params:
                    url += "?" + "&".join(params)

            return self._resolve_variables(url)

        return ""

    def _parse_headers(self, headers_data: list | None) -> dict[str, str]:
        """Parse headers from Postman format."""
        if not headers_data or not isinstance(headers_data, list):
            return {}

        headers = {}
        for h in headers_data:
            if isinstance(h, dict) and not h.get("disabled", False):
                key = h.get("key", "")
                value = h.get("value", "")
                if key:
                    headers[key] = self._resolve_variables(str(value))
        return headers

    def _parse_body(self, body_data: dict | None) -> tuple[Any, BodyMode]:
        """Parse request body from Postman format."""
        if not body_data or not isinstance(body_data, dict):
            return None, BodyMode.NONE

        mode = body_data.get("mode", "none")

        if mode == "raw":
            raw = body_data.get("raw", "")
            resolved = self._resolve_variables(raw)
            try:
                return json.loads(resolved), BodyMode.RAW
            except (ValueError, TypeError):
                return resolved, BodyMode.RAW

        if mode == "urlencoded":
            params = {}
            for item in body_data.get("urlencoded", []):
                if isinstance(item, dict) and not item.get("disabled", False):
                    key = item.get("key", "")
                    value = self._resolve_variables(item.get("value", ""))
                    if key:
                        params[key] = value
            return params, BodyMode.URLENCODED

        if mode == "formdata":
            params = {}
            for item in body_data.get("formdata", []):
                if isinstance(item, dict) and not item.get("disabled", False):
                    key = item.get("key", "")
                    value = self._resolve_variables(item.get("value", ""))
                    if key:
                        params[key] = value
            return params, BodyMode.FORMDATA

        if mode == "graphql":
            gql = body_data.get("graphql", {})
            return {
                "query": self._resolve_variables(gql.get("query", "")),
                "variables": self._resolve_deep(gql.get("variables", "")),
            }, BodyMode.GRAPHQL

        if mode == "file":
            return None, BodyMode.FILE

        return None, BodyMode.NONE

    def _parse_auth(self, auth_data: dict | None) -> tuple[str, dict[str, Any]]:
        """Parse auth config (handles both v2.0 flat objects and v2.1 key-value arrays)."""
        if not auth_data or not isinstance(auth_data, dict):
            return "", {}

        auth_type = auth_data.get("type", "")
        if auth_type == "noauth":
            return "noauth", {}

        config = {}
        auth_params = auth_data.get(auth_type, [])

        if isinstance(auth_params, list):
            # v2.1 format: [{key, value, type}, ...]
            for param in auth_params:
                if isinstance(param, dict):
                    key = param.get("key", "")
                    value = param.get("value", "")
                    if key:
                        config[key] = self._resolve_variables(str(value)) if isinstance(value, str) else value
        elif isinstance(auth_params, dict):
            # v2.0 format: flat object
            for key, value in auth_params.items():
                config[key] = self._resolve_variables(str(value)) if isinstance(value, str) else value

        return auth_type, config

    def _extract_query_params(self, url_data: Any) -> dict[str, str]:
        """Extract query parameters."""
        params = {}

        if isinstance(url_data, dict):
            for q in url_data.get("query", []):
                if isinstance(q, dict) and not q.get("disabled", False):
                    key = q.get("key", "")
                    value = self._resolve_variables(q.get("value", ""))
                    if key:
                        params[key] = value
        elif isinstance(url_data, str):
            if "?" in url_data:
                query_str = url_data.split("?", 1)[1]
                for part in query_str.split("&"):
                    if "=" in part:
                        k, v = part.split("=", 1)
                        params[k] = self._resolve_variables(v)
                    else:
                        params[part] = ""

        return params
