"""
Endpoint fuzzer for discovering API endpoints when spec is unavailable.

This module provides EndpointFuzzer, which orchestrates endpoint discovery
using either Kiterunner (when available) or a built-in wordlist fallback.
Discovered endpoints are converted to Endpoint model objects for use in
the pentest toolkit's testing pipeline.

Usage:
    from api_pentest.core.endpoint_fuzzer import EndpointFuzzer
    from api_pentest.core.api_discovery import RequestBudget
    from api_pentest.core.http_client import PentestHttpClient

    http = PentestHttpClient()
    budget = RequestBudget(max_requests=100)
    fuzzer = EndpointFuzzer(
        base_url="https://api.example.com",
        http_client=http,
        budget=budget,
    )
    endpoints = fuzzer.fuzz()
"""

import logging
import subprocess
import tarfile
import tempfile
from pathlib import Path
from typing import TYPE_CHECKING
from urllib.request import urlretrieve

from api_pentest.core.kiterunner_adapter import KiterunnerAdapter, KiterunnerNotFoundError
from api_pentest.core.endpoint_wordlist import API_ENDPOINTS
from api_pentest.core.models import Endpoint, EndpointClassification, Evidence

if TYPE_CHECKING:
    from api_pentest.core.api_discovery import RequestBudget
    from api_pentest.core.http_client import PentestHttpClient

logger = logging.getLogger(__name__)


class EndpointFuzzer:
    """Orchestrates API endpoint discovery via fuzzing.

    Uses Kiterunner when available for intelligent content discovery,
    falling back to a built-in wordlist when Kiterunner is not installed.
    All discovered endpoints are converted to Endpoint model objects with
    a conservative PROTECTED classification (since we can't determine auth
    requirements from fuzzing alone).

    Attributes:
        base_url: The target API base URL (without trailing slash).
        http_client: PentestHttpClient for making validation requests.
        budget: RequestBudget to limit discovery requests.
        kr: KiterunnerAdapter instance for external tool integration.

    Example:
        fuzzer = EndpointFuzzer(base_url, http_client, budget)
        endpoints = fuzzer.fuzz()
        for ep in endpoints:
            print(f"Discovered: {ep.method} {ep.url}")
    """

    # Content types that indicate an API response
    API_CONTENT_TYPES = frozenset({
        "application/json",
        "application/xml",
        "text/json",
        "text/xml",
        "application/hal+json",
        "application/vnd.api+json",
        "application/problem+json",
    })

    def __init__(
        self,
        base_url: str,
        http_client: "PentestHttpClient",
        budget: "RequestBudget",
    ):
        """Initialize EndpointFuzzer.

        Args:
            base_url: Target API base URL (trailing slash will be stripped).
            http_client: PentestHttpClient instance for HTTP requests.
            budget: RequestBudget to limit discovery requests.
        """
        self.base_url = base_url.rstrip("/") if base_url else ""
        self.http_client = http_client
        self.budget = budget
        # Use 30s timeout for Kiterunner (faster batch scanning)
        self.kr = KiterunnerAdapter(timeout=30)

    def fuzz(self) -> list[Endpoint]:
        """Discover API endpoints via fuzzing.

        Uses Kiterunner if available, otherwise falls back to the built-in
        wordlist. All discovered endpoints are returned as Endpoint objects.

        Returns:
            List of Endpoint objects discovered via fuzzing.
        """
        if self.kr.is_available():
            logger.info("Using Kiterunner for endpoint discovery")
            return self._fuzz_with_kiterunner()
        else:
            logger.warning(
                "Kiterunner not found, falling back to built-in wordlist. "
                "For better coverage, install Kiterunner: "
                "https://github.com/assetnote/kiterunner"
            )
            return self._fuzz_with_wordlist()

    # Wordlist download URLs
    WORDLIST_DOWNLOADS = {
        "routes-large.kite": "https://wordlists-cdn.assetnote.io/data/kiterunner/routes-large.kite.tar.gz",
        "swagger-wordlist.txt": "https://wordlists-cdn.assetnote.io/data/kiterunner/swagger-wordlist.txt",
    }

    def _fuzz_with_kiterunner(self) -> list[Endpoint]:
        """Discover endpoints using Kiterunner with built-in wordlist fallback.

        Tries routes-small.kite first, falls back to built-in wordlist if no
        endpoints found.

        Returns:
            List of validated Endpoint objects.
        """
        # Try Kiterunner with bundled .kite wordlist
        endpoints = self._scan_with_wordlist(None, "routes-small.kite")

        if endpoints:
            return endpoints

        # Kiterunner found nothing, fall back to built-in wordlist
        logger.info("Kiterunner found 0 endpoints, trying built-in wordlist...")
        return self._fuzz_with_wordlist()

    def _offer_download_wordlist(self, wordlist_name: str, download_key: str) -> bool:
        """Offer to download a wordlist that isn't present locally.

        Args:
            wordlist_name: Human-readable name for display.
            download_key: Key in WORDLIST_DOWNLOADS dict.

        Returns:
            True if wordlist was downloaded successfully, False otherwise.
        """
        if download_key not in self.WORDLIST_DOWNLOADS:
            return False

        try:
            print(f"\n[?] {wordlist_name} not found locally. Download it? [y/N] ", end="", flush=True)
            response = input().strip().lower()
            if response not in ("y", "yes"):
                logger.info("User declined to download %s", wordlist_name)
                return False
        except (EOFError, KeyboardInterrupt):
            return False

        # Download the wordlist
        url = self.WORDLIST_DOWNLOADS[download_key]
        dest_dir = self.kr.WORDLISTS_DIR
        dest_file = dest_dir / download_key

        print(f"[*] Downloading {download_key}...")
        logger.info("Downloading %s from %s", download_key, url)

        try:
            if url.endswith(".tar.gz"):
                # Download and extract tarball
                with tempfile.NamedTemporaryFile(suffix=".tar.gz", delete=False) as tmp:
                    urlretrieve(url, tmp.name)
                    with tarfile.open(tmp.name, "r:gz") as tar:
                        tar.extractall(path=dest_dir)
                    Path(tmp.name).unlink()
            else:
                # Direct download
                urlretrieve(url, dest_file)

            if dest_file.exists():
                print(f"[+] Downloaded {download_key} ({dest_file.stat().st_size // (1024*1024)}MB)")
                return True
            else:
                print(f"[-] Download failed: {download_key} not found after extraction")
                return False

        except Exception as e:
            logger.warning("Failed to download %s: %s", download_key, e)
            print(f"[-] Download failed: {e}")
            return False

    def _scan_with_wordlist(self, wordlist_path: str | None, wordlist_name: str) -> list[Endpoint]:
        """Scan target with a specific wordlist.

        Args:
            wordlist_path: Path to wordlist file, or None for default.
            wordlist_name: Human-readable wordlist name for logging.

        Returns:
            List of discovered Endpoint objects (empty if none found).
        """
        endpoints: list[Endpoint] = []
        seen: set[tuple[str, str]] = set()

        logger.info("Scanning with %s...", wordlist_name)

        try:
            for result in self.kr.scan(self.base_url, wordlist=wordlist_path):
                endpoint = self._discovered_to_endpoint(result)
                if endpoint is None:
                    continue

                # Deduplicate by (method, url)
                key = (endpoint.method, endpoint.url)
                if key in seen:
                    continue
                seen.add(key)

                # Optional: validate with follow-up request (use budget)
                if self.budget.can_request():
                    if self._validate_endpoint(endpoint):
                        endpoints.append(endpoint)
                else:
                    # Budget exhausted, add without validation
                    endpoints.append(endpoint)
                    logger.debug(
                        "Budget exhausted, adding unvalidated: %s %s",
                        endpoint.method,
                        endpoint.url,
                    )

        except KiterunnerNotFoundError:
            logger.warning("Kiterunner became unavailable during scan")
            return []
        except KeyboardInterrupt:
            logger.info("Scan interrupted by user (Ctrl+C)")
            raise

        logger.info(
            "Kiterunner (%s) discovered %d endpoints at %s",
            wordlist_name,
            len(endpoints),
            self.base_url,
        )

        return endpoints

    def _fuzz_with_wordlist(self) -> list[Endpoint]:
        """Discover endpoints using built-in wordlist.

        Iterates through API_ENDPOINTS, makes GET requests, and collects
        endpoints that return API-like responses. Exits early after 5
        consecutive timeouts/errors to avoid wasting time on unreachable hosts.

        Returns:
            List of Endpoint objects discovered via wordlist fuzzing.
        """
        endpoints: list[Endpoint] = []
        consecutive_errors = 0
        MAX_CONSECUTIVE_ERRORS = 5

        for idx, path in enumerate(API_ENDPOINTS):
            # Check budget before each request
            if not self.budget.can_request():
                logger.info(
                    "Request budget exhausted after testing %d/%d paths",
                    idx,
                    len(API_ENDPOINTS),
                )
                break

            url = f"{self.base_url}{path}"

            try:
                evidence = self.http_client.request(
                    method="GET",
                    url=url,
                    headers={},
                )
                self.budget.record()

                # Check for timeout/connection error (status 0)
                if evidence.response_status == 0:
                    consecutive_errors += 1
                    if consecutive_errors >= MAX_CONSECUTIVE_ERRORS:
                        logger.warning(
                            "Host unreachable after %d timeouts, stopping wordlist scan at %d/%d paths",
                            consecutive_errors, idx, len(API_ENDPOINTS),
                        )
                        break
                    continue

                consecutive_errors = 0  # Reset on successful request

                # Check if response looks like an API endpoint
                if self._is_valid_discovery(evidence):
                    endpoint = Endpoint(
                        method="GET",
                        url=url,
                        name=f"GET {path}",
                        classification=EndpointClassification.PROTECTED,
                        classification_reason="Discovered via wordlist fuzzing",
                    )
                    endpoints.append(endpoint)
                    logger.debug("Found endpoint: GET %s (status=%d)", path, evidence.response_status)

            except KeyboardInterrupt:
                logger.info("Wordlist scan interrupted by user (Ctrl+C)")
                raise
            except Exception as e:
                consecutive_errors += 1
                logger.debug("Error probing %s: %s", path, e)
                if consecutive_errors >= MAX_CONSECUTIVE_ERRORS:
                    logger.warning(
                        "Too many errors, stopping wordlist scan at %d/%d paths",
                        idx, len(API_ENDPOINTS),
                    )
                    break

        logger.info(
            "Wordlist fuzzing discovered %d endpoints at %s",
            len(endpoints),
            self.base_url,
        )
        return endpoints

    def _discovered_to_endpoint(self, discovered: dict) -> Endpoint | None:
        """Convert Kiterunner discovery result to Endpoint object.

        Kiterunner JSON output typically contains:
        - method: HTTP method
        - path: Discovered path
        - status: Response status code
        - length: Response body length
        - host: Target host (may be present)

        Args:
            discovered: Dictionary from Kiterunner JSON output.

        Returns:
            Endpoint object, or None if conversion fails.
        """
        if not isinstance(discovered, dict):
            return None

        # Extract method (default GET)
        method = discovered.get("method", "GET")
        if isinstance(method, str):
            method = method.upper()
        else:
            method = "GET"

        # Extract path (required)
        path = discovered.get("path") or discovered.get("uri") or discovered.get("url")
        if not path:
            logger.debug("Kiterunner result missing path: %s", discovered)
            return None

        # Ensure path starts with /
        if not path.startswith("/"):
            path = f"/{path}"

        # Build full URL
        url = f"{self.base_url}{path}"

        # Get status for logging
        status = discovered.get("status", 0)

        return Endpoint(
            method=method,
            url=url,
            name=f"{method} {path}",
            classification=EndpointClassification.PROTECTED,  # Conservative default
            classification_reason=f"Discovered via Kiterunner (status={status})",
        )

    def _validate_endpoint(self, endpoint: Endpoint) -> bool:
        """Validate a discovered endpoint with a follow-up request.

        Makes a request to confirm the endpoint exists and returns
        an API-like response.

        Args:
            endpoint: Endpoint to validate.

        Returns:
            True if endpoint is valid, False otherwise.
        """
        try:
            evidence = self.http_client.request(
                method=endpoint.method,
                url=endpoint.url,
                headers={},
            )
            self.budget.record()

            return self._is_valid_discovery(evidence)

        except Exception as e:
            logger.debug("Validation failed for %s: %s", endpoint.url, e)
            return False

    def _is_valid_discovery(self, evidence: Evidence) -> bool:
        """Check if a response indicates a valid API endpoint.

        Considers both status code and content type to filter out
        HTML error pages and non-API responses.

        Args:
            evidence: Evidence object from HTTP response.

        Returns:
            True if response looks like a valid API endpoint.
        """
        # Accept various status codes that indicate endpoint exists
        # 200 - OK
        # 201 - Created
        # 204 - No Content
        # 400 - Bad Request (endpoint exists but invalid input)
        # 401 - Unauthorized (endpoint exists, needs auth)
        # 403 - Forbidden (endpoint exists, needs permission)
        # 405 - Method Not Allowed (endpoint exists, wrong method)
        valid_statuses = {200, 201, 204, 400, 401, 403, 405}

        if evidence.response_status not in valid_statuses:
            return False

        # Check content type
        if self._is_api_response(evidence):
            return True

        # For 401/403/405, accept even without API content type
        # These strongly indicate an API endpoint exists
        if evidence.response_status in {401, 403, 405}:
            return True

        return False

    def _is_api_response(self, evidence: Evidence) -> bool:
        """Check if response content type indicates an API response.

        Args:
            evidence: Evidence object from HTTP response.

        Returns:
            True if content type is API-like or body looks like JSON/XML.
        """
        # Check Content-Type header
        content_type = ""
        for header_name, header_val in evidence.response_headers.items():
            if header_name.lower() == "content-type":
                # Normalize: strip charset and extra params
                content_type = header_val.split(";")[0].strip().lower()
                break

        if content_type in self.API_CONTENT_TYPES:
            return True

        # Fallback: check if body looks like JSON or XML
        body = evidence.response_body.strip() if evidence.response_body else ""
        if body:
            # JSON: starts with { or [
            if body.startswith("{") or body.startswith("["):
                return True
            # XML: starts with <
            if body.startswith("<") and not body.lower().startswith("<!doctype"):
                # Exclude HTML documents
                if "<html" not in body.lower()[:500]:
                    return True

        return False
