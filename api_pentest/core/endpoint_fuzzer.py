"""
Endpoint fuzzer for discovering API endpoints when spec is unavailable.

This module provides EndpointFuzzer, which orchestrates endpoint discovery
using either Kiterunner (when available) or a built-in wordlist fallback.
Discovered endpoints are converted to Endpoint model objects for use in
the pentest toolkit's testing pipeline.

Usage:
    from api_pentest.core.endpoint_fuzzer import EndpointFuzzer
    from api_pentest.core.api_discovery import RequestBudget
    from api_pentest.core.http_client import PentestHttpClient

    http = PentestHttpClient()
    budget = RequestBudget(max_requests=100)
    fuzzer = EndpointFuzzer(
        base_url="https://api.example.com",
        http_client=http,
        budget=budget,
    )
    endpoints = fuzzer.fuzz()
"""

import logging
from typing import TYPE_CHECKING

from api_pentest.core.kiterunner_adapter import KiterunnerAdapter, KiterunnerNotFoundError
from api_pentest.core.endpoint_wordlist import API_ENDPOINTS
from api_pentest.core.models import Endpoint, EndpointClassification, Evidence

if TYPE_CHECKING:
    from api_pentest.core.api_discovery import RequestBudget
    from api_pentest.core.http_client import PentestHttpClient

logger = logging.getLogger(__name__)


class EndpointFuzzer:
    """Orchestrates API endpoint discovery via fuzzing.

    Uses Kiterunner when available for intelligent content discovery,
    falling back to a built-in wordlist when Kiterunner is not installed.
    All discovered endpoints are converted to Endpoint model objects with
    a conservative PROTECTED classification (since we can't determine auth
    requirements from fuzzing alone).

    Attributes:
        base_url: The target API base URL (without trailing slash).
        http_client: PentestHttpClient for making validation requests.
        budget: RequestBudget to limit discovery requests.
        kr: KiterunnerAdapter instance for external tool integration.

    Example:
        fuzzer = EndpointFuzzer(base_url, http_client, budget)
        endpoints = fuzzer.fuzz()
        for ep in endpoints:
            print(f"Discovered: {ep.method} {ep.url}")
    """

    # Content types that indicate an API response
    API_CONTENT_TYPES = frozenset({
        "application/json",
        "application/xml",
        "text/json",
        "text/xml",
        "application/hal+json",
        "application/vnd.api+json",
        "application/problem+json",
    })

    def __init__(
        self,
        base_url: str,
        http_client: "PentestHttpClient",
        budget: "RequestBudget",
    ):
        """Initialize EndpointFuzzer.

        Args:
            base_url: Target API base URL (trailing slash will be stripped).
            http_client: PentestHttpClient instance for HTTP requests.
            budget: RequestBudget to limit discovery requests.
        """
        self.base_url = base_url.rstrip("/") if base_url else ""
        self.http_client = http_client
        self.budget = budget
        self.kr = KiterunnerAdapter()

    def fuzz(self) -> list[Endpoint]:
        """Discover API endpoints via fuzzing.

        Uses Kiterunner if available, otherwise falls back to the built-in
        wordlist. All discovered endpoints are returned as Endpoint objects.

        Returns:
            List of Endpoint objects discovered via fuzzing.
        """
        if self.kr.is_available():
            logger.info("Using Kiterunner for endpoint discovery")
            return self._fuzz_with_kiterunner()
        else:
            logger.warning(
                "Kiterunner not found, falling back to built-in wordlist. "
                "For better coverage, install Kiterunner: "
                "https://github.com/assetnote/kiterunner"
            )
            return self._fuzz_with_wordlist()

    def _fuzz_with_kiterunner(self) -> list[Endpoint]:
        """Discover endpoints using Kiterunner.

        Runs Kiterunner scan, converts results to Endpoint objects,
        filters duplicates, and optionally validates with follow-up requests.

        Returns:
            List of validated Endpoint objects.
        """
        endpoints: list[Endpoint] = []
        seen: set[tuple[str, str]] = set()  # (method, url) for deduplication

        try:
            for result in self.kr.scan(self.base_url):
                endpoint = self._discovered_to_endpoint(result)
                if endpoint is None:
                    continue

                # Deduplicate by (method, url)
                key = (endpoint.method, endpoint.url)
                if key in seen:
                    continue
                seen.add(key)

                # Optional: validate with follow-up request (use budget)
                if self.budget.can_request():
                    if self._validate_endpoint(endpoint):
                        endpoints.append(endpoint)
                else:
                    # Budget exhausted, add without validation
                    endpoints.append(endpoint)
                    logger.debug(
                        "Budget exhausted, adding unvalidated: %s %s",
                        endpoint.method,
                        endpoint.url,
                    )

        except KiterunnerNotFoundError:
            logger.warning("Kiterunner became unavailable during scan, falling back")
            return self._fuzz_with_wordlist()

        logger.info(
            "Kiterunner discovered %d endpoints at %s",
            len(endpoints),
            self.base_url,
        )

        # Fall back to wordlist if Kiterunner found nothing
        if not endpoints:
            logger.warning(
                "Kiterunner found 0 endpoints, falling back to built-in wordlist"
            )
            return self._fuzz_with_wordlist()

        return endpoints

    def _fuzz_with_wordlist(self) -> list[Endpoint]:
        """Discover endpoints using built-in wordlist.

        Iterates through API_ENDPOINTS, makes GET requests, and collects
        endpoints that return API-like responses.

        Returns:
            List of Endpoint objects discovered via wordlist fuzzing.
        """
        endpoints: list[Endpoint] = []

        for path in API_ENDPOINTS:
            # Check budget before each request
            if not self.budget.can_request():
                logger.info(
                    "Request budget exhausted after testing %d/%d paths",
                    API_ENDPOINTS.index(path),
                    len(API_ENDPOINTS),
                )
                break

            url = f"{self.base_url}{path}"

            try:
                evidence = self.http_client.request(
                    method="GET",
                    url=url,
                    headers={},
                )
                self.budget.record()

                # Check if response looks like an API endpoint
                if self._is_valid_discovery(evidence):
                    endpoint = Endpoint(
                        method="GET",
                        url=url,
                        name=f"GET {path}",
                        classification=EndpointClassification.PROTECTED,
                        classification_reason="Discovered via wordlist fuzzing",
                    )
                    endpoints.append(endpoint)
                    logger.debug("Found endpoint: GET %s (status=%d)", path, evidence.response_status)

            except Exception as e:
                logger.debug("Error probing %s: %s", path, e)
                continue

        logger.info(
            "Wordlist fuzzing discovered %d endpoints at %s",
            len(endpoints),
            self.base_url,
        )
        return endpoints

    def _discovered_to_endpoint(self, discovered: dict) -> Endpoint | None:
        """Convert Kiterunner discovery result to Endpoint object.

        Kiterunner JSON output typically contains:
        - method: HTTP method
        - path: Discovered path
        - status: Response status code
        - length: Response body length
        - host: Target host (may be present)

        Args:
            discovered: Dictionary from Kiterunner JSON output.

        Returns:
            Endpoint object, or None if conversion fails.
        """
        if not isinstance(discovered, dict):
            return None

        # Extract method (default GET)
        method = discovered.get("method", "GET")
        if isinstance(method, str):
            method = method.upper()
        else:
            method = "GET"

        # Extract path (required)
        path = discovered.get("path") or discovered.get("uri") or discovered.get("url")
        if not path:
            logger.debug("Kiterunner result missing path: %s", discovered)
            return None

        # Ensure path starts with /
        if not path.startswith("/"):
            path = f"/{path}"

        # Build full URL
        url = f"{self.base_url}{path}"

        # Get status for logging
        status = discovered.get("status", 0)

        return Endpoint(
            method=method,
            url=url,
            name=f"{method} {path}",
            classification=EndpointClassification.PROTECTED,  # Conservative default
            classification_reason=f"Discovered via Kiterunner (status={status})",
        )

    def _validate_endpoint(self, endpoint: Endpoint) -> bool:
        """Validate a discovered endpoint with a follow-up request.

        Makes a request to confirm the endpoint exists and returns
        an API-like response.

        Args:
            endpoint: Endpoint to validate.

        Returns:
            True if endpoint is valid, False otherwise.
        """
        try:
            evidence = self.http_client.request(
                method=endpoint.method,
                url=endpoint.url,
                headers={},
            )
            self.budget.record()

            return self._is_valid_discovery(evidence)

        except Exception as e:
            logger.debug("Validation failed for %s: %s", endpoint.url, e)
            return False

    def _is_valid_discovery(self, evidence: Evidence) -> bool:
        """Check if a response indicates a valid API endpoint.

        Considers both status code and content type to filter out
        HTML error pages and non-API responses.

        Args:
            evidence: Evidence object from HTTP response.

        Returns:
            True if response looks like a valid API endpoint.
        """
        # Accept various status codes that indicate endpoint exists
        # 200 - OK
        # 201 - Created
        # 204 - No Content
        # 400 - Bad Request (endpoint exists but invalid input)
        # 401 - Unauthorized (endpoint exists, needs auth)
        # 403 - Forbidden (endpoint exists, needs permission)
        # 405 - Method Not Allowed (endpoint exists, wrong method)
        valid_statuses = {200, 201, 204, 400, 401, 403, 405}

        if evidence.response_status not in valid_statuses:
            return False

        # Check content type
        if self._is_api_response(evidence):
            return True

        # For 401/403/405, accept even without API content type
        # These strongly indicate an API endpoint exists
        if evidence.response_status in {401, 403, 405}:
            return True

        return False

    def _is_api_response(self, evidence: Evidence) -> bool:
        """Check if response content type indicates an API response.

        Args:
            evidence: Evidence object from HTTP response.

        Returns:
            True if content type is API-like or body looks like JSON/XML.
        """
        # Check Content-Type header
        content_type = ""
        for header_name, header_val in evidence.response_headers.items():
            if header_name.lower() == "content-type":
                # Normalize: strip charset and extra params
                content_type = header_val.split(";")[0].strip().lower()
                break

        if content_type in self.API_CONTENT_TYPES:
            return True

        # Fallback: check if body looks like JSON or XML
        body = evidence.response_body.strip() if evidence.response_body else ""
        if body:
            # JSON: starts with { or [
            if body.startswith("{") or body.startswith("["):
                return True
            # XML: starts with <
            if body.startswith("<") and not body.lower().startswith("<!doctype"):
                # Exclude HTML documents
                if "<html" not in body.lower()[:500]:
                    return True

        return False
