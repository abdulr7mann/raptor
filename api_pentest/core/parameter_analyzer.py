"""
Smart parameter analyzer for intelligent API testing.

This module provides ParameterAnalyzer which identifies parameter types
and attack vectors based on parameter names, values, and context. This
enables more targeted testing (e.g., only test IDOR on ID-like params).

Usage:
    from api_pentest.core.parameter_analyzer import ParameterAnalyzer, ParamType

    analyzer = ParameterAnalyzer()

    # Analyze a URL
    params = analyzer.analyze_url("https://api.example.com/users/123/orders")
    # Returns: [ParamInfo(name="123", type=ID_NUMERIC, location=PATH, ...)]

    # Analyze request body
    params = analyzer.analyze_body({"user_id": 456, "callback_url": "https://..."})
    # Returns: [ParamInfo(name="user_id", type=ID_NUMERIC), ParamInfo(name="callback_url", type=URL)]
"""

import re
import logging
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any
from urllib.parse import urlparse, parse_qs

logger = logging.getLogger(__name__)


class ParamType(Enum):
    """Classification of parameter types for targeted testing."""

    # ID types - target for IDOR
    ID_NUMERIC = auto()      # 123, 456789
    ID_UUID = auto()         # 550e8400-e29b-41d4-a716-446655440000
    ID_MONGO = auto()        # 507f1f77bcf86cd799439011 (24 hex chars)
    ID_SHORT = auto()        # abc123, A1B2C3 (short alphanumeric IDs)
    ID_HASH = auto()         # MD5/SHA-like hashes

    # User references - target for privilege escalation
    USER_ID = auto()         # user_id, userId, uid
    USERNAME = auto()        # username, user, login
    EMAIL = auto()           # email addresses

    # URLs - target for SSRF
    URL = auto()             # Full URLs
    URL_PATH = auto()        # Relative paths that might be URLs

    # File paths - target for path traversal
    FILE_PATH = auto()       # file, path, filename

    # Sensitive data - never log, special handling
    PASSWORD = auto()        # password, passwd, secret
    TOKEN = auto()           # token, api_key, auth
    CREDIT_CARD = auto()     # card numbers
    SSN = auto()             # social security numbers

    # Injection targets
    SEARCH_QUERY = auto()    # q, query, search, filter
    SQL_LIKE = auto()        # Looks like it goes to DB (order, sort, limit)
    COMMAND = auto()         # cmd, command, exec

    # Generic
    STRING = auto()          # Generic string
    NUMBER = auto()          # Generic number
    BOOLEAN = auto()         # true/false
    ARRAY = auto()           # Arrays/lists
    OBJECT = auto()          # Nested objects
    UNKNOWN = auto()         # Can't determine


class ParamLocation(Enum):
    """Where the parameter was found."""
    PATH = "path"            # URL path segment
    QUERY = "query"          # Query string
    HEADER = "header"        # HTTP header
    BODY = "body"            # Request body
    COOKIE = "cookie"        # Cookie


@dataclass
class ParamInfo:
    """Information about a detected parameter."""
    name: str
    value: Any
    param_type: ParamType
    location: ParamLocation
    confidence: float = 1.0  # 0.0-1.0 confidence in type detection
    attack_vectors: list[str] = field(default_factory=list)  # Recommended tests
    original_path: str = ""  # For nested params: "user.profile.id"

    def __repr__(self):
        return f"ParamInfo({self.name}={self.value!r}, type={self.param_type.name}, loc={self.location.value})"


class ParameterAnalyzer:
    """Analyzes parameters to determine type and attack vectors.

    This enables intelligent test selection - for example, only running
    IDOR tests on parameters that look like IDs, or SSRF tests on
    parameters that look like URLs.
    """

    # Regex patterns for value-based detection
    PATTERNS = {
        ParamType.ID_UUID: re.compile(
            r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$',
            re.IGNORECASE
        ),
        ParamType.ID_MONGO: re.compile(r'^[0-9a-f]{24}$', re.IGNORECASE),
        ParamType.ID_HASH: re.compile(r'^[0-9a-f]{32,64}$', re.IGNORECASE),  # MD5, SHA1, SHA256
        ParamType.EMAIL: re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'),
        ParamType.CREDIT_CARD: re.compile(r'^\d{13,19}$'),  # 13-19 digits
        ParamType.SSN: re.compile(r'^\d{3}-?\d{2}-?\d{4}$'),
        ParamType.URL: re.compile(r'^https?://[^\s]+$', re.IGNORECASE),
    }

    # Name patterns for name-based detection (case-insensitive)
    NAME_PATTERNS = {
        # ID patterns
        ParamType.ID_NUMERIC: [
            r'.*_id$', r'.*Id$', r'^id$', r'.*ID$',
            r'^pk$', r'.*_pk$', r'^key$', r'.*_key$',
        ],
        ParamType.USER_ID: [
            r'^user_?id$', r'^uid$', r'^owner_?id$', r'^author_?id$',
            r'^created_?by$', r'^modified_?by$', r'^assigned_?to$',
        ],
        ParamType.USERNAME: [
            r'^user$', r'^username$', r'^user_?name$', r'^login$',
            r'^account$', r'^owner$', r'^author$',
        ],
        ParamType.EMAIL: [r'^email$', r'^e-?mail$', r'^mail$'],

        # URL patterns
        ParamType.URL: [
            r'^url$', r'.*_url$', r'^uri$', r'.*_uri$',
            r'^link$', r'.*_link$', r'^href$', r'^src$',
            r'^callback$', r'^redirect$', r'^return_?url$',
            r'^next$', r'^continue$', r'^destination$',
            r'^webhook$', r'.*_webhook$',
        ],

        # File patterns
        ParamType.FILE_PATH: [
            r'^file$', r'^filename$', r'^file_?name$', r'^path$',
            r'^filepath$', r'^file_?path$', r'^document$',
            r'^attachment$', r'^upload$', r'^download$',
        ],

        # Sensitive patterns
        ParamType.PASSWORD: [
            r'^pass$', r'^password$', r'^passwd$', r'^pwd$',
            r'^secret$', r'^credential$', r'^pin$',
            r'^current_?password$', r'^new_?password$', r'^old_?password$',
        ],
        ParamType.TOKEN: [
            r'^token$', r'.*_token$', r'^api_?key$', r'^apikey$',
            r'^access_?token$', r'^refresh_?token$', r'^auth$',
            r'^authorization$', r'^bearer$', r'^session$',
            r'^jwt$', r'^csrf$', r'^xsrf$',
        ],

        # Injection targets
        ParamType.SEARCH_QUERY: [
            r'^q$', r'^query$', r'^search$', r'^filter$',
            r'^keyword$', r'^term$', r'^find$',
        ],
        ParamType.SQL_LIKE: [
            r'^order$', r'^order_?by$', r'^sort$', r'^sort_?by$',
            r'^limit$', r'^offset$', r'^page$', r'^per_?page$',
            r'^column$', r'^field$', r'^select$', r'^where$',
        ],
        ParamType.COMMAND: [
            r'^cmd$', r'^command$', r'^exec$', r'^run$',
            r'^shell$', r'^process$', r'^action$',
        ],
    }

    # Attack vector recommendations per type
    ATTACK_VECTORS = {
        ParamType.ID_NUMERIC: ["idor", "enumeration", "injection"],
        ParamType.ID_UUID: ["idor"],
        ParamType.ID_MONGO: ["idor", "nosql_injection"],
        ParamType.ID_SHORT: ["idor", "enumeration"],
        ParamType.ID_HASH: ["idor"],
        ParamType.USER_ID: ["idor", "privilege_escalation", "horizontal_access"],
        ParamType.USERNAME: ["idor", "enumeration", "privilege_escalation"],
        ParamType.EMAIL: ["idor", "enumeration", "injection"],
        ParamType.URL: ["ssrf", "open_redirect"],
        ParamType.URL_PATH: ["ssrf", "path_traversal", "open_redirect"],
        ParamType.FILE_PATH: ["path_traversal", "lfi", "rfi"],
        ParamType.PASSWORD: [],  # Don't attack passwords
        ParamType.TOKEN: ["token_replay", "token_manipulation"],
        ParamType.SEARCH_QUERY: ["sql_injection", "nosql_injection", "xss", "ldap_injection"],
        ParamType.SQL_LIKE: ["sql_injection", "nosql_injection"],
        ParamType.COMMAND: ["command_injection", "ssti"],
    }

    def __init__(self):
        # Compile name patterns for efficiency
        self._compiled_name_patterns = {}
        for ptype, patterns in self.NAME_PATTERNS.items():
            self._compiled_name_patterns[ptype] = [
                re.compile(p, re.IGNORECASE) for p in patterns
            ]

    def analyze_url(self, url: str) -> list[ParamInfo]:
        """Analyze URL for path parameters and query strings.

        Args:
            url: Full URL to analyze

        Returns:
            List of ParamInfo for detected parameters
        """
        params = []

        try:
            parsed = urlparse(url)
        except Exception:
            return params

        # Analyze path segments
        path_segments = [s for s in parsed.path.split('/') if s]
        for i, segment in enumerate(path_segments):
            # Skip segments that look like API structure (v1, api, users, etc)
            if self._is_api_structure(segment):
                continue

            param_type = self._detect_value_type(segment)
            if param_type in (ParamType.ID_NUMERIC, ParamType.ID_UUID,
                             ParamType.ID_MONGO, ParamType.ID_SHORT, ParamType.ID_HASH):
                # This is a path parameter (ID)
                # Try to infer name from previous segment
                name = path_segments[i-1] if i > 0 else f"path_param_{i}"
                if name.endswith('s'):  # users -> user_id
                    name = name[:-1] + "_id"
                else:
                    name = name + "_id"

                params.append(ParamInfo(
                    name=name,
                    value=segment,
                    param_type=param_type,
                    location=ParamLocation.PATH,
                    attack_vectors=self.ATTACK_VECTORS.get(param_type, []),
                ))

        # Analyze query parameters
        query_params = parse_qs(parsed.query, keep_blank_values=True)
        for name, values in query_params.items():
            value = values[0] if values else ""
            param_info = self._analyze_param(name, value, ParamLocation.QUERY)
            params.append(param_info)

        return params

    def analyze_body(self, body: Any, location: ParamLocation = ParamLocation.BODY) -> list[ParamInfo]:
        """Analyze request body for parameters.

        Args:
            body: Request body (dict, list, or string)
            location: Where the body came from

        Returns:
            List of ParamInfo for detected parameters
        """
        params = []

        if isinstance(body, dict):
            params.extend(self._analyze_dict(body, location))
        elif isinstance(body, list):
            for i, item in enumerate(body):
                if isinstance(item, dict):
                    nested = self._analyze_dict(item, location, prefix=f"[{i}]")
                    params.extend(nested)
        elif isinstance(body, str):
            # Try to parse as JSON
            try:
                import json
                parsed = json.loads(body)
                return self.analyze_body(parsed, location)
            except (json.JSONDecodeError, TypeError):
                pass

        return params

    def analyze_headers(self, headers: dict[str, str]) -> list[ParamInfo]:
        """Analyze HTTP headers for interesting parameters.

        Args:
            headers: HTTP headers dict

        Returns:
            List of ParamInfo for security-relevant headers
        """
        params = []

        interesting_headers = {
            'authorization': ParamType.TOKEN,
            'x-api-key': ParamType.TOKEN,
            'x-auth-token': ParamType.TOKEN,
            'cookie': ParamType.TOKEN,
            'x-forwarded-for': ParamType.STRING,
            'x-forwarded-host': ParamType.URL,
            'x-original-url': ParamType.URL,
            'x-rewrite-url': ParamType.URL,
            'referer': ParamType.URL,
            'origin': ParamType.URL,
        }

        for header, value in headers.items():
            header_lower = header.lower()
            if header_lower in interesting_headers:
                param_type = interesting_headers[header_lower]
                params.append(ParamInfo(
                    name=header,
                    value=value,
                    param_type=param_type,
                    location=ParamLocation.HEADER,
                    attack_vectors=self.ATTACK_VECTORS.get(param_type, []),
                ))

        return params

    def analyze_endpoint(self, url: str, method: str, headers: dict = None,
                         body: Any = None) -> list[ParamInfo]:
        """Full endpoint analysis combining URL, headers, and body.

        Args:
            url: Full endpoint URL
            method: HTTP method
            headers: Optional headers dict
            body: Optional request body

        Returns:
            Combined list of all detected parameters
        """
        params = []

        # URL analysis
        params.extend(self.analyze_url(url))

        # Header analysis
        if headers:
            params.extend(self.analyze_headers(headers))

        # Body analysis (only for methods that have bodies)
        if body and method.upper() in ('POST', 'PUT', 'PATCH'):
            params.extend(self.analyze_body(body))

        return params

    def get_idor_candidates(self, params: list[ParamInfo]) -> list[ParamInfo]:
        """Filter parameters that are good IDOR candidates.

        Args:
            params: List of analyzed parameters

        Returns:
            Parameters likely to be IDOR targets
        """
        idor_types = {
            ParamType.ID_NUMERIC, ParamType.ID_UUID, ParamType.ID_MONGO,
            ParamType.ID_SHORT, ParamType.ID_HASH, ParamType.USER_ID,
            ParamType.USERNAME, ParamType.EMAIL,
        }
        return [p for p in params if p.param_type in idor_types]

    def get_ssrf_candidates(self, params: list[ParamInfo]) -> list[ParamInfo]:
        """Filter parameters that are good SSRF candidates.

        Args:
            params: List of analyzed parameters

        Returns:
            Parameters likely to be SSRF targets
        """
        ssrf_types = {ParamType.URL, ParamType.URL_PATH}
        return [p for p in params if p.param_type in ssrf_types]

    def get_injection_candidates(self, params: list[ParamInfo]) -> list[ParamInfo]:
        """Filter parameters that are good injection candidates.

        Args:
            params: List of analyzed parameters

        Returns:
            Parameters likely to be injection targets
        """
        injection_types = {
            ParamType.SEARCH_QUERY, ParamType.SQL_LIKE, ParamType.COMMAND,
            ParamType.ID_NUMERIC, ParamType.STRING,
        }
        return [p for p in params if p.param_type in injection_types]

    def _analyze_dict(self, data: dict, location: ParamLocation,
                      prefix: str = "") -> list[ParamInfo]:
        """Recursively analyze a dictionary."""
        params = []

        for key, value in data.items():
            full_path = f"{prefix}.{key}" if prefix else key

            if isinstance(value, dict):
                # Recurse into nested objects
                nested = self._analyze_dict(value, location, full_path)
                params.extend(nested)
            elif isinstance(value, list):
                # Analyze list items
                for i, item in enumerate(value):
                    if isinstance(item, dict):
                        nested = self._analyze_dict(item, location, f"{full_path}[{i}]")
                        params.extend(nested)
                    else:
                        param = self._analyze_param(key, item, location, f"{full_path}[{i}]")
                        params.append(param)
            else:
                param = self._analyze_param(key, value, location, full_path)
                params.append(param)

        return params

    def _analyze_param(self, name: str, value: Any, location: ParamLocation,
                       path: str = "") -> ParamInfo:
        """Analyze a single parameter."""
        # First try value-based detection
        param_type = self._detect_value_type(value)
        confidence = 0.9 if param_type != ParamType.UNKNOWN else 0.5

        # Then try name-based detection (may override)
        name_type = self._detect_name_type(name)
        if name_type != ParamType.UNKNOWN:
            # Name-based detection is usually more reliable
            if param_type == ParamType.UNKNOWN:
                param_type = name_type
                confidence = 0.8
            elif name_type == param_type:
                confidence = 1.0  # Both agree
            else:
                # Name says one thing, value says another
                # Prefer name for user/sensitive types, value for ID types
                if name_type in (ParamType.USER_ID, ParamType.USERNAME,
                                ParamType.PASSWORD, ParamType.TOKEN, ParamType.URL):
                    param_type = name_type
                    confidence = 0.85

        # Handle numeric values that might be IDs
        if param_type == ParamType.UNKNOWN:
            if isinstance(value, int) or (isinstance(value, str) and value.isdigit()):
                param_type = ParamType.ID_NUMERIC
                confidence = 0.6  # Lower confidence without name hint
            elif isinstance(value, str):
                param_type = ParamType.STRING
                confidence = 0.5
            elif isinstance(value, bool):
                param_type = ParamType.BOOLEAN
                confidence = 1.0
            elif isinstance(value, (int, float)):
                param_type = ParamType.NUMBER
                confidence = 0.9

        return ParamInfo(
            name=name,
            value=value,
            param_type=param_type,
            location=location,
            confidence=confidence,
            attack_vectors=self.ATTACK_VECTORS.get(param_type, []),
            original_path=path or name,
        )

    def _detect_value_type(self, value: Any) -> ParamType:
        """Detect parameter type from its value."""
        if value is None:
            return ParamType.UNKNOWN

        str_value = str(value)

        # Check regex patterns
        for ptype, pattern in self.PATTERNS.items():
            if pattern.match(str_value):
                return ptype

        # Check for numeric ID
        if isinstance(value, int) or str_value.isdigit():
            if len(str_value) <= 10:  # Reasonable ID length
                return ParamType.ID_NUMERIC
            return ParamType.NUMBER

        # Check for short alphanumeric ID (like "abc123")
        if re.match(r'^[a-zA-Z0-9]{4,16}$', str_value):
            # Contains both letters and numbers = likely ID
            if re.search(r'[a-zA-Z]', str_value) and re.search(r'[0-9]', str_value):
                return ParamType.ID_SHORT

        # Check for URL-like paths
        if str_value.startswith('/') or str_value.startswith('./'):
            return ParamType.URL_PATH

        return ParamType.UNKNOWN

    def _detect_name_type(self, name: str) -> ParamType:
        """Detect parameter type from its name."""
        for ptype, patterns in self._compiled_name_patterns.items():
            for pattern in patterns:
                if pattern.match(name):
                    return ptype
        return ParamType.UNKNOWN

    def _is_api_structure(self, segment: str) -> bool:
        """Check if a URL segment is API structure, not a parameter."""
        structure_patterns = [
            r'^v\d+$',          # v1, v2
            r'^api$',           # api
            r'^rest$',          # rest
            r'^graphql$',       # graphql
            r'^[a-z]+s$',       # users, orders (plural resource names)
            r'^[a-z]+$',        # user, order (singular - might be action)
        ]

        for pattern in structure_patterns:
            if re.match(pattern, segment, re.IGNORECASE):
                # But not if it looks like an ID
                if not re.match(r'^[0-9a-f-]{8,}$', segment, re.IGNORECASE):
                    return True

        return False


# Convenience function for quick analysis
def analyze_request(url: str, method: str = "GET", headers: dict = None,
                   body: Any = None) -> list[ParamInfo]:
    """Quick function to analyze a request for parameters.

    Args:
        url: Request URL
        method: HTTP method
        headers: Optional headers
        body: Optional body

    Returns:
        List of detected parameters
    """
    analyzer = ParameterAnalyzer()
    return analyzer.analyze_endpoint(url, method, headers, body)
