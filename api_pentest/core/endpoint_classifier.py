"""Endpoint classification using a three-tier priority strategy.

Classification priority:
1. Manual overrides from config (highest)
2. OpenAPI security definitions
3. Path-pattern heuristics (lowest)

Default classification is PROTECTED when no signal matches.
"""

import logging
import re
from urllib.parse import urlparse

from api_pentest.core.models import Endpoint, EndpointClassification

logger = logging.getLogger(__name__)

# Auth-endpoint patterns: endpoints that return credentials by design
AUTH_ENDPOINT_PATTERNS = re.compile(
    r"/(login|signin|sign-in|authenticate|auth/token|oauth/token|token$|session$)",
    re.IGNORECASE,
)

# Public endpoint patterns: endpoints that typically require no authentication
PUBLIC_PATH_PATTERNS = re.compile(
    r"/(register|signup|sign-up|"
    r"health|healthz|readyz|status|ping|version|"
    r"createdb|resetdb|initdb|"
    r"docs|swagger|openapi|api-docs|redoc)$",
    re.IGNORECASE,
)


class EndpointClassifier:
    """Classifies endpoints as public, protected, or auth-endpoint.

    Uses a three-tier priority chain:
    1. Manual overrides from config
    2. OpenAPI security definitions (when spec available)
    3. Path-pattern heuristics
    """

    def __init__(
        self,
        endpoints: list[Endpoint],
        openapi_spec: dict | None = None,
        config: dict | None = None,
    ):
        self.endpoints = endpoints
        self.openapi_spec = openapi_spec
        self.config = config or {}

    def classify_all(self) -> None:
        """Classify all endpoints and log a summary."""
        for ep in self.endpoints:
            classification, reason = self._classify(ep)
            ep.classification = classification
            ep.classification_reason = reason

        counts = {"public": 0, "protected": 0, "auth-endpoint": 0}
        for ep in self.endpoints:
            counts[ep.classification.value] += 1

        logger.info(
            "Classified %d endpoints: %d public, %d protected, %d auth-endpoint",
            len(self.endpoints),
            counts["public"],
            counts["protected"],
            counts["auth-endpoint"],
        )

    def _classify(self, endpoint: Endpoint) -> tuple[EndpointClassification, str]:
        """Apply three-tier classification priority chain.

        Auth-endpoint detection via path patterns runs as an early check
        before OpenAPI security classification, because auth-endpoint is
        about endpoint *purpose* (returns credentials), not security
        requirement. A login endpoint may have no security defined in
        the spec but is still an auth-endpoint.
        """
        # Tier 1: Manual overrides (highest priority)
        result = self._check_overrides(endpoint)
        if result is not None:
            return result, "manual override"

        # Auth-endpoint path check runs before OpenAPI security tier.
        # Auth-endpoint is about purpose, not security requirement.
        auth_result = self._check_auth_endpoint_path(endpoint)
        if auth_result is not None:
            return auth_result

        # Tier 2: OpenAPI security definitions
        if self.openapi_spec is not None:
            result_openapi = self._classify_from_openapi(endpoint)
            if result_openapi is not None:
                return result_openapi

        # Tier 3: Path-pattern heuristics (public patterns + default)
        return self._classify_from_path_patterns(endpoint)

    def _check_overrides(self, endpoint: Endpoint) -> EndpointClassification | None:
        """Check manual overrides from config."""
        overrides = self.config.get("endpoint_overrides", [])
        if not overrides:
            return None

        path = urlparse(endpoint.url).path
        for override in overrides:
            if not isinstance(override, dict):
                continue
            override_path = override.get("path", "")
            classification_str = override.get("classification", "")
            if override_path and path.rstrip("/") == override_path.rstrip("/"):
                try:
                    return EndpointClassification(classification_str)
                except ValueError:
                    logger.warning(
                        "Invalid classification '%s' in override for path '%s'",
                        classification_str,
                        override_path,
                    )
        return None

    def _check_auth_endpoint_path(
        self, endpoint: Endpoint
    ) -> tuple[EndpointClassification, str] | None:
        """Check if endpoint path matches auth-endpoint patterns.

        Auth-endpoint detection is purpose-based (returns credentials),
        independent of whether the endpoint requires authentication.
        """
        path = urlparse(endpoint.url).path
        match = AUTH_ENDPOINT_PATTERNS.search(path)
        if match:
            return (
                EndpointClassification.AUTH_ENDPOINT,
                f"path heuristic: matches /{match.group(1)} pattern",
            )
        return None

    def _classify_from_openapi(
        self, endpoint: Endpoint
    ) -> tuple[EndpointClassification, str] | None:
        """Classify using OpenAPI security definitions."""
        # Existing parser tags security: [] as "public-no-auth"
        if "public-no-auth" in endpoint.tags:
            return EndpointClassification.PUBLIC, "OpenAPI security: [] (explicitly public)"

        # Endpoint has explicit security schemes = protected
        if endpoint.security_schemes:
            schemes = ", ".join(endpoint.security_schemes)
            return EndpointClassification.PROTECTED, f"OpenAPI security scheme: {schemes}"

        # No per-operation security: check global security
        if self._has_global_security():
            return EndpointClassification.PROTECTED, "inherits global security"
        else:
            return EndpointClassification.PUBLIC, "no per-operation or global security defined"

    def _classify_from_path_patterns(
        self, endpoint: Endpoint
    ) -> tuple[EndpointClassification, str]:
        """Classify using URL path heuristics (public patterns + default).

        Auth-endpoint patterns are checked earlier in _check_auth_endpoint_path.
        """
        path = urlparse(endpoint.url).path

        # Root path is typically public
        if path.rstrip("/") == "" or path == "/":
            return EndpointClassification.PUBLIC, "path heuristic: root path"

        # Check public patterns
        match = PUBLIC_PATH_PATTERNS.search(path)
        if match:
            return (
                EndpointClassification.PUBLIC,
                f"path heuristic: matches /{match.group(1)} pattern",
            )

        # Default: protected
        return EndpointClassification.PROTECTED, "default classification (no matching signal)"

    def _has_global_security(self) -> bool:
        """Check if the raw OpenAPI spec has non-empty top-level security."""
        if not self.openapi_spec:
            return False
        global_security = self.openapi_spec.get("security", None)
        if global_security is None:
            return False
        if isinstance(global_security, list) and len(global_security) > 0:
            return True
        return False
