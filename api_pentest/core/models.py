from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Optional, TYPE_CHECKING
import time

if TYPE_CHECKING:
    from api_pentest.core.api_discovery import ArchitectureType


class Severity(Enum):
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    INFO = "Info"


class TestStatus(Enum):
    PASS = "PASS"
    FAIL = "FAIL"
    ERROR = "ERROR"
    SKIP = "SKIP"


class BodyMode(Enum):
    RAW = "raw"
    URLENCODED = "urlencoded"
    FORMDATA = "formdata"
    FILE = "file"
    GRAPHQL = "graphql"
    NONE = "none"


class InputFormat(Enum):
    POSTMAN_V20 = "postman_v2.0"
    POSTMAN_V21 = "postman_v2.1"
    SWAGGER_20 = "swagger_2.0"
    OPENAPI_30 = "openapi_3.0"
    OPENAPI_31 = "openapi_3.1"


class EndpointClassification(Enum):
    PUBLIC = "public"                # No auth required
    PROTECTED = "protected"          # Auth required (default)
    AUTH_ENDPOINT = "auth-endpoint"  # Returns credentials by design (e.g. login)


class ApplicabilityMode(Enum):
    """Mode for matching applicability criteria."""

    ANY = "any"      # Applies if ANY listed value matches
    ALL = "all"      # Applies only if ALL listed values match
    EXCLUDE = "exclude"  # Applies if NONE of the listed values match


@dataclass
class ScenarioApplicability:
    """Declares when a scenario applies to an endpoint.

    Used by the relevance calculator to score test-endpoint pairs.
    Empty lists mean "applies to all" for that dimension.
    """

    # Import ArchitectureType at runtime to avoid circular imports
    architectures: list = field(default_factory=list)  # list[ArchitectureType]
    architecture_mode: ApplicabilityMode = ApplicabilityMode.ANY
    classifications: list[str] = field(default_factory=list)  # "public", "protected", "auth-endpoint"
    classification_mode: ApplicabilityMode = ApplicabilityMode.ANY
    requires_prerequisites: list[str] = field(default_factory=list)  # e.g. ["rate_limiting"]


@dataclass
class Endpoint:
    method: str
    url: str
    name: str = ""
    folder_path: str = ""
    headers: dict[str, str] = field(default_factory=dict)
    body: Any = None
    body_mode: BodyMode = BodyMode.NONE
    auth_type: str = ""
    auth_config: dict[str, Any] = field(default_factory=dict)
    path_params: list[str] = field(default_factory=list)
    query_params: dict[str, str] = field(default_factory=dict)
    tags: list[str] = field(default_factory=list)
    is_deprecated: bool = False
    security_schemes: list[str] = field(default_factory=list)
    unresolved_variables: list[str] = field(default_factory=list)
    classification: EndpointClassification = EndpointClassification.PROTECTED
    classification_reason: str = ""

    @property
    def has_id_params(self) -> bool:
        import re
        id_pattern = re.compile(r'\b\d+\b|[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', re.I)
        return bool(id_pattern.search(self.url))

    @property
    def full_name(self) -> str:
        if self.folder_path:
            return f"{self.folder_path}/{self.name}"
        return self.name


@dataclass
class TokenContext:
    access_token: str = ""
    refresh_token: str = ""
    token_type: str = "Bearer"
    expires_at: float = 0.0
    scopes: list[str] = field(default_factory=list)
    raw_jwt: str = ""
    decoded_header: dict[str, Any] = field(default_factory=dict)
    decoded_claims: dict[str, Any] = field(default_factory=dict)
    user_label: str = ""

    @property
    def is_expired(self) -> bool:
        if self.expires_at == 0:
            return False
        return time.time() > self.expires_at

    @property
    def authorization_header(self) -> str:
        return f"{self.token_type} {self.access_token}"


@dataclass
class Evidence:
    request_method: str = ""
    request_url: str = ""
    request_headers: dict[str, str] = field(default_factory=dict)
    request_body: Any = None
    response_status: int = 0
    response_headers: dict[str, str] = field(default_factory=dict)
    response_body: str = ""
    response_time_ms: float = 0.0
    timestamp: str = ""

    def to_dict(self) -> dict:
        return {
            "request": {
                "method": self.request_method,
                "url": self.request_url,
                "headers": self.request_headers,
                "body": self.request_body,
            },
            "response": {
                "status": self.response_status,
                "headers": self.response_headers,
                "body": self.response_body if self.response_body else "",
                "time_ms": self.response_time_ms,
            },
            "timestamp": self.timestamp,
        }


@dataclass
class TestResult:
    scenario_id: str
    test_name: str
    endpoint_name: str = ""
    status: TestStatus = TestStatus.SKIP
    details: str = ""
    evidence: Optional[Evidence] = None
    duration_ms: float = 0.0

    def to_dict(self) -> dict:
        return {
            "scenario_id": self.scenario_id,
            "test_name": self.test_name,
            "endpoint_name": self.endpoint_name,
            "status": self.status.value,
            "details": self.details,
            "evidence": self.evidence.to_dict() if self.evidence else None,
            "duration_ms": self.duration_ms,
        }


@dataclass
class Finding:
    severity: Severity
    title: str
    description: str
    endpoint: str = ""
    evidence: Optional[Evidence] = None
    remediation: str = ""
    owasp_id: str = ""
    owasp_name: str = ""
    scenario_id: str = ""

    def to_dict(self) -> dict:
        return {
            "severity": self.severity.value,
            "title": self.title,
            "description": self.description,
            "endpoint": self.endpoint,
            "evidence": self.evidence.to_dict() if self.evidence else None,
            "remediation": self.remediation,
            "owasp_id": self.owasp_id,
            "owasp_name": self.owasp_name,
            "scenario_id": self.scenario_id,
        }
