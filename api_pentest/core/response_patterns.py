import json
import logging
from dataclasses import dataclass, field

from api_pentest.core.http_client import PentestHttpClient
from api_pentest.core.models import Endpoint, Evidence

logger = logging.getLogger(__name__)

STATUS_FIELD_CANDIDATES = ["status", "success", "ok", "error", "code", "result", "errorCode", "error_code"]
FAILURE_INDICATORS = {"fail", "failed", "failure", "error", "err", "false", "denied", "unauthorized", "forbidden", "invalid"}
SUCCESS_INDICATORS = {"success", "successful", "ok", "okay", "true", "completed", "done"}


@dataclass
class ResponsePattern:
    """Learned success/failure indicators for a single endpoint."""

    endpoint_key: str
    status_field: str | None = None
    success_values: set[str] = field(default_factory=set)
    failure_values: set[str] = field(default_factory=set)
    error_field: str | None = None
    success_keys: frozenset[str] | None = None
    failure_keys: frozenset[str] | None = None


class ResponsePatternLearner:
    """Learns per-endpoint response patterns by probing APIs before security tests.

    Sends baseline probes (with and without auth) to each endpoint, then
    compares the two responses to identify fields and structures that
    distinguish success from failure at the application level.
    """

    def __init__(
        self,
        http_client: PentestHttpClient,
        endpoints: list[Endpoint],
        oauth_handler=None,
    ):
        self.http = http_client
        self.endpoints = endpoints
        self.oauth = oauth_handler
        self.patterns: dict[str, ResponsePattern] = {}

    def learn(self):
        """Probe each endpoint and extract response patterns."""
        learned = 0

        for ep in self.endpoints:
            endpoint_key = f"{ep.method}:{ep.url}"

            # Get auth token if available
            auth_token = None
            if self.oauth:
                try:
                    token_ctx = self.oauth.acquire_token()
                    if token_ctx:
                        auth_token = token_ctx.authorization_header
                except Exception:
                    logger.debug("Failed to acquire token for learning probe on %s", endpoint_key)

            success_evidence = None
            failure_evidence = None

            if ep.method.upper() == "GET":
                # GET endpoints are safe to probe with both valid and invalid auth
                if auth_token:
                    success_evidence = self.http.request(
                        method=ep.method,
                        url=ep.url,
                        headers=ep.headers,
                        body=ep.body,
                        auth_token=auth_token,
                    )
                failure_evidence = self.http.request(
                    method=ep.method,
                    url=ep.url,
                    headers=ep.headers,
                    body=ep.body,
                    auth_token=None,
                )
            else:
                # POST/PUT/DELETE: only send the no-auth probe to avoid state mutation
                failure_evidence = self.http.request(
                    method=ep.method,
                    url=ep.url,
                    headers=ep.headers,
                    body=ep.body,
                    auth_token=None,
                )

            pattern = self._extract_pattern(endpoint_key, success_evidence, failure_evidence)
            if pattern:
                self.patterns[endpoint_key] = pattern
                learned += 1
                logger.debug(
                    "Pattern for %s: status_field=%s, success_values=%s, "
                    "failure_values=%s, error_field=%s",
                    endpoint_key,
                    pattern.status_field,
                    pattern.success_values,
                    pattern.failure_values,
                    pattern.error_field,
                )

        logger.info("Learned response patterns for %d/%d endpoints", learned, len(self.endpoints))

    def _extract_pattern(
        self,
        endpoint_key: str,
        success_response: Evidence | None,
        failure_response: Evidence | None,
    ) -> ResponsePattern | None:
        """Compare success and failure responses to build a ResponsePattern."""
        success_json = self._parse_json(success_response.response_body) if success_response else None
        failure_json = self._parse_json(failure_response.response_body) if failure_response else None

        # Need at least one JSON response to extract a pattern
        if success_json is None and failure_json is None:
            return None

        pattern = ResponsePattern(endpoint_key=endpoint_key)

        # Check STATUS_FIELD_CANDIDATES for explicit status fields
        for candidate in STATUS_FIELD_CANDIDATES:
            has_in_success = success_json is not None and candidate in success_json
            has_in_failure = failure_json is not None and candidate in failure_json

            if has_in_success and has_in_failure:
                success_val = str(success_json[candidate]).lower()
                failure_val = str(failure_json[candidate]).lower()
                if success_val != failure_val:
                    pattern.status_field = candidate
                    pattern.success_values.add(success_val)
                    pattern.failure_values.add(failure_val)
                    break
            elif has_in_failure and not has_in_success:
                # Field exists only in failure response -- it is an error indicator
                pattern.error_field = candidate
                break

        # Record top-level keys as structural fingerprint
        if success_json is not None:
            pattern.success_keys = frozenset(success_json.keys())
        if failure_json is not None:
            pattern.failure_keys = frozenset(failure_json.keys())

        # Only return pattern if we learned something useful
        if pattern.status_field or pattern.error_field or (pattern.success_keys != pattern.failure_keys):
            return pattern

        return None

    def is_real_success(self, evidence: Evidence, endpoint_key: str) -> bool:
        """Check if response represents genuine application-level success.

        Checks signals in priority order:
        1. HTTP status must be 200-299
        2. Look up learned pattern
        3. If no pattern, fall back to HTTP-status-only (no regression)
        4-7. Check status_field, error_field, structural fingerprint
        8. Default: return True (do NOT suppress when in doubt)
        """
        # 1. HTTP status must be 200-299
        if not (200 <= evidence.response_status < 300):
            return False

        # 2. Look up learned pattern
        pattern = self.patterns.get(endpoint_key)

        # 3. No pattern learned -- fall back to HTTP-status-only
        if pattern is None:
            return True

        # 4. Parse response body as JSON
        body_json = self._parse_json(evidence.response_body)

        # 5. Check status_field
        if body_json and pattern.status_field and pattern.status_field in body_json:
            value = str(body_json[pattern.status_field]).lower()
            if value in pattern.failure_values:
                return False
            if value in pattern.success_values:
                return True

        # 6. Check error_field
        if body_json and pattern.error_field and pattern.error_field in body_json:
            return False

        # 7. Structural fingerprint comparison
        if body_json is not None and pattern.failure_keys is not None and pattern.success_keys is not None:
            current_keys = frozenset(body_json.keys())
            if current_keys == pattern.failure_keys and current_keys != pattern.success_keys:
                return False

        # 8. Default: trust HTTP status code
        return True

    def _parse_json(self, body: str) -> dict | None:
        """Safely parse JSON body, returning None for non-JSON."""
        if not body:
            return None
        try:
            parsed = json.loads(body)
            if isinstance(parsed, dict):
                return parsed
            return None
        except (json.JSONDecodeError, TypeError, ValueError):
            return None
