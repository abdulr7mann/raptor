"""
Kiterunner adapter for subprocess-based endpoint discovery.

This module provides a wrapper around the Kiterunner CLI tool for automated
API endpoint discovery. When Kiterunner is not available on the system,
the toolkit can auto-install it or fall back to a built-in wordlist.

Kiterunner is a context-aware content discovery tool that uses API specs
and wordlists to brute-force API endpoints more intelligently than
traditional wordlist-based tools.

Usage:
    adapter = KiterunnerAdapter(auto_install=True)
    if adapter.is_available():
        for result in adapter.scan("https://api.example.com"):
            print(result)
"""

import json
import logging
import os
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Generator

logger = logging.getLogger(__name__)


class KiterunnerNotFoundError(Exception):
    """Raised when Kiterunner binary (kr or kiterunner) is not found on the system.

    This is NOT a fatal error - the toolkit should fall back to the built-in
    wordlist when Kiterunner is unavailable.
    """

    def __init__(self, message: str = "Kiterunner not found. Install from https://github.com/assetnote/kiterunner"):
        super().__init__(message)


class KiterunnerAdapter:
    """Subprocess wrapper for the Kiterunner CLI tool.

    Kiterunner is a context-aware content discovery tool that uses API-specific
    wordlists to discover endpoints. This adapter provides a Python interface
    to the CLI tool with JSON output parsing.

    Attributes:
        timeout: Maximum time in seconds to wait for scan completion (default 300).
        kr_path: Path to the Kiterunner binary, or None if not found.
        auto_install: If True, automatically install Kiterunner if not found.

    Example:
        adapter = KiterunnerAdapter(timeout=600, auto_install=True)
        if adapter.is_available():
            for endpoint in adapter.scan("https://api.example.com"):
                print(f"Found: {endpoint['path']}")
    """

    # Default install location for auto-install
    DEFAULT_BIN_DIR = Path.home() / ".local" / "bin"

    # Bundled wordlist paths (included with Raptor)
    BUNDLED_KITE_WORDLIST = Path(__file__).parent.parent.parent / "wordlists" / "routes-small.kite"
    BUNDLED_TXT_WORDLIST = Path(__file__).parent.parent.parent / "wordlists" / "apiroutes.txt"

    def __init__(self, timeout: int = 300, auto_install: bool = True):
        """Initialize KiterunnerAdapter.

        Args:
            timeout: Maximum time in seconds to wait for scan completion.
                     Default is 300 seconds (5 minutes).
            auto_install: If True, automatically install Kiterunner if not found.
                         Default is True.
        """
        self.timeout = timeout
        self.auto_install = auto_install

        # Check for 'kr' (common alias) or 'kiterunner' (full name)
        self.kr_path = self._find_kiterunner()

        if not self.kr_path and self.auto_install:
            logger.info("Kiterunner not found, attempting auto-install...")
            self.kr_path = self._auto_install()

        if self.kr_path:
            logger.debug("Kiterunner found at: %s", self.kr_path)
        else:
            logger.debug("Kiterunner not found in PATH")

    def _find_kiterunner(self) -> str | None:
        """Find Kiterunner binary in PATH or default install location."""
        # Check standard PATH
        kr_path = shutil.which("kr") or shutil.which("kiterunner")
        if kr_path:
            return kr_path

        # Check default install location
        for name in ["kr", "kiterunner"]:
            local_path = self.DEFAULT_BIN_DIR / name
            if local_path.exists() and os.access(local_path, os.X_OK):
                return str(local_path)

        return None

    def _auto_install(self) -> str | None:
        """Auto-install Kiterunner using the setup script."""
        try:
            # Import and run the setup script
            scripts_dir = Path(__file__).parent.parent.parent / "scripts"
            setup_script = scripts_dir / "setup_kiterunner.py"

            if not setup_script.exists():
                logger.warning("Setup script not found: %s", setup_script)
                return None

            # Run the setup script
            result = subprocess.run(
                [sys.executable, str(setup_script)],
                capture_output=True,
                text=True,
                timeout=120,
            )

            if result.returncode == 0:
                logger.info("Kiterunner installed successfully")
                # Re-check for the binary
                return self._find_kiterunner()
            else:
                logger.warning("Kiterunner installation failed: %s", result.stderr)
                return None

        except subprocess.TimeoutExpired:
            logger.warning("Kiterunner installation timed out")
            return None
        except Exception as e:
            logger.warning("Failed to auto-install Kiterunner: %s", e)
            return None

    def is_available(self) -> bool:
        """Check if Kiterunner is available on the system.

        Returns:
            True if Kiterunner binary is found in PATH, False otherwise.
        """
        return self.kr_path is not None

    def scan(
        self,
        target: str,
        wordlist: str | None = None,
    ) -> Generator[dict, None, None]:
        """Scan a target URL for API endpoints using Kiterunner.

        This method runs Kiterunner as a subprocess and yields discovered
        endpoints as dictionaries. Each dictionary contains the raw JSON
        output from Kiterunner, typically including:
        - method: HTTP method (GET, POST, etc.)
        - path: Discovered endpoint path
        - status: HTTP response status code
        - length: Response body length
        - words: Word count in response
        - lines: Line count in response

        Args:
            target: Base URL to scan (e.g., "https://api.example.com").
            wordlist: Path to wordlist file. Supports .kite format for
                     Kiterunner-optimized wordlists, or plain text wordlists.
                     If None, uses Assetnote's remote apiroutes wordlist.

        Yields:
            dict: Discovered endpoint information from Kiterunner JSON output.

        Raises:
            KiterunnerNotFoundError: If Kiterunner is not installed.

        Example:
            for result in adapter.scan("https://api.example.com"):
                print(f"Found: {result.get('method', 'GET')} {result.get('path')}")
        """
        if not self.is_available():
            raise KiterunnerNotFoundError(
                "Kiterunner binary not found in PATH. "
                "Install from https://github.com/assetnote/kiterunner or "
                "ensure 'kr' or 'kiterunner' is in your PATH."
            )

        # Build command list
        cmd = [
            self.kr_path,
            "scan",
            target,
            "-o", "json",   # JSON output format
            "-x", "5",      # Max 5 concurrent connections per host
        ]

        # Add wordlist: user-provided > bundled .kite > bundled .txt > remote
        if wordlist:
            cmd.extend(["-w", wordlist])
            logger.info("Kiterunner scanning %s with wordlist: %s", target, wordlist)
        elif self.BUNDLED_KITE_WORDLIST.exists():
            # Use bundled .kite wordlist (no network dependency)
            cmd.extend(["-w", str(self.BUNDLED_KITE_WORDLIST)])
            logger.info("Kiterunner scanning %s with bundled wordlist: %s", target, self.BUNDLED_KITE_WORDLIST.name)
        elif self.BUNDLED_TXT_WORDLIST.exists():
            # Fallback to bundled text wordlist
            cmd.extend(["-w", str(self.BUNDLED_TXT_WORDLIST)])
            logger.info("Kiterunner scanning %s with bundled wordlist: %s", target, self.BUNDLED_TXT_WORDLIST.name)
        else:
            # Last resort: Assetnote's remote apiroutes wordlist
            cmd.extend(["-A", "apiroutes-210228:5000"])
            logger.info("Kiterunner scanning %s with Assetnote remote wordlist", target)

        logger.debug("Kiterunner command: %s", " ".join(cmd))

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout,
            )

            # Check exit code and log errors
            if result.returncode != 0:
                logger.warning(
                    "Kiterunner exited with code %d for target %s",
                    result.returncode,
                    target,
                )
                # Log stderr at warning level when there's an error
                if result.stderr:
                    for line in result.stderr.strip().split("\n"):
                        if line:
                            logger.warning("Kiterunner error: %s", line)
            elif result.stderr:
                # Log stderr at debug level for non-errors (progress info)
                for line in result.stderr.strip().split("\n"):
                    if line:
                        logger.debug("Kiterunner stderr: %s", line)

            # Parse JSON output from stdout (line by line, NDJSON format)
            if result.stdout:
                for line in result.stdout.strip().split("\n"):
                    if line:
                        try:
                            yield json.loads(line)
                        except json.JSONDecodeError:
                            # Skip non-JSON lines (progress output, etc.)
                            logger.debug("Skipping non-JSON line: %s", line[:100])
                            continue

        except subprocess.TimeoutExpired:
            logger.warning(
                "Kiterunner scan timed out after %d seconds for target: %s",
                self.timeout,
                target,
            )
            # Return empty generator on timeout
            return

        except subprocess.SubprocessError as e:
            logger.error("Kiterunner subprocess error: %s", e)
            return

        except OSError as e:
            logger.error("Failed to execute Kiterunner: %s", e)
            return
