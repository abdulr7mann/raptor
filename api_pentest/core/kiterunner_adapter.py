"""
Kiterunner adapter for subprocess-based endpoint discovery.

This module provides a wrapper around the Kiterunner CLI tool for automated
API endpoint discovery. When Kiterunner is not available on the system,
the toolkit falls back to a built-in wordlist (see endpoint_wordlist.py).

Kiterunner is a context-aware content discovery tool that uses API specs
and wordlists to brute-force API endpoints more intelligently than
traditional wordlist-based tools.

Usage:
    adapter = KiterunnerAdapter()
    if adapter.is_available():
        for result in adapter.scan("https://api.example.com"):
            print(result)
"""

import json
import logging
import shutil
import subprocess
from typing import Generator

logger = logging.getLogger(__name__)


class KiterunnerNotFoundError(Exception):
    """Raised when Kiterunner binary (kr or kiterunner) is not found on the system.

    This is NOT a fatal error - the toolkit should fall back to the built-in
    wordlist when Kiterunner is unavailable.
    """

    def __init__(self, message: str = "Kiterunner not found. Install from https://github.com/assetnote/kiterunner"):
        super().__init__(message)


class KiterunnerAdapter:
    """Subprocess wrapper for the Kiterunner CLI tool.

    Kiterunner is a context-aware content discovery tool that uses API-specific
    wordlists to discover endpoints. This adapter provides a Python interface
    to the CLI tool with JSON output parsing.

    Attributes:
        timeout: Maximum time in seconds to wait for scan completion (default 300).
        kr_path: Path to the Kiterunner binary, or None if not found.

    Example:
        adapter = KiterunnerAdapter(timeout=600)
        if adapter.is_available():
            for endpoint in adapter.scan("https://api.example.com"):
                print(f"Found: {endpoint['path']}")
    """

    def __init__(self, timeout: int = 300):
        """Initialize KiterunnerAdapter.

        Args:
            timeout: Maximum time in seconds to wait for scan completion.
                     Default is 300 seconds (5 minutes).
        """
        self.timeout = timeout
        # Check for 'kr' (common alias) or 'kiterunner' (full name)
        self.kr_path = shutil.which("kr") or shutil.which("kiterunner")
        if self.kr_path:
            logger.debug("Kiterunner found at: %s", self.kr_path)
        else:
            logger.debug("Kiterunner not found in PATH")

    def is_available(self) -> bool:
        """Check if Kiterunner is available on the system.

        Returns:
            True if Kiterunner binary is found in PATH, False otherwise.
        """
        return self.kr_path is not None

    def scan(
        self,
        target: str,
        wordlist: str | None = None,
    ) -> Generator[dict, None, None]:
        """Scan a target URL for API endpoints using Kiterunner.

        This method runs Kiterunner as a subprocess and yields discovered
        endpoints as dictionaries. Each dictionary contains the raw JSON
        output from Kiterunner, typically including:
        - method: HTTP method (GET, POST, etc.)
        - path: Discovered endpoint path
        - status: HTTP response status code
        - length: Response body length
        - words: Word count in response
        - lines: Line count in response

        Args:
            target: Base URL to scan (e.g., "https://api.example.com").
            wordlist: Path to wordlist file. Supports .kite format for
                     Kiterunner-optimized wordlists, or plain text wordlists.
                     If None, uses Assetnote's remote apiroutes wordlist.

        Yields:
            dict: Discovered endpoint information from Kiterunner JSON output.

        Raises:
            KiterunnerNotFoundError: If Kiterunner is not installed.

        Example:
            for result in adapter.scan("https://api.example.com"):
                print(f"Found: {result.get('method', 'GET')} {result.get('path')}")
        """
        if not self.is_available():
            raise KiterunnerNotFoundError(
                "Kiterunner binary not found in PATH. "
                "Install from https://github.com/assetnote/kiterunner or "
                "ensure 'kr' or 'kiterunner' is in your PATH."
            )

        # Build command list
        cmd = [
            self.kr_path,
            "scan",
            target,
            "-o", "json",   # JSON output format
            "-x", "5",      # Max 5 concurrent connections per host
        ]

        # Add wordlist or use Assetnote remote
        if wordlist:
            cmd.extend(["-w", wordlist])
            logger.info("Kiterunner scanning %s with wordlist: %s", target, wordlist)
        else:
            # Use Assetnote's remote apiroutes wordlist (top 5000 API routes)
            cmd.extend(["-A", "apiroutes-210228:5000"])
            logger.info("Kiterunner scanning %s with Assetnote remote wordlist", target)

        logger.debug("Kiterunner command: %s", " ".join(cmd))

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout,
            )

            # Log stderr if present (warnings, progress info)
            if result.stderr:
                for line in result.stderr.strip().split("\n"):
                    if line:
                        logger.debug("Kiterunner stderr: %s", line)

            # Parse JSON output from stdout (line by line, NDJSON format)
            if result.stdout:
                for line in result.stdout.strip().split("\n"):
                    if line:
                        try:
                            yield json.loads(line)
                        except json.JSONDecodeError:
                            # Skip non-JSON lines (progress output, etc.)
                            logger.debug("Skipping non-JSON line: %s", line[:100])
                            continue

            # Check exit code
            if result.returncode != 0:
                logger.warning(
                    "Kiterunner exited with code %d for target %s",
                    result.returncode,
                    target,
                )

        except subprocess.TimeoutExpired:
            logger.warning(
                "Kiterunner scan timed out after %d seconds for target: %s",
                self.timeout,
                target,
            )
            # Return empty generator on timeout
            return

        except subprocess.SubprocessError as e:
            logger.error("Kiterunner subprocess error: %s", e)
            return

        except OSError as e:
            logger.error("Failed to execute Kiterunner: %s", e)
            return
