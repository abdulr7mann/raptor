"""
Spec discoverer module for auto-discovery of API specs at common paths.

This module provides:
- SpecDiscoverer: Probes common spec paths and returns spec content + type
- SpecType: Enum for detected specification types (OpenAPI, Swagger, GraphQL)

When given only a URL (no spec file), the toolkit can use SpecDiscoverer
to find API specifications at standard locations before falling back to
endpoint fuzzing.
"""

import json
import logging
from enum import Enum

from api_pentest.core.api_discovery import RequestBudget

logger = logging.getLogger(__name__)


class SpecType(Enum):
    """Specification types that can be detected."""

    OPENAPI_30 = "openapi_3.x"
    SWAGGER_20 = "swagger_2.0"
    GRAPHQL = "graphql"


class SpecDiscoverer:
    """Discovers API specifications by probing common spec paths.

    Given a base URL and HTTP client, SpecDiscoverer probes a list of
    common specification paths (e.g., /openapi.json, /swagger.json, /graphql)
    and returns the spec content along with its detected type.

    Respects RequestBudget to avoid excessive probing (request storm protection).
    """

    # Ordered list of common spec paths to probe
    SPEC_PATHS = [
        # OpenAPI/Swagger JSON
        "/openapi.json",
        "/swagger.json",
        "/api-docs",
        "/api/openapi.json",
        "/api/swagger.json",
        "/v1/swagger.json",
        "/v2/swagger.json",
        "/v3/swagger.json",
        "/swagger/v1/swagger.json",
        "/docs.json",
        "/api-docs.json",
        # OpenAPI/Swagger YAML
        "/openapi.yaml",
        "/swagger.yaml",
        # GraphQL
        "/graphql",
        "/api/graphql",
        "/gql",
        "/query",
    ]

    # Paths that require GraphQL introspection POST instead of plain GET
    GRAPHQL_PATHS = frozenset({"/graphql", "/api/graphql", "/gql", "/query"})

    def __init__(self, base_url: str, http_client, budget: RequestBudget):
        """Initialize SpecDiscoverer.

        Args:
            base_url: Base URL of the API (trailing slash will be stripped)
            http_client: PentestHttpClient instance for making requests
            budget: Shared RequestBudget instance to limit discovery requests
        """
        self.base_url = base_url.rstrip("/") if base_url else ""
        self.http_client = http_client
        self.budget = budget

    def discover(self) -> tuple[str | None, SpecType | None]:
        """Probe common spec paths and return spec content + type if found.

        Iterates through SPEC_PATHS, checking budget before each request.
        For GraphQL paths, uses introspection POST instead of plain GET.

        Early exits after 3 consecutive connection errors to avoid wasting
        time on unresponsive hosts.

        Returns:
            Tuple of (spec_content, spec_type) if a spec is found,
            or (None, None) if no spec is found or budget exhausted.
        """
        consecutive_errors = 0
        MAX_CONSECUTIVE_ERRORS = 3

        for path in self.SPEC_PATHS:
            # Check budget before each request
            if not self.budget.can_request():
                logger.warning(
                    "Spec discovery budget exhausted, %d paths remain unprobed",
                    len(self.SPEC_PATHS) - self.SPEC_PATHS.index(path),
                )
                break

            url = f"{self.base_url}{path}"

            # GraphQL paths need introspection POST, not plain GET
            if path in self.GRAPHQL_PATHS:
                result = self._try_graphql_introspection(url)
                if result[0] is not None:
                    logger.info("Spec found via GraphQL introspection at %s", path)
                    return result
            else:
                # Plain GET for OpenAPI/Swagger paths
                try:
                    evidence = self.http_client.request(
                        method="GET",
                        url=url,
                        headers={"Accept": "application/json, application/yaml, */*"},
                    )
                    self.budget.record()

                    # Status 0 = timeout/connection error
                    if evidence.response_status == 0:
                        consecutive_errors += 1
                        if consecutive_errors >= MAX_CONSECUTIVE_ERRORS:
                            logger.warning(
                                "Host unreachable after %d timeouts/errors, skipping remaining spec paths",
                                consecutive_errors,
                            )
                            break
                        continue

                    consecutive_errors = 0  # Reset on successful request

                    if evidence.response_status == 200:
                        spec_type = self._detect_spec_type(evidence.response_body)
                        if spec_type is not None:
                            logger.info(
                                "Spec found at %s (type: %s)", path, spec_type.value
                            )
                            return (evidence.response_body, spec_type)
                        else:
                            logger.debug(
                                "Got 200 at %s but content is not a recognized spec format",
                                path,
                            )
                    else:
                        logger.debug(
                            "No spec at %s (status: %d)", path, evidence.response_status
                        )

                except Exception as e:
                    self.budget.record()
                    consecutive_errors += 1
                    logger.debug("Request failed for %s: %s", path, e)

                    if consecutive_errors >= MAX_CONSECUTIVE_ERRORS:
                        logger.warning(
                            "Host unreachable after %d consecutive errors, skipping remaining spec paths",
                            consecutive_errors,
                        )
                        break

        logger.info("No spec found at any of %d common paths", len(self.SPEC_PATHS))
        return (None, None)

    def _detect_spec_type(self, body: str) -> SpecType | None:
        """Detect specification type from response body.

        Parses the body as JSON and checks for format-specific markers:
        - OpenAPI 3.x: "openapi" field starting with "3."
        - Swagger 2.0: "swagger" field equals "2.0"
        - GraphQL: "__schema" in root or nested in "data"

        Args:
            body: Response body string to analyze

        Returns:
            SpecType if recognized, None otherwise
        """
        try:
            data = json.loads(body)
        except json.JSONDecodeError:
            # Not valid JSON -- could be YAML, but we don't parse YAML here
            # YAML specs would need separate handling
            return None

        if not isinstance(data, dict):
            return None

        # Check for OpenAPI 3.x
        openapi_version = data.get("openapi", "")
        if isinstance(openapi_version, str) and openapi_version.startswith("3."):
            return SpecType.OPENAPI_30

        # Check for Swagger 2.0
        swagger_version = data.get("swagger")
        if swagger_version == "2.0":
            return SpecType.SWAGGER_20

        # Check for GraphQL introspection response
        # Can be at root level or nested under "data"
        if "__schema" in data:
            return SpecType.GRAPHQL
        if "data" in data and isinstance(data.get("data"), dict):
            if "__schema" in data["data"]:
                return SpecType.GRAPHQL

        return None

    def _try_graphql_introspection(self, url: str) -> tuple[str | None, SpecType | None]:
        """Attempt GraphQL introspection at the given URL.

        Sends a POST request with a minimal introspection query.
        GraphQL introspection is a read-only operation (safe to probe).

        Args:
            url: Full URL of the GraphQL endpoint

        Returns:
            Tuple of (response_body, GRAPHQL) if introspection succeeds,
            or (None, None) if it fails.
        """
        # Check budget before request
        if not self.budget.can_request():
            logger.debug("Budget exhausted, skipping GraphQL introspection at %s", url)
            return (None, None)

        # Minimal introspection query - just enough to confirm GraphQL
        introspection_query = {"query": "{ __schema { types { name } } }"}

        try:
            evidence = self.http_client.request(
                method="POST",
                url=url,
                headers={"Content-Type": "application/json"},
                body=introspection_query,
            )
            self.budget.record()

            if evidence.response_status == 200:
                try:
                    data = json.loads(evidence.response_body)

                    # Check for successful introspection response
                    # Response can have __schema at root or under "data"
                    if "__schema" in data:
                        logger.debug("GraphQL introspection successful at %s", url)
                        return (evidence.response_body, SpecType.GRAPHQL)

                    if "data" in data and isinstance(data.get("data"), dict):
                        if "__schema" in data["data"]:
                            logger.debug("GraphQL introspection successful at %s", url)
                            return (evidence.response_body, SpecType.GRAPHQL)

                    # Got 200 but not a valid introspection response
                    # Could be GraphQL with introspection disabled (returns errors)
                    if "errors" in data:
                        logger.debug(
                            "GraphQL endpoint at %s responded but introspection may be disabled",
                            url,
                        )

                except json.JSONDecodeError:
                    logger.debug("Non-JSON response from %s", url)

            else:
                logger.debug(
                    "GraphQL introspection at %s returned status %d",
                    url,
                    evidence.response_status,
                )

        except Exception as e:
            self.budget.record()
            logger.debug("GraphQL introspection failed at %s: %s", url, e)

        return (None, None)
