"""Finding validation with multi-signal confidence classification.

Validates findings against baselines and assigns confidence levels
(CONFIRMED, LIKELY, UNCERTAIN) based on detected validation signals.
"""

from dataclasses import dataclass

from api_pentest.core.baseline_comparator import BaselineComparator
from api_pentest.core.models import ConfidenceLevel, Evidence, Finding


@dataclass
class ValidationResult:
    """Result of finding validation."""

    signals_detected: list[str]
    confidence: ConfidenceLevel
    explanation: str


class FindingValidator:
    """Validates findings using multiple signals to determine confidence.

    Collects up to 4 validation signals:
    1. body_diff - Response body differs from baseline
    2. timing_anomaly - Response time significantly exceeds baseline
    3. error_message - Error indicators present in test but not baseline
    4. structure_change - JSON structure changed (keys added/removed)

    Confidence levels:
    - CONFIRMED: 2+ signals detected
    - LIKELY: 1 signal detected
    - UNCERTAIN: 0 signals detected
    """

    # Error indicators to look for in response bodies
    ERROR_INDICATORS = {
        "error",
        "exception",
        "traceback",
        "stack trace",
        "syntax error",
        "internal server error",
        "fatal",
        "panic",
    }

    # Test response time > TIMING_MULTIPLIER * baseline = timing anomaly
    TIMING_MULTIPLIER = 3.0

    def __init__(self, baselines: dict[str, Evidence] | None = None):
        """Initialize validator with optional baseline evidence.

        Args:
            baselines: Dict mapping endpoint keys ("{method}:{url}") to
                       baseline Evidence objects
        """
        self.baselines = baselines or {}
        self.comparator = BaselineComparator()

    def validate(self, finding: Finding, endpoint_key: str) -> Finding:
        """Validate a finding and enrich with confidence information.

        Args:
            finding: Finding to validate (must have evidence set)
            endpoint_key: Key in format "{method}:{url}" for baseline lookup

        Returns:
            Finding enriched with confidence, confidence_signals, and
            confidence_explanation fields
        """
        baseline = self.baselines.get(endpoint_key)
        evidence = finding.evidence

        if evidence is None:
            # No evidence to validate - stay UNCERTAIN
            finding.confidence = ConfidenceLevel.UNCERTAIN
            finding.confidence_signals = []
            finding.confidence_explanation = "No evidence available for validation"
            return finding

        signals = self._collect_signals(evidence, baseline)
        confidence = self._determine_confidence(signals)
        explanation = self._build_explanation(signals, baseline is not None)

        finding.confidence = confidence
        finding.confidence_signals = signals
        finding.confidence_explanation = explanation

        return finding

    def _collect_signals(
        self, evidence: Evidence, baseline: Evidence | None
    ) -> list[str]:
        """Collect validation signals from evidence comparison.

        Args:
            evidence: Test evidence to validate
            baseline: Optional baseline evidence for comparison

        Returns:
            List of detected signal names
        """
        signals = []

        # Signal 1: Response body diff
        if baseline and self.comparator.has_meaningful_diff(
            baseline.response_body, evidence.response_body
        ):
            signals.append("body_diff")

        # Signal 2: Timing anomaly
        if self._has_timing_anomaly(evidence, baseline):
            signals.append("timing_anomaly")

        # Signal 3: Error message
        if self._has_error_message(evidence, baseline):
            signals.append("error_message")

        # Signal 4: Structure change
        if baseline and self.comparator.has_structure_change(
            baseline.response_body, evidence.response_body
        ):
            signals.append("structure_change")

        return signals

    def _has_timing_anomaly(
        self, evidence: Evidence, baseline: Evidence | None
    ) -> bool:
        """Check if response time indicates an anomaly.

        Args:
            evidence: Test evidence
            baseline: Optional baseline evidence

        Returns:
            True if test time > baseline time * TIMING_MULTIPLIER
        """
        if baseline is None:
            return False

        if baseline.response_time_ms <= 0:
            return False

        threshold = baseline.response_time_ms * self.TIMING_MULTIPLIER
        return evidence.response_time_ms > threshold

    def _has_error_message(
        self, evidence: Evidence, baseline: Evidence | None
    ) -> bool:
        """Check for error indicators in test response not present in baseline.

        Args:
            evidence: Test evidence
            baseline: Optional baseline evidence

        Returns:
            True if test contains error indicators not in baseline
        """
        test_body_lower = evidence.response_body.lower()
        test_errors = {
            indicator
            for indicator in self.ERROR_INDICATORS
            if indicator in test_body_lower
        }

        if not test_errors:
            return False

        if baseline is None:
            # No baseline - any error indicator counts
            return True

        # Check if error indicators are new (not in baseline)
        baseline_body_lower = baseline.response_body.lower()
        baseline_errors = {
            indicator
            for indicator in self.ERROR_INDICATORS
            if indicator in baseline_body_lower
        }

        # Return True if test has error indicators that baseline doesn't
        return bool(test_errors - baseline_errors)

    def _determine_confidence(self, signals: list[str]) -> ConfidenceLevel:
        """Determine confidence level from signal count.

        Args:
            signals: List of detected signal names

        Returns:
            CONFIRMED if 2+, LIKELY if 1, UNCERTAIN if 0
        """
        if len(signals) >= 2:
            return ConfidenceLevel.CONFIRMED
        elif len(signals) == 1:
            return ConfidenceLevel.LIKELY
        else:
            return ConfidenceLevel.UNCERTAIN

    def _build_explanation(
        self, signals: list[str], baseline_available: bool
    ) -> str:
        """Build human-readable explanation of confidence determination.

        Args:
            signals: List of detected signal names
            baseline_available: Whether baseline was available

        Returns:
            Human-readable explanation string
        """
        if not baseline_available:
            return "No baseline available for comparison"

        if not signals:
            return "No validation signals detected"

        # Convert signal names to human-readable format
        signal_names = {
            "body_diff": "response body diff",
            "timing_anomaly": "timing anomaly",
            "error_message": "error message detected",
            "structure_change": "structure change",
        }

        readable_signals = [signal_names.get(s, s) for s in signals]
        return f"Validated by: {', '.join(readable_signals)}"
