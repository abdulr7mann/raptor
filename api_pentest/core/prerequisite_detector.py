"""Prerequisite detection for security controls.

Probes the target API to determine whether specific security controls
(rate limiting, CORS, CSP) are present before running bypass tests.
This prevents false positives from bypass tests when there is nothing
to bypass.
"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum

from api_pentest.core.models import Endpoint

logger = logging.getLogger(__name__)


class DetectionStatus(Enum):
    """Three-state detection result."""

    PRESENT = "PRESENT"
    ABSENT = "ABSENT"
    UNCERTAIN = "UNCERTAIN"


@dataclass
class PrerequisiteResult:
    """Result of detecting a security control prerequisite."""

    control_name: str
    status: DetectionStatus
    reason: str
    evidence_summary: str = ""
    endpoint: str = ""


class ControlDetector(ABC):
    """Abstract base class for security control detectors."""

    def __init__(self, http_client, endpoints: list[Endpoint], config=None, token=None):
        self.http = http_client
        self.endpoints = endpoints
        self.config = config or {}
        self.token = token

    @abstractmethod
    def detect(self) -> list[PrerequisiteResult]:
        """Detect whether the security control is present."""
        ...

    def _get_auth_token(self) -> str | None:
        """Return authorization header value if a token is available."""
        return self.token.authorization_header if self.token else None


class RateLimitDetector(ControlDetector):
    """Detects whether the target API enforces rate limiting."""

    DETECTION_BURST_SIZE = 15

    def detect(self) -> list[PrerequisiteResult]:
        probe_ep = self._select_probe_endpoint()
        if probe_ep is None:
            return [
                PrerequisiteResult(
                    control_name="rate_limiting",
                    status=DetectionStatus.UNCERTAIN,
                    reason="No endpoints available for rate limit detection",
                )
            ]

        auth_token = self._get_auth_token()
        count_429 = 0
        has_rate_headers = False

        for _ in range(self.DETECTION_BURST_SIZE):
            evidence = self.http.request(
                method=probe_ep.method,
                url=probe_ep.url,
                headers=probe_ep.headers,
                body=probe_ep.body,
                auth_token=auth_token,
            )
            if evidence.response_status == 429:
                count_429 += 1
            if self._check_rate_limit_headers(evidence):
                has_rate_headers = True

        ep_label = f"{probe_ep.method} {probe_ep.url}"

        if count_429 > 0 or has_rate_headers:
            parts = []
            if count_429 > 0:
                parts.append(f"{count_429}/{self.DETECTION_BURST_SIZE} requests returned 429")
            if has_rate_headers:
                parts.append("rate limit headers detected")
            return [
                PrerequisiteResult(
                    control_name="rate_limiting",
                    status=DetectionStatus.PRESENT,
                    reason="; ".join(parts),
                    evidence_summary=f"Probed {ep_label} with {self.DETECTION_BURST_SIZE} requests",
                    endpoint=ep_label,
                )
            ]

        return [
            PrerequisiteResult(
                control_name="rate_limiting",
                status=DetectionStatus.ABSENT,
                reason=f"No 429 responses or rate limit headers after {self.DETECTION_BURST_SIZE} rapid requests",
                evidence_summary=f"Probed {ep_label} with {self.DETECTION_BURST_SIZE} requests, all returned non-429",
                endpoint=ep_label,
            )
        ]

    def _select_probe_endpoint(self) -> Endpoint | None:
        """Select a probe endpoint, preferring GET methods."""
        if not self.endpoints:
            return None
        for ep in self.endpoints:
            if ep.method.upper() == "GET":
                return ep
        return self.endpoints[0]

    @staticmethod
    def _check_rate_limit_headers(evidence) -> bool:
        """Check if response contains rate limit related headers."""
        rate_keywords = ("ratelimit", "rate-limit", "x-rate", "retry-after")
        for header_name in evidence.response_headers:
            lower = header_name.lower()
            if any(kw in lower for kw in rate_keywords):
                return True
        return False


class CORSDetector(ControlDetector):
    """Detects whether the target API returns CORS headers."""

    def detect(self) -> list[PrerequisiteResult]:
        if not self.endpoints:
            return [
                PrerequisiteResult(
                    control_name="cors",
                    status=DetectionStatus.UNCERTAIN,
                    reason="No endpoints available for CORS detection",
                )
            ]

        auth_token = self._get_auth_token()
        test_endpoints = self.endpoints[:5]

        for ep in test_endpoints:
            headers = dict(ep.headers)
            headers["Origin"] = "https://detect-cors.example.com"
            evidence = self.http.request(
                method=ep.method,
                url=ep.url,
                headers=headers,
                body=ep.body,
                auth_token=auth_token,
            )
            for header_name in evidence.response_headers:
                if header_name.lower() == "access-control-allow-origin":
                    return [
                        PrerequisiteResult(
                            control_name="cors",
                            status=DetectionStatus.PRESENT,
                            reason="CORS Access-Control-Allow-Origin header found",
                            evidence_summary=f"{ep.method} {ep.url} returned {header_name}: {evidence.response_headers[header_name]}",
                            endpoint=f"{ep.method} {ep.url}",
                        )
                    ]

        return [
            PrerequisiteResult(
                control_name="cors",
                status=DetectionStatus.ABSENT,
                reason=f"No Access-Control-Allow-Origin header in {len(test_endpoints)} endpoint(s)",
                evidence_summary=f"Tested {len(test_endpoints)} endpoints with Origin header",
            )
        ]


class CSPDetector(ControlDetector):
    """Detects whether the target API returns Content-Security-Policy headers."""

    def detect(self) -> list[PrerequisiteResult]:
        if not self.endpoints:
            return [
                PrerequisiteResult(
                    control_name="csp",
                    status=DetectionStatus.UNCERTAIN,
                    reason="No endpoints available for CSP detection",
                )
            ]

        auth_token = self._get_auth_token()
        test_endpoints = self.endpoints[:5]

        for ep in test_endpoints:
            evidence = self.http.request(
                method=ep.method,
                url=ep.url,
                headers=ep.headers,
                body=ep.body,
                auth_token=auth_token,
            )
            for header_name in evidence.response_headers:
                if header_name.lower() == "content-security-policy":
                    return [
                        PrerequisiteResult(
                            control_name="csp",
                            status=DetectionStatus.PRESENT,
                            reason="Content-Security-Policy header found",
                            evidence_summary=f"{ep.method} {ep.url} returned CSP header",
                            endpoint=f"{ep.method} {ep.url}",
                        )
                    ]

        return [
            PrerequisiteResult(
                control_name="csp",
                status=DetectionStatus.ABSENT,
                reason=f"No Content-Security-Policy header in {len(test_endpoints)} endpoint(s)",
                evidence_summary=f"Tested {len(test_endpoints)} endpoints",
            )
        ]


class PrerequisiteChecker:
    """Facade that runs all control detectors and collects results."""

    def __init__(self, http_client, endpoints: list[Endpoint], config=None, oauth_handler=None):
        self.http = http_client
        self.endpoints = endpoints
        self.config = config or {}
        self.token = None
        if oauth_handler:
            self.token = oauth_handler.acquire_token()

    def check_all(self) -> dict[str, PrerequisiteResult]:
        """Run all detectors and return results keyed by control name."""
        detectors = [
            RateLimitDetector(self.http, self.endpoints, self.config, self.token),
            CORSDetector(self.http, self.endpoints, self.config, self.token),
            CSPDetector(self.http, self.endpoints, self.config, self.token),
        ]

        results: dict[str, PrerequisiteResult] = {}
        for detector in detectors:
            detector_results = detector.detect()
            if detector_results:
                result = detector_results[0]  # API-level detection: use first result
                results[result.control_name] = result
                logger.info(
                    "[Prerequisites] %s: %s - %s",
                    result.control_name,
                    result.status.value,
                    result.reason,
                )

        return results
