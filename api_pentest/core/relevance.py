"""Relevance scoring for adaptive test execution.

Computes weighted scores for scenario-endpoint pairs based on:
- Architecture type match (0.4 weight)
- Endpoint classification match (0.3 weight)
- Prerequisite availability (0.3 weight)

Tests with scores below threshold are skipped with documented reason.
"""

import logging
from dataclasses import dataclass

from api_pentest.core.api_discovery import ArchitectureType
from api_pentest.core.models import Endpoint, ScenarioApplicability, ApplicabilityMode
from api_pentest.core.prerequisite_detector import DetectionStatus

logger = logging.getLogger(__name__)


@dataclass
class RelevanceScore:
    """Result of relevance calculation for a scenario-endpoint pair.

    Attributes:
        total: Combined weighted score (0.0 to 1.0)
        architecture_score: Score from architecture matching (0.0 or 0.4)
        classification_score: Score from classification matching (0.0 or 0.3)
        prerequisite_score: Score from prerequisite availability (0.0 or 0.3)
        skip_reason: Human-readable reason if below threshold, empty if applicable
    """

    total: float
    architecture_score: float
    classification_score: float
    prerequisite_score: float
    skip_reason: str = ""


class RelevanceCalculator:
    """Calculates relevance scores for scenario-endpoint pairs.

    Uses weighted scoring with three factors:
    - Architecture type match: 40% weight
    - Endpoint classification match: 30% weight
    - Prerequisite availability: 30% weight

    Tests below the threshold are marked with skip_reason for reporting.
    """

    WEIGHT_ARCHITECTURE: float = 0.4
    WEIGHT_CLASSIFICATION: float = 0.3
    WEIGHT_PREREQUISITE: float = 0.3

    def __init__(
        self,
        api_profile,
        prerequisite_results: dict,
        threshold: float = 0.3,
    ):
        """Initialize RelevanceCalculator.

        Args:
            api_profile: ApiProfile instance with architecture_type
            prerequisite_results: Dict of control_name -> PrerequisiteResult
            threshold: Minimum score for a test to be applicable (default 0.3)
        """
        self.profile = api_profile
        self.prereqs = prerequisite_results
        self.threshold = threshold

    def calculate(
        self,
        applicability: ScenarioApplicability,
        endpoint: Endpoint,
    ) -> RelevanceScore:
        """Calculate relevance score for a scenario-endpoint pair.

        Args:
            applicability: ScenarioApplicability declaring test requirements
            endpoint: Endpoint to score against

        Returns:
            RelevanceScore with breakdown and skip_reason if below threshold
        """
        skip_reasons = []

        # Architecture scoring
        arch_score = self._score_architecture(applicability, skip_reasons)

        # Classification scoring
        class_score = self._score_classification(applicability, endpoint, skip_reasons)

        # Prerequisite scoring
        prereq_score = self._score_prerequisites(applicability, skip_reasons)

        # Calculate total
        total = arch_score + class_score + prereq_score

        # Set skip reason if below threshold
        skip_reason = ""
        if total < self.threshold:
            if skip_reasons:
                skip_reason = "; ".join(skip_reasons)
            else:
                skip_reason = f"Score {total:.2f} below threshold {self.threshold}"

        return RelevanceScore(
            total=total,
            architecture_score=arch_score,
            classification_score=class_score,
            prerequisite_score=prereq_score,
            skip_reason=skip_reason,
        )

    def _score_architecture(
        self,
        applicability: ScenarioApplicability,
        skip_reasons: list[str],
    ) -> float:
        """Score based on architecture type match.

        Returns:
            0.4 if match (or no restriction), 0.0 otherwise
        """
        # Empty list means applies to all architectures
        if not applicability.architectures:
            return self.WEIGHT_ARCHITECTURE

        # Get profile architecture type
        profile_arch = self._get_profile_architecture()
        if profile_arch is None:
            # Unknown architecture - be conservative, allow test
            return self.WEIGHT_ARCHITECTURE

        # Check if profile architecture matches any in applicability list
        matches = profile_arch in applicability.architectures

        # Handle mode
        mode = applicability.architecture_mode
        if mode == ApplicabilityMode.EXCLUDE:
            # EXCLUDE mode: applies if NOT in list
            if matches:
                skip_reasons.append(
                    f"Architecture {profile_arch.value} excluded"
                )
                return 0.0
            return self.WEIGHT_ARCHITECTURE
        elif mode == ApplicabilityMode.ALL:
            # ALL mode: requires ALL architectures (unlikely for single profile)
            # Interpret as: profile must match all listed
            if not matches:
                arch_names = [a.value for a in applicability.architectures]
                skip_reasons.append(
                    f"Architecture {profile_arch.value} not in required set {arch_names}"
                )
                return 0.0
            return self.WEIGHT_ARCHITECTURE
        else:
            # ANY mode (default): applies if ANY listed value matches
            if matches:
                return self.WEIGHT_ARCHITECTURE
            arch_names = [a.value for a in applicability.architectures]
            skip_reasons.append(
                f"Architecture {profile_arch.value} not in {arch_names}"
            )
            return 0.0

    def _score_classification(
        self,
        applicability: ScenarioApplicability,
        endpoint: Endpoint,
        skip_reasons: list[str],
    ) -> float:
        """Score based on endpoint classification match.

        Returns:
            0.3 if match (or no restriction), 0.0 otherwise
        """
        # Empty list means applies to all classifications
        if not applicability.classifications:
            return self.WEIGHT_CLASSIFICATION

        # Get endpoint classification value
        ep_class = endpoint.classification.value if endpoint.classification else "protected"

        # Check if endpoint classification matches any in applicability list
        matches = ep_class in applicability.classifications

        # Handle mode
        mode = applicability.classification_mode
        if mode == ApplicabilityMode.EXCLUDE:
            # EXCLUDE mode: applies if NOT in list
            if matches:
                skip_reasons.append(
                    f"Classification '{ep_class}' excluded"
                )
                return 0.0
            return self.WEIGHT_CLASSIFICATION
        elif mode == ApplicabilityMode.ALL:
            # ALL mode for classification doesn't make sense (endpoint has one class)
            # Treat same as ANY
            if not matches:
                skip_reasons.append(
                    f"Classification '{ep_class}' not in {applicability.classifications}"
                )
                return 0.0
            return self.WEIGHT_CLASSIFICATION
        else:
            # ANY mode (default): applies if ANY listed value matches
            if matches:
                return self.WEIGHT_CLASSIFICATION
            skip_reasons.append(
                f"Classification '{ep_class}' not in {applicability.classifications}"
            )
            return 0.0

    def _score_prerequisites(
        self,
        applicability: ScenarioApplicability,
        skip_reasons: list[str],
    ) -> float:
        """Score based on prerequisite availability.

        Returns:
            0.3 if all required prereqs are PRESENT (or no requirements), 0.0 otherwise
        """
        # Empty list means no prerequisite requirements
        if not applicability.requires_prerequisites:
            return self.WEIGHT_PREREQUISITE

        # Check each required prerequisite
        missing = []
        for prereq_name in applicability.requires_prerequisites:
            result = self.prereqs.get(prereq_name)
            if result is None:
                # Prerequisite not checked - treat as missing
                missing.append(f"{prereq_name} (not checked)")
            elif hasattr(result, "status"):
                if result.status != DetectionStatus.PRESENT:
                    missing.append(f"{prereq_name} ({result.status.value})")
            elif isinstance(result, dict) and "status" in result:
                if result["status"] != "PRESENT":
                    missing.append(f"{prereq_name} ({result['status']})")
            else:
                # Unknown format - treat as missing
                missing.append(f"{prereq_name} (unknown)")

        if missing:
            skip_reasons.append(
                f"Prerequisites not met: {', '.join(missing)}"
            )
            return 0.0

        return self.WEIGHT_PREREQUISITE

    def _get_profile_architecture(self) -> ArchitectureType | None:
        """Extract ArchitectureType from profile."""
        if self.profile is None:
            return None

        # Handle ApiProfile object
        if hasattr(self.profile, "architecture_type"):
            arch_val = self.profile.architecture_type
            # May be string or ArchitectureType
            if isinstance(arch_val, ArchitectureType):
                return arch_val
            elif isinstance(arch_val, str):
                # Convert string to enum
                for arch in ArchitectureType:
                    if arch.value == arch_val:
                        return arch
        return None
