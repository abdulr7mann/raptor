"""
API Discovery module for detecting authentication schemes and architecture types.

This module provides:
- AuthDetector: Detects auth schemes from OpenAPI specs and active probing
- ArchitectureDetector: Identifies REST/GraphQL/SOAP architecture types
- RequestBudget: Shared request counter across detection subsystems
- Supporting enums and dataclasses
"""

import json
import logging
import re
from dataclasses import dataclass, field
from enum import Enum
from typing import Any

from api_pentest.core.models import Evidence

logger = logging.getLogger(__name__)


# =============================================================================
# Enums
# =============================================================================


class AuthSchemeType(Enum):
    """Authentication scheme types detected from specs or probing."""

    BEARER = "bearer"
    API_KEY = "apiKey"
    BASIC = "basic"
    OAUTH2 = "oauth2"
    SESSION_COOKIE = "session_cookie"
    OPENID_CONNECT = "openIdConnect"
    UNKNOWN = "unknown"


class ArchitectureType(Enum):
    """API architecture types."""

    REST = "REST"
    GRAPHQL = "GraphQL"
    SOAP = "SOAP"
    GRPC_WEB = "gRPC-web"
    HYBRID = "hybrid"
    UNKNOWN = "unknown"


# =============================================================================
# Dataclasses
# =============================================================================


@dataclass
class DetectedAuthScheme:
    """Represents a detected authentication scheme."""

    scheme_type: AuthSchemeType
    name: str  # e.g. "bearerAuth", "api_key"
    source: str  # "spec" or "probe"
    details: dict = field(default_factory=dict)
    # For apiKey: {"in": "header", "name": "X-API-Key"}
    # For bearer: {"format": "JWT"}
    # For oauth2: {"flows": {"clientCredentials": {"tokenUrl": "..."}}}
    endpoints: list[str] = field(default_factory=list)  # which endpoints use this scheme


# =============================================================================
# RequestBudget
# =============================================================================


class RequestBudget:
    """Tracks and limits the number of discovery requests.

    All detector subsystems share one RequestBudget instance to ensure
    the total discovery request count stays within the configured cap.
    """

    def __init__(self, max_requests: int = 30):
        self.max_requests = max_requests
        self.used = 0

    def can_request(self) -> bool:
        """Check if another request can be made within budget."""
        return self.used < self.max_requests

    def record(self):
        """Record that a request was made."""
        self.used += 1

    @property
    def remaining(self) -> int:
        """Number of requests remaining in budget."""
        return max(0, self.max_requests - self.used)


# =============================================================================
# AuthDetector
# =============================================================================


class AuthDetector:
    """Detects authentication schemes using spec extraction + active probing.

    Two-tier strategy (per CONTEXT.md):
    1. Tier 1: Extract from OpenAPI spec (cheapest, most reliable)
    2. Tier 2: Active probing as fallback (when spec is missing or lacks security info)
    """

    # Session cookie names to detect
    SESSION_COOKIE_NAMES = frozenset({
        "session",
        "sid",
        "sessionid",
        "jsessionid",
        "connect.sid",
        "phpsessid",
        "asp.net_sessionid",
        "aspsessionid",
    })

    def __init__(
        self,
        openapi_spec: dict | None,
        http_client: Any,
        endpoints: list,
        base_url: str,
        budget: RequestBudget,
    ):
        """Initialize AuthDetector.

        Args:
            openapi_spec: Parsed OpenAPI/Swagger spec dict, or None
            http_client: PentestHttpClient instance for active probing
            endpoints: List of Endpoint objects to probe
            base_url: Base URL of the API
            budget: Shared RequestBudget instance
        """
        self.spec = openapi_spec
        self.http = http_client
        self.endpoints = endpoints
        self.base_url = base_url.rstrip("/") if base_url else ""
        self.budget = budget

    def detect(self) -> list[DetectedAuthScheme]:
        """Detect authentication schemes.

        Returns a list of DetectedAuthScheme objects found via spec extraction
        or active probing.
        """
        schemes = []

        # Tier 1: Spec extraction (zero requests needed)
        if self.spec:
            schemes.extend(self._extract_from_spec())
            if schemes:
                logger.info(
                    "Detected %d auth scheme(s) from spec: %s",
                    len(schemes),
                    [s.name for s in schemes],
                )

        # Tier 2: Active probing (only if Tier 1 found nothing)
        if not schemes and self.http and self.endpoints:
            logger.info("No auth schemes in spec, falling back to active probing")
            schemes.extend(self._probe_unauthenticated())
            if schemes:
                logger.info(
                    "Detected %d auth scheme(s) via probing: %s",
                    len(schemes),
                    [s.name for s in schemes],
                )

        if not schemes:
            logger.warning("No authentication schemes detected")

        return schemes

    def _extract_from_spec(self) -> list[DetectedAuthScheme]:
        """Extract auth schemes from OpenAPI spec.

        Handles both Swagger 2.0 (securityDefinitions) and
        OpenAPI 3.x (components.securitySchemes).
        """
        if not self.spec:
            return []

        # Get raw security schemes from appropriate location
        raw_schemes: dict = {}

        # Swagger 2.0 uses securityDefinitions at root
        if "securityDefinitions" in self.spec:
            raw_schemes = self.spec.get("securityDefinitions", {})
            logger.debug("Found securityDefinitions (Swagger 2.0)")

        # OpenAPI 3.x uses components.securitySchemes
        elif "components" in self.spec:
            raw_schemes = self.spec.get("components", {}).get("securitySchemes", {})
            logger.debug("Found components.securitySchemes (OpenAPI 3.x)")

        if not raw_schemes:
            logger.debug("No security schemes found in spec")
            return []

        detected = []
        for name, scheme_def in raw_schemes.items():
            if not isinstance(scheme_def, dict):
                continue

            scheme_type = self._map_spec_type(scheme_def)
            detected.append(
                DetectedAuthScheme(
                    scheme_type=scheme_type,
                    name=name,
                    source="spec",
                    details=self._extract_scheme_details(scheme_def),
                    endpoints=self._find_endpoints_using_scheme(name),
                )
            )

        return detected

    def _map_spec_type(self, scheme_def: dict) -> AuthSchemeType:
        """Map OpenAPI/Swagger type field to AuthSchemeType enum.

        Handles BOTH formats:
        - OpenAPI 3.x: type:"http" + scheme:"bearer" -> BEARER
        - OpenAPI 3.x: type:"http" + scheme:"basic" -> BASIC
        - OpenAPI 3.x: type:"apiKey" -> API_KEY
        - OpenAPI 3.x: type:"oauth2" -> OAUTH2
        - OpenAPI 3.x: type:"openIdConnect" -> OPENID_CONNECT
        - Swagger 2.0: type:"basic" (direct, no scheme field) -> BASIC
        """
        spec_type = scheme_def.get("type", "").lower()

        # OpenAPI 3.x http scheme
        if spec_type == "http":
            http_scheme = scheme_def.get("scheme", "").lower()
            if http_scheme == "bearer":
                return AuthSchemeType.BEARER
            elif http_scheme == "basic":
                return AuthSchemeType.BASIC
            return AuthSchemeType.UNKNOWN

        # OpenAPI 3.x apiKey
        elif spec_type == "apikey":
            return AuthSchemeType.API_KEY

        # OpenAPI 3.x oauth2
        elif spec_type == "oauth2":
            return AuthSchemeType.OAUTH2

        # OpenAPI 3.x openIdConnect
        elif spec_type == "openidconnect":
            return AuthSchemeType.OPENID_CONNECT

        # Swagger 2.0 uses type: "basic" directly (no scheme field needed)
        elif spec_type == "basic":
            return AuthSchemeType.BASIC

        return AuthSchemeType.UNKNOWN

    def _extract_scheme_details(self, scheme_def: dict) -> dict:
        """Extract relevant details from a security scheme definition."""
        details = {}
        spec_type = scheme_def.get("type", "").lower()

        # Copy raw type and scheme
        if "type" in scheme_def:
            details["type"] = scheme_def["type"]
        if "scheme" in scheme_def:
            details["scheme"] = scheme_def["scheme"]

        # Bearer-specific: bearerFormat
        if scheme_def.get("bearerFormat"):
            details["format"] = scheme_def["bearerFormat"]

        # apiKey-specific: in, name
        if spec_type == "apikey":
            if "in" in scheme_def:
                details["in"] = scheme_def["in"]
            if "name" in scheme_def:
                details["name"] = scheme_def["name"]

        # oauth2-specific: flows
        if spec_type == "oauth2" and "flows" in scheme_def:
            details["flows"] = scheme_def["flows"]

        # Swagger 2.0 oauth2: flow, authorizationUrl, tokenUrl, scopes
        if spec_type == "oauth2":
            for key in ("flow", "authorizationUrl", "tokenUrl", "scopes"):
                if key in scheme_def:
                    details[key] = scheme_def[key]

        # openIdConnect-specific: openIdConnectUrl
        if "openIdConnectUrl" in scheme_def:
            details["openIdConnectUrl"] = scheme_def["openIdConnectUrl"]

        return details

    def _find_endpoints_using_scheme(self, scheme_name: str) -> list[str]:
        """Find which endpoints reference a given security scheme.

        Checks both per-operation security and global security in the spec.
        Returns endpoints in "METHOD /path" format.
        """
        if not self.spec:
            return []

        using_scheme = []

        # Check global security
        global_security = self.spec.get("security", [])
        global_uses_scheme = any(
            scheme_name in sec_req
            for sec_req in global_security
            if isinstance(sec_req, dict)
        )

        paths = self.spec.get("paths", {})
        for path, path_item in paths.items():
            if not isinstance(path_item, dict):
                continue

            for method in ("get", "post", "put", "delete", "patch", "head", "options"):
                operation = path_item.get(method)
                if not operation or not isinstance(operation, dict):
                    continue

                op_security = operation.get("security")

                if op_security is not None:
                    # Explicit per-operation security
                    # Empty array [] means no auth required
                    if op_security == []:
                        continue
                    if any(
                        scheme_name in sec_req
                        for sec_req in op_security
                        if isinstance(sec_req, dict)
                    ):
                        using_scheme.append(f"{method.upper()} {path}")
                elif global_uses_scheme:
                    # Inherits global security
                    using_scheme.append(f"{method.upper()} {path}")

        return using_scheme

    def _select_probe_endpoints(self, count: int = 5) -> list:
        """Select representative endpoints for probing.

        Prefers GET endpoints, mixes paths for variety.
        """
        if not self.endpoints:
            return []

        # Prefer GET endpoints (safe methods)
        get_endpoints = [
            ep for ep in self.endpoints if ep.method.upper() == "GET"
        ]
        other_endpoints = [
            ep for ep in self.endpoints if ep.method.upper() != "GET"
        ]

        # Mix: prioritize GET, fill with others
        selected = []
        selected.extend(get_endpoints[:count])

        if len(selected) < count:
            remaining = count - len(selected)
            selected.extend(other_endpoints[:remaining])

        return selected[:count]

    def _probe_unauthenticated(self) -> list[DetectedAuthScheme]:
        """Send unauthenticated requests, parse 401/403 responses.

        Only probes with safe methods (GET, HEAD, OPTIONS).
        Never POST/PUT/DELETE for auth probing.
        """
        schemes = []
        seen_types: set[AuthSchemeType] = set()
        evidence_list: list[Evidence] = []

        probe_endpoints = self._select_probe_endpoints(count=5)

        for ep in probe_endpoints:
            # Check budget before each request
            if not self.budget.can_request():
                logger.warning(
                    "Discovery request budget exhausted, %d endpoints unprobed",
                    len(probe_endpoints) - probe_endpoints.index(ep),
                )
                break

            # Only use safe methods for probing
            method = ep.method.upper()
            if method not in ("GET", "HEAD", "OPTIONS"):
                # For non-safe methods, use HEAD instead
                method = "HEAD"

            try:
                evidence = self.http.request(
                    method=method,
                    url=ep.url,
                    headers={},
                )
                self.budget.record()
                evidence_list.append(evidence)

                if evidence.response_status in (401, 403):
                    # Parse WWW-Authenticate header
                    detected = self._parse_www_authenticate(evidence)
                    for d in detected:
                        if d.scheme_type not in seen_types:
                            seen_types.add(d.scheme_type)
                            schemes.append(d)

                    # Detect cookie-based auth from Set-Cookie
                    cookie_scheme = self._detect_session_cookie(evidence)
                    if cookie_scheme and AuthSchemeType.SESSION_COOKIE not in seen_types:
                        seen_types.add(AuthSchemeType.SESSION_COOKIE)
                        schemes.append(cookie_scheme)

            except Exception as e:
                logger.debug("Probe request failed for %s: %s", ep.url, e)
                continue

        return schemes

    def _parse_www_authenticate(self, evidence: Evidence) -> list[DetectedAuthScheme]:
        """Parse WWW-Authenticate header per RFC 7235.

        Matches known scheme names (Bearer, Basic, Digest, OAuth) via regex.
        Extracts realm if present.
        """
        schemes = []

        # Find WWW-Authenticate header (case-insensitive)
        www_auth = None
        for header_name, header_val in evidence.response_headers.items():
            if header_name.lower() == "www-authenticate":
                www_auth = header_val
                break

        if not www_auth:
            # No WWW-Authenticate header -- infer from status code
            return self._infer_from_status(evidence)

        # Parse multiple challenges (comma-separated at top level)
        # Match known scheme keywords
        scheme_pattern = re.compile(
            r"\b(Bearer|Basic|Digest|Negotiate|HOBA|OAuth)\b",
            re.IGNORECASE,
        )

        seen_scheme_names: set[str] = set()
        matches = scheme_pattern.finditer(www_auth)

        for match in matches:
            scheme_name = match.group(1).lower()

            # Avoid duplicates in same header
            if scheme_name in seen_scheme_names:
                continue
            seen_scheme_names.add(scheme_name)

            scheme_type_map = {
                "bearer": AuthSchemeType.BEARER,
                "basic": AuthSchemeType.BASIC,
                "digest": AuthSchemeType.UNKNOWN,  # Track but don't deeply support
                "negotiate": AuthSchemeType.UNKNOWN,
                "hoba": AuthSchemeType.UNKNOWN,
                "oauth": AuthSchemeType.OAUTH2,
            }
            scheme_type = scheme_type_map.get(scheme_name, AuthSchemeType.UNKNOWN)

            # Extract realm if present (search from match position)
            realm_match = re.search(r'realm="([^"]*)"', www_auth[match.start() :])
            realm = realm_match.group(1) if realm_match else ""

            schemes.append(
                DetectedAuthScheme(
                    scheme_type=scheme_type,
                    name=scheme_name,
                    source="probe",
                    details={"realm": realm, "raw_header": www_auth},
                )
            )

        return schemes

    def _detect_session_cookie(self, evidence: Evidence) -> DetectedAuthScheme | None:
        """Detect session cookie from Set-Cookie header."""
        for header_name, header_val in evidence.response_headers.items():
            if header_name.lower() == "set-cookie":
                # Check for session-like cookie names
                cookie_lower = header_val.lower()
                for session_name in self.SESSION_COOKIE_NAMES:
                    if session_name in cookie_lower:
                        return DetectedAuthScheme(
                            scheme_type=AuthSchemeType.SESSION_COOKIE,
                            name="session_cookie",
                            source="probe",
                            details={
                                "cookie_name_pattern": session_name,
                                "raw_header": header_val,
                            },
                        )
        return None

    def _infer_from_status(self, evidence: Evidence) -> list[DetectedAuthScheme]:
        """Infer auth requirement from status code when no WWW-Authenticate header.

        Returns UNKNOWN scheme with status code details.
        """
        if evidence.response_status in (401, 403):
            return [
                DetectedAuthScheme(
                    scheme_type=AuthSchemeType.UNKNOWN,
                    name="unknown",
                    source="probe",
                    details={
                        "status_code": evidence.response_status,
                        "note": "Auth required but scheme not specified in WWW-Authenticate header",
                    },
                )
            ]
        return []
