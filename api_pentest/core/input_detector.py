import json
import logging
from pathlib import Path
from typing import Any

import yaml

from api_pentest.core.models import Endpoint, InputFormat

logger = logging.getLogger(__name__)


class InputDetector:
    """Auto-detects input file format and delegates to the correct parser."""

    def __init__(self, file_path: str, environment_path: str | None = None,
                 base_url_override: str | None = None):
        self.file_path = Path(file_path)
        self.environment_path = Path(environment_path) if environment_path else None
        self.base_url_override = base_url_override
        self._data: dict | None = None
        self._env_data: dict | None = None
        self._format: InputFormat | None = None
        self._warnings: list[str] = []

    def load(self) -> dict:
        """Load the input file as JSON or YAML."""
        if not self.file_path.exists():
            raise FileNotFoundError(f"Input file not found: {self.file_path}")

        content = self.file_path.read_text(encoding="utf-8")

        if self.file_path.suffix.lower() in (".json",):
            self._data = json.loads(content)
        elif self.file_path.suffix.lower() in (".yaml", ".yml"):
            self._data = yaml.safe_load(content)
        else:
            # Try JSON first, then YAML
            try:
                self._data = json.loads(content)
            except json.JSONDecodeError:
                self._data = yaml.safe_load(content)

        if self.environment_path and self.environment_path.exists():
            env_content = self.environment_path.read_text(encoding="utf-8")
            self._env_data = json.loads(env_content)

        return self._data

    def detect_format(self) -> InputFormat:
        """Detect whether the file is Postman, Swagger 2.0, OpenAPI 3.0, or 3.1."""
        if self._data is None:
            self.load()

        data = self._data

        # Check for Postman collection
        info = data.get("info", {})
        if isinstance(info, dict):
            schema = info.get("schema", "") or info.get("_postman_id", "")
            if "schema.getpostman.com" in str(schema) or "_postman_id" in data.get("info", {}):
                if "v2.0.0" in str(schema):
                    self._format = InputFormat.POSTMAN_V20
                else:
                    self._format = InputFormat.POSTMAN_V21
                return self._format

        # Check for Postman by structure (no schema URL but has item array + info)
        if "item" in data and isinstance(info, dict) and "name" in info:
            self._format = InputFormat.POSTMAN_V21
            self._warnings.append("No Postman schema URL found; assuming v2.1 from structure")
            return self._format

        # Check for Swagger 2.0
        if data.get("swagger") == "2.0":
            self._format = InputFormat.SWAGGER_20
            return self._format

        # Check for OpenAPI 3.x
        openapi_version = str(data.get("openapi", ""))
        if openapi_version.startswith("3.1"):
            self._format = InputFormat.OPENAPI_31
            return self._format
        if openapi_version.startswith("3.0"):
            self._format = InputFormat.OPENAPI_30
            return self._format
        if openapi_version.startswith("3."):
            self._format = InputFormat.OPENAPI_30
            self._warnings.append(f"Unknown OpenAPI 3.x version '{openapi_version}'; treating as 3.0")
            return self._format

        raise ValueError(
            f"Unable to detect input format from {self.file_path}. "
            "Expected a Postman collection (v2.0/v2.1) or Swagger/OpenAPI spec (2.0/3.0/3.1)."
        )

    def parse(self) -> list[Endpoint]:
        """Parse the input file and return a list of Endpoint objects."""
        if self._format is None:
            self.detect_format()

        if self._format in (InputFormat.POSTMAN_V20, InputFormat.POSTMAN_V21):
            from api_pentest.core.postman_parser import PostmanParser
            parser = PostmanParser(self._data, environment_data=self._env_data)
            endpoints = parser.parse()
            self._warnings.extend(parser.warnings)

            # Apply base URL override
            if self.base_url_override:
                endpoints = self._apply_base_url(endpoints)

            return endpoints

        if self._format in (InputFormat.SWAGGER_20, InputFormat.OPENAPI_30, InputFormat.OPENAPI_31):
            from api_pentest.core.openapi_parser import OpenAPIParser
            parser = OpenAPIParser(self._data, base_url_override=self.base_url_override)
            endpoints = parser.parse()
            self._warnings.extend(parser.warnings)
            return endpoints

        raise ValueError(f"Unsupported format: {self._format}")

    def _apply_base_url(self, endpoints: list[Endpoint]) -> list[Endpoint]:
        """Replace the base URL in all endpoint URLs."""
        base = self.base_url_override.rstrip("/")
        for ep in endpoints:
            # Extract path from URL (everything after the host)
            from urllib.parse import urlparse
            parsed = urlparse(ep.url)
            path = parsed.path
            if parsed.query:
                path += f"?{parsed.query}"
            ep.url = f"{base}{path}"
        return endpoints

    @property
    def format(self) -> InputFormat | None:
        return self._format

    @property
    def warnings(self) -> list[str]:
        return self._warnings

    @property
    def data(self) -> dict | None:
        return self._data
