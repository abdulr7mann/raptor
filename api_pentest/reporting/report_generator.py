import json
import logging
from datetime import datetime, timezone
from pathlib import Path

from jinja2 import Environment, FileSystemLoader, select_autoescape
from markupsafe import Markup
from pygments import highlight
from pygments.formatters import HtmlFormatter
from pygments.lexers import HttpLexer

from api_pentest.core.models import Evidence, Finding, Severity, TestResult, TestStatus

logger = logging.getLogger(__name__)

# Jinja2 environment with autoescape enabled for all HTML templates
_template_dir = Path(__file__).parent / "templates"
_env = Environment(
    loader=FileSystemLoader(str(_template_dir)),
    autoescape=select_autoescape(["html"]),
    trim_blocks=True,
    lstrip_blocks=True,
)

# Pygments formatter: inline styles (no external CSS), monokai theme
_formatter = HtmlFormatter(noclasses=True, style="monokai", nowrap=False)

# Severity sort order: Critical first, Info last
_SEVERITY_ORDER = {
    Severity.CRITICAL: 0,
    Severity.HIGH: 1,
    Severity.MEDIUM: 2,
    Severity.LOW: 3,
    Severity.INFO: 4,
}


def _format_evidence_html(evidence: Evidence) -> Markup:
    """Render evidence as Pygments-highlighted HTML.

    Returns Markup so Jinja2 does not double-escape the syntax highlighting.
    All user-controlled data inside the highlighted blocks is escaped by Pygments.
    """
    # Build request text
    req_headers = "\n".join(
        f"{k}: {v}" for k, v in evidence.request_headers.items()
    )
    req_body = ""
    if evidence.request_body:
        if isinstance(evidence.request_body, (dict, list)):
            req_body = json.dumps(evidence.request_body, indent=2)
        else:
            req_body = str(evidence.request_body)

    request_text = (
        f"{evidence.request_method} {evidence.request_url}\n"
        f"{req_headers}"
    )
    if req_body:
        request_text += f"\n\n{req_body}"

    # Build response text
    resp_headers = "\n".join(
        f"{k}: {v}" for k, v in evidence.response_headers.items()
    )
    response_text = (
        f"HTTP/1.1 {evidence.response_status}\n"
        f"{resp_headers}"
    )
    if evidence.response_body:
        response_text += f"\n\n{evidence.response_body}"

    # Highlight with Pygments (escapes all content internally)
    request_html = highlight(request_text, HttpLexer(), _formatter)
    response_html = highlight(response_text, HttpLexer(), _formatter)

    timing_html = (
        f'<p class="evidence-timing">'
        f"Response time: {evidence.response_time_ms:.1f}ms"
        f"</p>"
    )

    html = (
        f'<div class="evidence">'
        f"<strong>Request:</strong>{request_html}"
        f"<strong>Response:</strong>{response_html}"
        f"{timing_html}"
        f"</div>"
    )

    return Markup(html)


class ReportGenerator:
    """Generates JSON and HTML pentest reports."""

    def __init__(self, output_dir: str = "./reports"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self._timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")

    def generate_json(self, results: list[TestResult], findings: list[Finding]) -> str:
        """Generate JSON report and return file path."""
        report = {
            "metadata": {
                "generated_at": datetime.now(timezone.utc).isoformat(),
                "total_tests": len(results),
                "total_findings": len(findings),
            },
            "summary": self._build_summary(results, findings),
            "findings": [f.to_dict() for f in findings],
            "results": [r.to_dict() for r in results],
        }

        path = self.output_dir / f"report_{self._timestamp}.json"
        path.write_text(json.dumps(report, indent=2, default=str), encoding="utf-8")
        return str(path)

    def generate_html(self, results: list[TestResult], findings: list[Finding]) -> str:
        """Generate HTML report and return file path."""
        summary = self._build_summary(results, findings)

        # Sort findings by severity: Critical first, Info last
        sorted_findings = sorted(
            findings, key=lambda f: _SEVERITY_ORDER.get(f.severity, 99)
        )

        # Build finding dicts with pre-rendered evidence HTML
        finding_dicts = []
        for f in sorted_findings:
            d = f.to_dict()
            if f.evidence:
                d["evidence_html"] = _format_evidence_html(f.evidence)
            else:
                d["evidence_html"] = None
            finding_dicts.append(d)

        # Build result dicts
        result_dicts = [r.to_dict() for r in results]

        # Render template
        template = _env.get_template("report.html")
        html = template.render(
            timestamp=datetime.now(timezone.utc).isoformat(),
            summary=summary,
            findings=finding_dicts,
            results=result_dicts,
        )

        path = self.output_dir / f"report_{self._timestamp}.html"
        path.write_text(html, encoding="utf-8")
        return str(path)

    @staticmethod
    def _build_summary(results: list[TestResult], findings: list[Finding]) -> dict:
        severity_counts = {s.value: 0 for s in Severity}
        for f in findings:
            severity_counts[f.severity.value] += 1

        return {
            "total_tests": len(results),
            "passed": sum(1 for r in results if r.status == TestStatus.PASS),
            "failed": sum(1 for r in results if r.status == TestStatus.FAIL),
            "errors": sum(1 for r in results if r.status == TestStatus.ERROR),
            "skipped": sum(1 for r in results if r.status == TestStatus.SKIP),
            "total_findings": len(findings),
            "severity": severity_counts,
        }
