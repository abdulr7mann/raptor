import logging
import re
import time

from api_pentest.core.api_discovery import ArchitectureType
from api_pentest.core.models import ScenarioApplicability, Severity, TestStatus
from api_pentest.scenarios.base_scenario import BaseScenario

logger = logging.getLogger(__name__)


class S04Injection(BaseScenario):
    """S04 - Injection Attacks (SQLi, NoSQL, Command, CRLF, SSTI)."""

    SCENARIO_ID = "S04"
    SCENARIO_NAME = "Injection Attacks"
    OWASP_ID = "API8:2023"
    OWASP_NAME = "Security Misconfiguration"
    APPLICABILITY = ScenarioApplicability(
        architectures=[ArchitectureType.REST, ArchitectureType.GRAPHQL, ArchitectureType.HYBRID, ArchitectureType.UNKNOWN],
        # No classification restriction - injection can affect any endpoint
    )

    SQLI_PAYLOADS = [
        ("' OR '1'='1", "sqli_basic"),
        ("' OR 1=1--", "sqli_comment"),
        ("' UNION SELECT NULL,NULL--", "sqli_union"),
        ("1; WAITFOR DELAY '0:0:5'--", "sqli_time_mssql"),
        ("1' AND SLEEP(5)--", "sqli_time_mysql"),
        ("1'; SELECT pg_sleep(5);--", "sqli_time_pg"),
    ]

    NOSQL_PAYLOADS = [
        ({"$gt": ""}, "nosql_gt"),
        ({"$ne": ""}, "nosql_ne"),
        ({"$regex": ".*"}, "nosql_regex"),
        ({"$where": "1==1"}, "nosql_where"),
    ]

    COMMAND_PAYLOADS = [
        ("; ls", "cmd_semicolon"),
        ("| cat /etc/passwd", "cmd_pipe"),
        ("`id`", "cmd_backtick"),
        ("$(whoami)", "cmd_dollar"),
    ]

    CRLF_PAYLOADS = [
        ("%0d%0aX-Injected: true", "crlf_encoded"),
        ("\r\nX-Injected: true", "crlf_raw"),
    ]

    SSTI_PAYLOADS = [
        ("{{7*7}}", "ssti_jinja", "49"),
        ("${7*7}", "ssti_freemarker", "49"),
        ("<%=7*7%>", "ssti_erb", "49"),
    ]

    SQL_ERROR_PATTERNS = re.compile(
        r"(sql syntax|mysql|postgresql|sqlite|oracle|microsoft sql|"
        r"unclosed quotation|quoted string|syntax error|ORA-\d|"
        r"pg_query|mysqli_|PDOException|SqlException)",
        re.IGNORECASE,
    )

    def get_test_cases(self) -> list[str]:
        return [
            "sql_injection",
            "nosql_injection",
            "command_injection",
            "crlf_injection",
            "ssti_injection",
        ]

    def execute_test(self, test_name: str):
        if test_name == "sql_injection":
            self._test_sql_injection()
        elif test_name == "nosql_injection":
            self._test_nosql_injection()
        elif test_name == "command_injection":
            self._test_command_injection()
        elif test_name == "crlf_injection":
            self._test_crlf_injection()
        elif test_name == "ssti_injection":
            self._test_ssti_injection()

    def _inject_into_params(self, ep, token, payload: str) -> list[tuple[str, object]]:
        """Inject payload into path params, query params, and body fields.

        Returns list of (location, evidence) tuples.
        """
        results = []

        # 1. Inject into path parameters (e.g., /users/v1/{username})
        path_injections = self.generate_path_injections(ep.url, payload)
        for modified_url, location, original_value in path_injections:
            evidence = self.make_request(ep, token=token, override_url=modified_url)
            results.append((location, evidence))

        # 2. Inject into query params
        if "?" in ep.url:
            base_url, query = ep.url.split("?", 1)
            for param in query.split("&"):
                if "=" in param:
                    key, _ = param.split("=", 1)
                    injected_url = ep.url.replace(f"{key}=", f"{key}={payload}", 1)
                    evidence = self.make_request(ep, token=token, override_url=injected_url)
                    results.append((f"query:{key}", evidence))

        # 3. Inject into body fields (string values only)
        if ep.body and isinstance(ep.body, dict):
            for field, value in ep.body.items():
                if isinstance(value, str):
                    modified_body = dict(ep.body)
                    modified_body[field] = payload
                    evidence = self.make_request(ep, token=token, override_body=modified_body)
                    results.append((f"body:{field}", evidence))

        return results

    def _test_sql_injection(self):
        """Test for SQL injection vulnerabilities."""
        token = self.get_token_a()
        vuln_found = False

        for ep in self.endpoints:
            for payload, payload_name in self.SQLI_PAYLOADS:
                injections = self._inject_into_params(ep, token, payload)

                for location, evidence in injections:
                    # Check for SQL error messages in response
                    if self.SQL_ERROR_PATTERNS.search(evidence.response_body):
                        vuln_found = True
                        self.add_result(
                            "sql_injection",
                            TestStatus.FAIL,
                            f"SQL error exposed: {ep.method} {ep.url} [{location}] with {payload_name}",
                            endpoint_name=ep.full_name,
                            evidence=evidence,
                        )
                        self.log_finding(
                            severity=Severity.CRITICAL,
                            title=f"SQL Injection on {ep.method} {ep.url}",
                            description=(
                                f"SQL error message detected in response when injecting "
                                f"'{payload}' into {location}."
                            ),
                            endpoint=f"{ep.method} {ep.url}",
                            evidence=evidence,
                            remediation="Use parameterized queries/prepared statements. Never concatenate user input into SQL.",
                        )
                        break

                    # Check for time-based blind SQLi
                    if "time" in payload_name and evidence.response_time_ms > 4500:
                        vuln_found = True
                        self.add_result(
                            "sql_injection",
                            TestStatus.FAIL,
                            f"Time-based blind SQLi: {ep.method} {ep.url} [{location}] "
                            f"response took {evidence.response_time_ms:.0f}ms",
                            endpoint_name=ep.full_name,
                            evidence=evidence,
                        )
                        self.log_finding(
                            severity=Severity.CRITICAL,
                            title=f"Time-based Blind SQL Injection on {ep.method} {ep.url}",
                            description=(
                                f"Injecting sleep payload into {location} caused a "
                                f"{evidence.response_time_ms:.0f}ms delay (expected ~5000ms)."
                            ),
                            endpoint=f"{ep.method} {ep.url}",
                            evidence=evidence,
                            remediation="Use parameterized queries. Implement query timeouts.",
                        )
                        break

        if not vuln_found:
            self.add_result("sql_injection", TestStatus.PASS, "No SQL injection detected")

    def _test_nosql_injection(self):
        """Test for NoSQL injection in JSON body fields."""
        token = self.get_token_a()
        vuln_found = False

        for ep in self.endpoints:
            if not ep.body or not isinstance(ep.body, dict):
                continue

            for nosql_payload, payload_name in self.NOSQL_PAYLOADS:
                for field, value in ep.body.items():
                    if not isinstance(value, str):
                        continue

                    modified_body = dict(ep.body)
                    modified_body[field] = nosql_payload

                    # Baseline comparison
                    baseline = self.make_request(ep, token=token)
                    evidence = self.make_request(ep, token=token, override_body=modified_body)

                    if (
                        self.is_success_status(evidence.response_status)
                        and evidence.response_body != baseline.response_body
                        and len(evidence.response_body) > len(baseline.response_body)
                    ):
                        vuln_found = True
                        self.add_result(
                            "nosql_injection",
                            TestStatus.FAIL,
                            f"NoSQL injection: {ep.method} {ep.url} field '{field}' with {payload_name}",
                            endpoint_name=ep.full_name,
                            evidence=evidence,
                        )
                        self.log_finding(
                            severity=Severity.HIGH,
                            title=f"NoSQL Injection on {ep.method} {ep.url}",
                            description=(
                                f"Injecting NoSQL operator {nosql_payload} into field '{field}' "
                                f"returned more data than the baseline request."
                            ),
                            endpoint=f"{ep.method} {ep.url}",
                            evidence=evidence,
                            remediation="Sanitize and validate all input. Use ODM query builders.",
                        )
                        break

        if not vuln_found:
            self.add_result("nosql_injection", TestStatus.PASS, "No NoSQL injection detected")

    def _test_command_injection(self):
        """Test for OS command injection."""
        token = self.get_token_a()
        vuln_found = False

        cmd_indicators = re.compile(
            r"(root:|uid=\d|/bin/|/etc/passwd|total \d|drwx|www-data|nobody)",
            re.IGNORECASE,
        )

        for ep in self.endpoints:
            for payload, payload_name in self.COMMAND_PAYLOADS:
                injections = self._inject_into_params(ep, token, payload)

                for location, evidence in injections:
                    if cmd_indicators.search(evidence.response_body):
                        vuln_found = True
                        self.add_result(
                            "command_injection",
                            TestStatus.FAIL,
                            f"Command injection: {ep.method} {ep.url} [{location}] with {payload_name}",
                            endpoint_name=ep.full_name,
                            evidence=evidence,
                        )
                        self.log_finding(
                            severity=Severity.CRITICAL,
                            title=f"OS Command Injection on {ep.method} {ep.url}",
                            description=(
                                f"Command output detected in response when injecting "
                                f"'{payload}' into {location}."
                            ),
                            endpoint=f"{ep.method} {ep.url}",
                            evidence=evidence,
                            remediation="Never pass user input to system commands. Use safe APIs instead of shell execution.",
                        )
                        break

        if not vuln_found:
            self.add_result("command_injection", TestStatus.PASS, "No command injection detected")

    def _test_crlf_injection(self):
        """Test for CRLF header injection."""
        token = self.get_token_a()
        vuln_found = False

        for ep in self.endpoints:
            for payload, payload_name in self.CRLF_PAYLOADS:
                # Inject into a header value
                evidence = self.make_request(
                    ep,
                    token=token,
                    override_headers={"X-Custom-Test": f"value{payload}"},
                )

                # Check if injected header appears in response
                resp_headers_lower = {k.lower(): v for k, v in evidence.response_headers.items()}
                if "x-injected" in resp_headers_lower:
                    vuln_found = True
                    self.add_result(
                        "crlf_injection",
                        TestStatus.FAIL,
                        f"CRLF injection: {ep.method} {ep.url} with {payload_name}",
                        endpoint_name=ep.full_name,
                        evidence=evidence,
                    )
                    self.log_finding(
                        severity=Severity.MEDIUM,
                        title=f"CRLF Header Injection on {ep.method} {ep.url}",
                        description="Injected header appeared in the HTTP response.",
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Sanitize CR/LF characters from header values.",
                    )
                    break

        if not vuln_found:
            self.add_result("crlf_injection", TestStatus.PASS, "No CRLF injection detected")

    def _test_ssti_injection(self):
        """Test for Server-Side Template Injection."""
        token = self.get_token_a()
        vuln_found = False

        for ep in self.endpoints:
            for payload, payload_name, expected in self.SSTI_PAYLOADS:
                injections = self._inject_into_params(ep, token, payload)

                for location, evidence in injections:
                    if expected in evidence.response_body:
                        vuln_found = True
                        self.add_result(
                            "ssti_injection",
                            TestStatus.FAIL,
                            f"SSTI: {ep.method} {ep.url} [{location}] with {payload_name} "
                            f"(found '{expected}' in response)",
                            endpoint_name=ep.full_name,
                            evidence=evidence,
                        )
                        self.log_finding(
                            severity=Severity.CRITICAL,
                            title=f"Server-Side Template Injection on {ep.method} {ep.url}",
                            description=(
                                f"Template expression '{payload}' was evaluated (found '{expected}' in response). "
                                f"Injection point: {location}."
                            ),
                            endpoint=f"{ep.method} {ep.url}",
                            evidence=evidence,
                            remediation="Never render user input in template engines. Use sandboxed templates.",
                        )
                        break

        if not vuln_found:
            self.add_result("ssti_injection", TestStatus.PASS, "No SSTI detected")
