import logging
import time
from concurrent.futures import ThreadPoolExecutor, as_completed

from api_pentest.core.models import Severity, TestStatus
from api_pentest.core.prerequisite_detector import DetectionStatus
from api_pentest.scenarios.base_scenario import BaseScenario

logger = logging.getLogger(__name__)


class S02RateLimiting(BaseScenario):
    """S02 - Insufficient Rate Limiting detection."""

    SCENARIO_ID = "S02"
    SCENARIO_NAME = "Insufficient Rate Limiting"
    OWASP_ID = "API4:2023"
    OWASP_NAME = "Unrestricted Resource Consumption"

    def get_test_cases(self) -> list[str]:
        return [
            "burst_requests",
            "response_time_degradation",
            "rate_limit_header_check",
            "header_bypass_attempt",
        ]

    def execute_test(self, test_name: str):
        if test_name == "burst_requests":
            self._test_burst_requests()
        elif test_name == "response_time_degradation":
            self._test_response_time_degradation()
        elif test_name == "rate_limit_header_check":
            self._test_rate_limit_headers()
        elif test_name == "header_bypass_attempt":
            self._test_header_bypass()

    def _get_rate_config(self) -> tuple[int, int]:
        rate_cfg = self.config.get("rate_limit", {})
        burst = rate_cfg.get("requests_per_burst", 50)
        window = rate_cfg.get("window_seconds", 10)
        return burst, window

    def _test_burst_requests(self):
        """Send a burst of requests and check for 429 responses."""
        burst_count, window = self._get_rate_config()
        token = self.get_token_a()

        # Test up to 5 endpoints
        test_endpoints = self.endpoints[:5]
        if not test_endpoints:
            self.add_result("burst_requests", TestStatus.SKIP, "No endpoints")
            return

        for ep in test_endpoints:
            rate_limited = 0
            success = 0
            errors = 0
            last_evidence = None

            for i in range(burst_count):
                evidence = self.make_request(ep, token=token)
                last_evidence = evidence

                if evidence.response_status == 429:
                    rate_limited += 1
                elif self.is_success_status(evidence.response_status):
                    success += 1
                else:
                    errors += 1

            logger.info(
                f"  {ep.method} {ep.url}: {success} ok, {rate_limited} rate-limited, {errors} errors"
            )

            if rate_limited > 0:
                self.add_result(
                    "burst_requests",
                    TestStatus.PASS,
                    f"{ep.method} {ep.url}: Rate limiting triggered after {success} requests "
                    f"({rate_limited} blocked)",
                    endpoint_name=ep.full_name,
                    evidence=last_evidence,
                )
            else:
                self.add_result(
                    "burst_requests",
                    TestStatus.FAIL,
                    f"{ep.method} {ep.url}: No rate limiting detected after {burst_count} requests",
                    endpoint_name=ep.full_name,
                    evidence=last_evidence,
                )
                self.log_finding(
                    severity=Severity.MEDIUM,
                    title="No rate limiting detected",
                    description=(
                        f"Sent {burst_count} rapid requests without triggering "
                        "any rate limiting (HTTP 429)."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=last_evidence,
                    remediation=(
                        "Implement rate limiting on all API endpoints. "
                        "Use sliding window or token bucket algorithms."
                    ),
                )

    def _test_response_time_degradation(self):
        """Check if response times degrade significantly under load."""
        token = self.get_token_a()
        ep = self.endpoints[0] if self.endpoints else None
        if not ep:
            self.add_result("response_time_degradation", TestStatus.SKIP, "No endpoints")
            return

        # Baseline: single request
        baseline = self.make_request(ep, token=token)
        baseline_time = baseline.response_time_ms

        # Load: send 20 rapid requests
        times = []
        for _ in range(20):
            ev = self.make_request(ep, token=token)
            if ev.response_status != 0:
                times.append(ev.response_time_ms)

        if not times:
            self.add_result("response_time_degradation", TestStatus.ERROR, "No successful responses")
            return

        avg_time = sum(times) / len(times)
        max_time = max(times)

        # Check for significant degradation (>3x baseline)
        if baseline_time > 0 and avg_time > baseline_time * 3:
            self.add_result(
                "response_time_degradation",
                TestStatus.FAIL,
                f"Response time degraded: baseline={baseline_time:.0f}ms, "
                f"avg_under_load={avg_time:.0f}ms, max={max_time:.0f}ms",
            )
            self.log_finding(
                severity=Severity.LOW,
                title="Response time degradation under load",
                description=(
                    f"Average response time increased from {baseline_time:.0f}ms to "
                    f"{avg_time:.0f}ms under rapid requests (max: {max_time:.0f}ms)."
                ),
                endpoint=f"{ep.method} {ep.url}",
                evidence=baseline,
                remediation="Investigate server capacity and implement request throttling.",
            )
        else:
            self.add_result(
                "response_time_degradation",
                TestStatus.PASS,
                f"Response times stable: baseline={baseline_time:.0f}ms, "
                f"avg={avg_time:.0f}ms, max={max_time:.0f}ms",
            )

    def _test_rate_limit_headers(self):
        """Check if rate limiting headers are present in responses."""
        token = self.get_token_a()
        ep = self.endpoints[0] if self.endpoints else None
        if not ep:
            self.add_result("rate_limit_header_check", TestStatus.SKIP, "No endpoints")
            return

        evidence = self.make_request(ep, token=token)

        rate_headers = []
        for header_name in evidence.response_headers:
            lower = header_name.lower()
            if any(kw in lower for kw in ["ratelimit", "rate-limit", "x-rate", "retry-after"]):
                rate_headers.append(f"{header_name}: {evidence.response_headers[header_name]}")

        if rate_headers:
            self.add_result(
                "rate_limit_header_check",
                TestStatus.PASS,
                f"Rate limit headers found: {'; '.join(rate_headers)}",
                evidence=evidence,
            )
        else:
            self.add_result(
                "rate_limit_header_check",
                TestStatus.FAIL,
                "No rate limiting headers found in response",
                evidence=evidence,
            )
            self.log_finding(
                severity=Severity.INFO,
                title="No rate limit headers in API responses",
                description="API responses do not include rate limiting headers.",
                endpoint=f"{ep.method} {ep.url}",
                evidence=evidence,
                remediation=(
                    "Include headers like X-RateLimit-Limit, X-RateLimit-Remaining, "
                    "X-RateLimit-Reset to inform clients of rate limits."
                ),
            )

    def _test_header_bypass(self):
        """Test if rate limiting can be bypassed with header manipulation."""
        token = self.get_token_a()
        ep = self.endpoints[0] if self.endpoints else None
        if not ep:
            self.add_result("header_bypass_attempt", TestStatus.SKIP, "No endpoints")
            return

        # Check if rate limiting exists before testing bypass
        rate_limit_prereq = self.get_prerequisite("rate_limiting")
        if rate_limit_prereq and rate_limit_prereq.status == DetectionStatus.ABSENT:
            self.add_skip_result(
                test_name="header_bypass_attempt",
                reason=rate_limit_prereq.reason,
                control="rate_limiting",
                endpoint_name=ep.full_name,
            )
            return

        bypass_headers_list = [
            {"X-Forwarded-For": "127.0.0.1"},
            {"X-Forwarded-For": "10.0.0.1"},
            {"X-Real-IP": "192.168.1.1"},
            {"X-Originating-IP": "172.16.0.1"},
            {"X-Client-IP": "8.8.8.8"},
        ]

        burst_count = self.config.get("rate_limit", {}).get("requests_per_burst", 50)
        bypass_found = False

        for bypass_headers in bypass_headers_list:
            success_count = 0
            for _ in range(burst_count):
                evidence = self.make_request(ep, token=token, override_headers=bypass_headers)
                if self.is_success_status(evidence.response_status):
                    success_count += 1

            header_name = list(bypass_headers.keys())[0]
            if success_count == burst_count:
                bypass_found = True
                self.log_finding(
                    severity=Severity.MEDIUM,
                    title=f"Rate limit bypass via {header_name}",
                    description=(
                        f"All {burst_count} requests succeeded with {header_name} header, "
                        "suggesting rate limiting may be bypassed."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Ensure rate limiting uses authenticated user identity, not client IP headers.",
                )

        status = TestStatus.FAIL if bypass_found else TestStatus.PASS
        self.add_result(
            "header_bypass_attempt",
            status,
            "Rate limit bypass via header manipulation " + ("possible" if bypass_found else "not detected"),
        )
