import logging
import re
from urllib.parse import urlparse

from api_pentest.core.models import ScenarioApplicability, Severity, TestStatus
from api_pentest.core.prerequisite_detector import DetectionStatus
from api_pentest.scenarios.base_scenario import BaseScenario

logger = logging.getLogger(__name__)


class S11SecurityMisconfig(BaseScenario):
    """S11 - Security Misconfiguration (API8:2023)."""

    SCENARIO_ID = "S11"
    SCENARIO_NAME = "Security Misconfiguration"
    OWASP_ID = "API8:2023"
    OWASP_NAME = "Security Misconfiguration"
    APPLICABILITY = ScenarioApplicability()  # Config issues affect all endpoints

    REQUIRED_HEADERS = {
        "Strict-Transport-Security": "HSTS not set - connections can be downgraded to HTTP",
        "X-Content-Type-Options": "Missing X-Content-Type-Options - MIME sniffing possible",
        "X-Frame-Options": "Missing X-Frame-Options - clickjacking possible",
    }

    RECOMMENDED_HEADERS = {
        "Content-Security-Policy": "No CSP header - XSS risk increased",
        "X-XSS-Protection": "Missing X-XSS-Protection header",
        "Referrer-Policy": "Missing Referrer-Policy header",
    }

    VERSION_HEADERS = [
        "Server",
        "X-Powered-By",
        "X-AspNet-Version",
        "X-AspNetMvc-Version",
        "X-Runtime",
        "X-Version",
        "X-Generator",
    ]

    DEFAULT_CREDS = [
        ("admin", "admin"),
        ("admin", "password"),
        ("admin", "123456"),
        ("admin", "admin123"),
        ("test", "test"),
        ("root", "root"),
        ("root", "toor"),
        ("user", "user"),
        ("guest", "guest"),
        ("demo", "demo"),
    ]

    ERROR_PATTERNS = re.compile(
        r"(Traceback \(most recent|File \"|at [\w.]+\(|"
        r"Exception in thread|java\.\w+Exception|"
        r"Microsoft\.AspNet|System\.Web\.|"
        r"stack trace:|RuntimeError|"
        r"/usr/|/var/|/home/|/opt/|C:\\\\|"
        r"SQLSTATE\[|PDOException|"
        r"django\.core|flask\.app|"
        r"Werkzeug Debugger|Debug mode)",
        re.IGNORECASE,
    )

    def get_test_cases(self) -> list[str]:
        return [
            "security_headers_check",
            "server_version_disclosure",
            "http_trace_method",
            "default_credentials",
            "cookie_security_flags",
            "error_verbosity",
            "cors_deep_analysis",
        ]

    def execute_test(self, test_name: str):
        if test_name == "security_headers_check":
            self._test_security_headers()
        elif test_name == "server_version_disclosure":
            self._test_version_disclosure()
        elif test_name == "http_trace_method":
            self._test_trace_method()
        elif test_name == "default_credentials":
            self._test_default_credentials()
        elif test_name == "cookie_security_flags":
            self._test_cookie_flags()
        elif test_name == "error_verbosity":
            self._test_error_verbosity()
        elif test_name == "cors_deep_analysis":
            self._test_cors_deep()

    def _normalize_headers(self, headers: dict) -> dict:
        """Return headers dict with lowercase keys."""
        return {k.lower(): v for k, v in headers.items()}

    def _test_security_headers(self):
        """Check for missing security headers on all endpoints."""
        token = self.get_token_a()
        any_missing = False

        all_headers = {}
        all_headers.update(self.REQUIRED_HEADERS)
        all_headers.update(self.RECOMMENDED_HEADERS)

        for ep in self.endpoints[:10]:
            evidence = self.make_request(ep, token=token)
            headers = self._normalize_headers(evidence.response_headers)

            for header, desc in all_headers.items():
                if header.lower() not in headers:
                    any_missing = True
                    is_required = header in self.REQUIRED_HEADERS
                    severity = Severity.MEDIUM if is_required else Severity.LOW

                    self.log_finding(
                        severity=severity,
                        title=f"Missing security header: {header}",
                        description=f"{desc}. Header not present in response.",
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation=f"Add the {header} header to all API responses.",
                    )

        if any_missing:
            self.add_result(
                "security_headers_check",
                TestStatus.FAIL,
                "Missing security header(s) on one or more endpoints",
            )
        else:
            self.add_result(
                "security_headers_check",
                TestStatus.PASS,
                "All security headers present",
            )

    def _test_version_disclosure(self):
        """Check for server version information in response headers."""
        token = self.get_token_a()
        disclosures = []

        version_pattern = re.compile(r"\d+\.\d+")

        for ep in self.endpoints[:10]:
            evidence = self.make_request(ep, token=token)

            for header_name in self.VERSION_HEADERS:
                value = evidence.response_headers.get(
                    header_name,
                    evidence.response_headers.get(header_name.lower(), ""),
                )
                if value and version_pattern.search(str(value)):
                    disclosure = f"{header_name}: {value}"
                    if disclosure not in disclosures:
                        disclosures.append(disclosure)
                        self.log_finding(
                            severity=Severity.LOW,
                            title=f"Server version disclosure: {header_name}",
                            description=(
                                f"Response header '{header_name}: {value}' reveals "
                                f"server/framework version information."
                            ),
                            endpoint=f"{ep.method} {ep.url}",
                            evidence=evidence,
                            remediation=f"Remove or suppress the {header_name} header in production.",
                        )

        if disclosures:
            self.add_result(
                "server_version_disclosure",
                TestStatus.FAIL,
                f"Version disclosed in {len(disclosures)} header(s): {'; '.join(disclosures[:3])}",
            )
        else:
            self.add_result(
                "server_version_disclosure",
                TestStatus.PASS,
                "No server version disclosure found",
            )

    def _test_trace_method(self):
        """Send TRACE requests to check for XST vulnerability."""
        token = self.get_token_a()
        vuln_found = False

        for ep in self.endpoints[:10]:
            evidence = self.make_request(ep, token=token, override_method="TRACE")

            if evidence.response_status == 200:
                vuln_found = True
                self.add_result(
                    "http_trace_method",
                    TestStatus.FAIL,
                    f"TRACE enabled on {ep.url} (HTTP 200)",
                    endpoint_name=ep.full_name,
                    evidence=evidence,
                )
                self.log_finding(
                    severity=Severity.MEDIUM,
                    title=f"HTTP TRACE method enabled: {ep.url}",
                    description=(
                        f"TRACE method returned HTTP 200 on {ep.url}. "
                        f"This can be exploited for Cross-Site Tracing (XST) attacks."
                    ),
                    endpoint=f"TRACE {ep.url}",
                    evidence=evidence,
                    remediation="Disable TRACE method on the web server.",
                )
                break

        if not vuln_found:
            self.add_result(
                "http_trace_method",
                TestStatus.PASS,
                "TRACE method properly disabled",
            )

    def _test_default_credentials(self):
        """Try common default credentials on login endpoints."""
        login_keywords = ["login", "signin", "sign-in", "authenticate", "auth", "token"]
        login_eps = []

        for ep in self.endpoints:
            name_lower = (ep.full_name or ep.name or ep.url).lower()
            if any(kw in name_lower for kw in login_keywords):
                login_eps.append(ep)

        if not login_eps:
            self.add_result("default_credentials", TestStatus.SKIP, "No login endpoints found")
            return

        vuln_found = False

        for ep in login_eps:
            for username, password in self.DEFAULT_CREDS:
                login_body = {"username": username, "password": password}
                evidence = self.make_request(ep, override_body=login_body)

                if self.is_success_status(evidence.response_status):
                    body_lower = evidence.response_body.lower()
                    if any(kw in body_lower for kw in ["token", "session", "auth", "jwt", "access"]):
                        vuln_found = True
                        self.add_result(
                            "default_credentials",
                            TestStatus.FAIL,
                            f"Default credentials work: {username}/{password} on {ep.url}",
                            endpoint_name=ep.full_name,
                            evidence=evidence,
                        )
                        self.log_finding(
                            severity=Severity.CRITICAL,
                            title=f"Default credentials accepted: {username}/{password}",
                            description=(
                                f"Login endpoint {ep.method} {ep.url} accepts default "
                                f"credentials ({username}/{password})."
                            ),
                            endpoint=f"{ep.method} {ep.url}",
                            evidence=evidence,
                            remediation="Remove default accounts. Enforce strong password policies.",
                        )
                        break

        if not vuln_found:
            self.add_result(
                "default_credentials",
                TestStatus.PASS,
                "No default credentials accepted",
            )

    def _test_cookie_flags(self):
        """Check Set-Cookie headers for security flags."""
        token = self.get_token_a()
        insecure_cookies = []

        login_keywords = ["login", "signin", "auth", "session", "token"]
        auth_eps = [
            ep for ep in self.endpoints
            if any(kw in (ep.full_name or ep.name or ep.url).lower() for kw in login_keywords)
        ]

        check_eps = auth_eps + self.endpoints[:5]

        for ep in check_eps:
            evidence = self.make_request(ep, token=token)

            set_cookie = evidence.response_headers.get(
                "Set-Cookie",
                evidence.response_headers.get("set-cookie", ""),
            )

            if not set_cookie:
                continue

            cookie_lower = set_cookie.lower()
            issues = []

            if "secure" not in cookie_lower:
                issues.append("missing Secure flag")
            if "httponly" not in cookie_lower:
                issues.append("missing HttpOnly flag")
            if "samesite" not in cookie_lower:
                issues.append("missing SameSite attribute")

            if issues:
                insecure_cookies.append((ep, issues, set_cookie, evidence))

        if insecure_cookies:
            for ep, issues, cookie, evidence in insecure_cookies:
                self.log_finding(
                    severity=Severity.MEDIUM,
                    title=f"Insecure cookie flags on {ep.url}",
                    description=(
                        f"Set-Cookie header at {ep.url} has: {', '.join(issues)}. "
                        f"Cookie: {cookie[:100]}"
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Set Secure, HttpOnly, and SameSite flags on all cookies.",
                )

            self.add_result(
                "cookie_security_flags",
                TestStatus.FAIL,
                f"Insecure cookies found on {len(insecure_cookies)} endpoint(s)",
            )
        else:
            self.add_result(
                "cookie_security_flags",
                TestStatus.PASS,
                "No insecure cookie flags detected (or no cookies set)",
            )

    def _test_error_verbosity(self):
        """Trigger errors and check for verbose error messages."""
        token = self.get_token_a()
        verbose_errors = []

        error_triggers = [
            {"headers": {"Content-Type": "application/xml"}, "body": "<invalid>"},
            {"headers": {"Content-Type": "application/json"}, "body": "{invalid json"},
            {"method": "GET", "url_suffix": "/" + "A" * 5000},
            {"method": "GET", "url_suffix": "/%00"},
            {"method": "GET", "url_suffix": "/1'"},
        ]

        for ep in self.endpoints[:5]:
            for trigger in error_triggers:
                kwargs = {"token": token}
                if "method" in trigger:
                    kwargs["override_method"] = trigger["method"]
                if "headers" in trigger:
                    kwargs["override_headers"] = trigger["headers"]
                if "body" in trigger:
                    kwargs["override_body"] = trigger["body"]
                if "url_suffix" in trigger:
                    kwargs["override_url"] = ep.url + trigger["url_suffix"]

                try:
                    evidence = self.make_request(ep, **kwargs)
                except Exception:
                    continue

                if self.ERROR_PATTERNS.search(evidence.response_body):
                    verbose_errors.append((ep.url, evidence))
                    self.log_finding(
                        severity=Severity.MEDIUM,
                        title=f"Verbose error message exposed: {ep.url}",
                        description=(
                            f"Error response from {ep.method} {ep.url} contains stack traces, "
                            f"file paths, or framework details: "
                            f"{evidence.response_body[:200]}"
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Return generic error messages in production. Log details server-side only.",
                    )
                    break

        if verbose_errors:
            self.add_result(
                "error_verbosity",
                TestStatus.FAIL,
                f"Verbose errors found on {len(verbose_errors)} endpoint(s)",
            )
        else:
            self.add_result(
                "error_verbosity",
                TestStatus.PASS,
                "No verbose error messages detected",
            )

    def _test_cors_deep(self):
        """Deep CORS analysis beyond basic origin reflection."""
        # Check if CORS is configured before testing deep CORS issues
        cors_prereq = self.get_prerequisite("cors")
        if cors_prereq and cors_prereq.status == DetectionStatus.ABSENT:
            self.add_skip_result(
                test_name="cors_deep_analysis",
                reason=cors_prereq.reason,
                control="cors",
            )
            return

        token = self.get_token_a()
        issues = []

        for ep in self.endpoints[:5]:
            preflight_headers = {
                "Origin": "https://evil.com",
                "Access-Control-Request-Method": "DELETE",
                "Access-Control-Request-Headers": "X-Custom-Header, Authorization",
            }

            evidence = self.make_request(
                ep, token=token, override_method="OPTIONS",
                override_headers=preflight_headers,
            )

            headers = self._normalize_headers(evidence.response_headers)

            allow_methods = headers.get("access-control-allow-methods", "")
            if allow_methods and "DELETE" in allow_methods.upper():
                issues.append(("dangerous_methods", ep, evidence, allow_methods))

            allow_headers = headers.get("access-control-allow-headers", "")
            if allow_headers == "*":
                issues.append(("wildcard_headers", ep, evidence, allow_headers))

            max_age = headers.get("access-control-max-age", "")
            if max_age:
                try:
                    if int(max_age) > 86400:
                        issues.append(("long_cache", ep, evidence, max_age))
                except ValueError:
                    pass

            acao = headers.get("access-control-allow-origin", "")
            acac = headers.get("access-control-allow-credentials", "")
            if acao == "https://evil.com" and acac.lower() == "true":
                issues.append(("creds_with_evil_origin", ep, evidence, f"{acao} + credentials"))

        if issues:
            for issue_type, ep, evidence, detail in issues:
                titles = {
                    "dangerous_methods": "CORS allows dangerous methods",
                    "wildcard_headers": "CORS allows wildcard headers",
                    "long_cache": "CORS max-age excessively long",
                    "creds_with_evil_origin": "CORS allows credentials with arbitrary origin",
                }
                severity = Severity.HIGH if issue_type == "creds_with_evil_origin" else Severity.MEDIUM

                self.log_finding(
                    severity=severity,
                    title=f"{titles.get(issue_type, 'CORS issue')}: {ep.url}",
                    description=f"CORS configuration issue on {ep.url}: {detail}",
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Restrict CORS methods, headers, and origins to minimum required set.",
                )

            self.add_result(
                "cors_deep_analysis",
                TestStatus.FAIL,
                f"Found {len(issues)} CORS configuration issue(s)",
            )
        else:
            self.add_result(
                "cors_deep_analysis",
                TestStatus.PASS,
                "CORS configuration appears secure",
            )
