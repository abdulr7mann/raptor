import json
import logging

from api_pentest.core.models import Severity, TestStatus
from api_pentest.scenarios.base_scenario import BaseScenario

logger = logging.getLogger(__name__)

class S13UnsafeConsumption(BaseScenario):
    """S13 - Unsafe API Consumption testing."""

    SCENARIO_ID = "S13"
    SCENARIO_NAME = "Unsafe API Consumption"
    OWASP_ID = "API10:2023"
    OWASP_NAME = "Unsafe Consumption of APIs"

    MAX_PAYLOAD_SIZE = 1_000_000  # 1MB
    NESTING_DEPTH = 100
    ARRAY_SIZE = 10_000

    def get_test_cases(self) -> list[str]:
        return [
            "content_type_mismatch",
            "data_type_confusion",
            "oversized_payload",
            "encoding_attacks",
            "null_and_special_values",
        ]

    def execute_test(self, test_name: str):
        if test_name == "content_type_mismatch":
            self._test_content_type_mismatch()
        elif test_name == "data_type_confusion":
            self._test_type_confusion()
        elif test_name == "oversized_payload":
            self._test_oversized_payload()
        elif test_name == "encoding_attacks":
            self._test_encoding_attacks()
        elif test_name == "null_and_special_values":
            self._test_null_special()

    def _get_write_endpoints(self):
        """Get POST/PUT endpoints with body."""
        return [
            ep for ep in self.endpoints
            if ep.method.upper() in ("POST", "PUT") and ep.body
        ]

    def _test_content_type_mismatch(self):
        """Send requests with mismatched Content-Type and body format."""
        token = self.get_token_a()
        write_eps = self._get_write_endpoints()

        if not write_eps:
            self.add_result("content_type_mismatch", TestStatus.SKIP, "No write endpoints with body")
            return

        mismatch_accepted = False

        mismatches = [
            ("application/json", '{"test": "value"}', "text/plain"),
            ("application/json", '{"test": "value"}', "application/xml"),
            ("application/json", '{"test": "value"}', "multipart/form-data"),
            ("text/plain", "just plain text not json", "application/json"),
        ]

        for ep in write_eps[:3]:
            for actual_format, body, wrong_ct in mismatches:
                evidence = self.make_request(
                    ep, token=token,
                    override_body=body,
                    override_headers={"Content-Type": wrong_ct},
                )

                if self.is_real_success(evidence):
                    mismatch_accepted = True
                    self.log_finding(
                        severity=Severity.MEDIUM,
                        title=f"Content-Type mismatch accepted: {ep.name}",
                        description=(
                            f"Sent {actual_format} body with Content-Type: {wrong_ct} to "
                            f"{ep.method} {ep.url}. Server accepted it (HTTP {evidence.response_status}). "
                            "This indicates the server ignores Content-Type validation."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Validate Content-Type header matches the actual request body format.",
                    )
                    break

        status = TestStatus.FAIL if mismatch_accepted else TestStatus.PASS
        self.add_result(
            "content_type_mismatch",
            status,
            f"Content-Type mismatch {'accepted' if mismatch_accepted else 'rejected'}",
        )

    def _test_type_confusion(self):
        """Send wrong data types for fields to test type validation."""
        token = self.get_token_a()
        write_eps = self._get_write_endpoints()

        if not write_eps:
            self.add_result("data_type_confusion", TestStatus.SKIP, "No write endpoints with body")
            return

        confusion_found = False

        type_mutations = [
            ("string_for_int", lambda v: "not_a_number" if isinstance(v, (int, float)) else v),
            ("int_for_string", lambda v: 99999 if isinstance(v, str) else v),
            ("array_for_object", lambda v: [v] if isinstance(v, dict) else v),
            ("object_for_string", lambda v: {"injected": "object"} if isinstance(v, str) else v),
            ("bool_for_string", lambda v: True if isinstance(v, str) else v),
        ]

        for ep in write_eps[:3]:
            if not isinstance(ep.body, dict):
                continue

            for mutation_name, mutator in type_mutations:
                mutated_body = {}
                for key, value in ep.body.items():
                    mutated_body[key] = mutator(value)

                if mutated_body == ep.body:
                    continue

                evidence = self.make_request(ep, token=token, override_body=mutated_body)

                if evidence.response_status == 500:
                    confusion_found = True
                    self.log_finding(
                        severity=Severity.MEDIUM,
                        title=f"Type confusion causes server error: {mutation_name} at {ep.name}",
                        description=(
                            f"Sending {mutation_name} mutation to {ep.method} {ep.url} caused "
                            f"HTTP 500. The server doesn't properly validate/reject wrong types."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Implement strict type validation on all input fields. Return 400 for type mismatches.",
                    )
                elif self.is_success_status(evidence.response_status):
                    confusion_found = True
                    self.log_finding(
                        severity=Severity.LOW,
                        title=f"Type confusion accepted: {mutation_name} at {ep.name}",
                        description=(
                            f"Sending {mutation_name} mutation to {ep.method} {ep.url} was "
                            f"accepted (HTTP {evidence.response_status}). The server may "
                            "silently coerce types without validation."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Implement strict type checking. Reject requests with incorrect field types.",
                    )

        status = TestStatus.FAIL if confusion_found else TestStatus.PASS
        self.add_result(
            "data_type_confusion",
            status,
            f"Type confusion {'issues found' if confusion_found else 'handled properly'}",
        )

    def _test_oversized_payload(self):
        """Send oversized and deeply nested payloads."""
        token = self.get_token_a()
        write_eps = self._get_write_endpoints()

        if not write_eps:
            self.add_result("oversized_payload", TestStatus.SKIP, "No write endpoints")
            return

        no_limits = False
        ep = write_eps[0]

        # Test 1: Large string payload
        large_body = {"data": "A" * self.MAX_PAYLOAD_SIZE}
        evidence = self.make_request(
            ep, token=token, override_body=large_body,
        )
        if self.is_success_status(evidence.response_status) or evidence.response_status == 500:
            if evidence.response_status != 413:
                no_limits = True
                self.log_finding(
                    severity=Severity.MEDIUM,
                    title=f"No payload size limit: {ep.name}",
                    description=(
                        f"A 1MB payload was sent to {ep.method} {ep.url} and returned "
                        f"HTTP {evidence.response_status} instead of 413 Payload Too Large."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Enforce request body size limits. Return 413 for oversized payloads.",
                )

        # Test 2: Deeply nested JSON
        nested = {"level": 0}
        current = nested
        for i in range(1, self.NESTING_DEPTH):
            current["nested"] = {"level": i}
            current = current["nested"]

        evidence_nested = self.make_request(
            ep, token=token, override_body=nested,
        )
        if evidence_nested.response_status == 500:
            no_limits = True
            self.log_finding(
                severity=Severity.MEDIUM,
                title=f"Deep nesting causes server error: {ep.name}",
                description=(
                    f"A JSON payload nested {self.NESTING_DEPTH} levels deep caused "
                    f"HTTP 500 at {ep.method} {ep.url}. No depth limit enforced."
                ),
                endpoint=f"{ep.method} {ep.url}",
                evidence=evidence_nested,
                remediation="Limit JSON nesting depth. Return 400 for excessively nested payloads.",
            )

        # Test 3: Large array
        large_array = {"items": list(range(self.ARRAY_SIZE))}
        evidence_array = self.make_request(
            ep, token=token, override_body=large_array,
        )
        if self.is_success_status(evidence_array.response_status) or evidence_array.response_status == 500:
            if evidence_array.response_status != 413:
                no_limits = True

        status = TestStatus.FAIL if no_limits else TestStatus.PASS
        self.add_result(
            "oversized_payload",
            status,
            f"Payload limits {'not enforced' if no_limits else 'enforced'}",
        )

    def _test_encoding_attacks(self):
        """Test character encoding edge cases."""
        token = self.get_token_a()
        write_eps = self._get_write_endpoints()

        if not write_eps:
            self.add_result("encoding_attacks", TestStatus.SKIP, "No write endpoints")
            return

        encoding_issues = False

        encoding_payloads = [
            ("utf8_bom", "\ufefftest_value"),
            ("null_byte", "test\x00admin"),
            ("unicode_override", "test\u202evalue"),
            ("zero_width", "test\u200bvalue"),
            ("homoglyph", "\u0430dmin"),  # Cyrillic 'Ð°' looks like Latin 'a'
        ]

        for ep in write_eps[:3]:
            if not isinstance(ep.body, dict):
                continue

            for enc_name, payload in encoding_payloads:
                body = dict(ep.body)
                # Inject into first string field
                for key, value in body.items():
                    if isinstance(value, str):
                        body[key] = payload
                        break
                else:
                    continue

                evidence = self.make_request(ep, token=token, override_body=body)

                if evidence.response_status == 500:
                    encoding_issues = True
                    self.log_finding(
                        severity=Severity.MEDIUM,
                        title=f"Encoding attack causes error: {enc_name} at {ep.name}",
                        description=(
                            f"Payload with {enc_name} encoding at {ep.method} {ep.url} "
                            f"caused HTTP 500. The server doesn't handle encoding edge cases."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Normalize and validate character encoding. Strip BOM, null bytes, and control characters.",
                    )
                elif self.is_success_status(evidence.response_status):
                    if enc_name in ("null_byte", "homoglyph"):
                        encoding_issues = True
                        self.log_finding(
                            severity=Severity.LOW,
                            title=f"Encoding bypass accepted: {enc_name} at {ep.name}",
                            description=(
                                f"{enc_name} payload accepted at {ep.method} {ep.url} "
                                f"(HTTP {evidence.response_status}). This may enable "
                                "input validation bypasses."
                            ),
                            endpoint=f"{ep.method} {ep.url}",
                            evidence=evidence,
                            remediation="Normalize unicode input. Reject null bytes and control characters.",
                        )

        status = TestStatus.FAIL if encoding_issues else TestStatus.PASS
        self.add_result(
            "encoding_attacks",
            status,
            f"Encoding issues {'found' if encoding_issues else 'not found'}",
        )

    def _test_null_special(self):
        """Test null and special values for required fields."""
        token = self.get_token_a()
        write_eps = self._get_write_endpoints()

        if not write_eps:
            self.add_result("null_and_special_values", TestStatus.SKIP, "No write endpoints")
            return

        bypass_found = False

        special_values = [
            ("null", None),
            ("empty_string", ""),
            ("empty_object", {}),
            ("empty_array", []),
            ("whitespace_only", "   "),
            ("single_space", " "),
        ]

        for ep in write_eps[:3]:
            if not isinstance(ep.body, dict):
                continue

            for value_name, special_value in special_values:
                body = {}
                for key in ep.body:
                    body[key] = special_value

                evidence = self.make_request(ep, token=token, override_body=body)

                if self.is_real_success(evidence):
                    bypass_found = True
                    self.log_finding(
                        severity=Severity.MEDIUM,
                        title=f"Null/special value accepted: {value_name} at {ep.name}",
                        description=(
                            f"All fields set to {value_name} were accepted at "
                            f"{ep.method} {ep.url} (HTTP {evidence.response_status}). "
                            "Required field validation may be missing."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Validate required fields are present and non-empty. Reject null/empty values for required fields.",
                    )
                    break  # One finding per endpoint is enough

        status = TestStatus.FAIL if bypass_found else TestStatus.PASS
        self.add_result(
            "null_and_special_values",
            status,
            f"Null/special values {'accepted' if bypass_found else 'properly rejected'}",
        )
