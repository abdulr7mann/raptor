import logging
import time
from abc import ABC, abstractmethod
from datetime import datetime, timezone

from api_pentest.core.http_client import PentestHttpClient
from api_pentest.core.models import (
    Endpoint,
    Evidence,
    Finding,
    Severity,
    TestResult,
    TestStatus,
    TokenContext,
)
from api_pentest.core.oauth2_handler import OAuth2Handler
from api_pentest.core.response_patterns import ResponsePatternLearner

logger = logging.getLogger(__name__)


class BaseScenario(ABC):
    """Abstract base class for all pentest attack scenarios."""

    SCENARIO_ID: str = ""
    SCENARIO_NAME: str = ""
    OWASP_ID: str = ""
    OWASP_NAME: str = ""

    def __init__(self):
        self.endpoints: list[Endpoint] = []
        self.oauth: OAuth2Handler | None = None
        self.oauth_b: OAuth2Handler | None = None
        self.http: PentestHttpClient | None = None
        self.config: dict = {}
        self.results: list[TestResult] = []
        self.findings: list[Finding] = []
        self._baselines: dict[str, Evidence] = {}
        self.response_learner: ResponsePatternLearner | None = None

    def setup(
        self,
        endpoints: list[Endpoint],
        oauth_handler: OAuth2Handler | None,
        http_client: PentestHttpClient,
        config: dict,
        oauth_handler_b: OAuth2Handler | None = None,
        response_learner: ResponsePatternLearner | None = None,
    ):
        """Initialize the scenario with shared resources."""
        self.endpoints = endpoints
        self.oauth = oauth_handler
        self.oauth_b = oauth_handler_b
        self.http = http_client
        self.config = config
        self.results = []
        self.findings = []
        self.response_learner = response_learner

    def run(self) -> list[TestResult]:
        """Execute all test cases for this scenario."""
        logger.info(f"[{self.SCENARIO_ID}] Starting: {self.SCENARIO_NAME}")
        test_cases = self.get_test_cases()
        logger.info(f"[{self.SCENARIO_ID}] {len(test_cases)} test case(s) to run")

        for test_name in test_cases:
            logger.info(f"[{self.SCENARIO_ID}] Running: {test_name}")
            start = time.time()
            try:
                self.execute_test(test_name)
            except Exception as e:
                self.results.append(TestResult(
                    scenario_id=self.SCENARIO_ID,
                    test_name=test_name,
                    status=TestStatus.ERROR,
                    details=f"Unhandled exception: {e}",
                    duration_ms=(time.time() - start) * 1000,
                ))
                logger.error(f"[{self.SCENARIO_ID}] Error in {test_name}: {e}")

        passed = sum(1 for r in self.results if r.status == TestStatus.PASS)
        failed = sum(1 for r in self.results if r.status == TestStatus.FAIL)
        errors = sum(1 for r in self.results if r.status == TestStatus.ERROR)
        logger.info(
            f"[{self.SCENARIO_ID}] Complete: {passed} passed, {failed} failed, {errors} errors"
        )
        return self.results

    @abstractmethod
    def get_test_cases(self) -> list[str]:
        """Return list of test case names to run."""
        ...

    @abstractmethod
    def execute_test(self, test_name: str):
        """Execute a single named test case."""
        ...

    def capture_baseline(self, endpoint: Endpoint, token: TokenContext | None = None) -> Evidence:
        """Make a normal request to establish baseline response."""
        key = f"{endpoint.method}:{endpoint.url}"
        if key in self._baselines:
            return self._baselines[key]

        auth_token = token.authorization_header if token else None
        evidence = self.http.request(
            method=endpoint.method,
            url=endpoint.url,
            headers=endpoint.headers,
            body=endpoint.body,
            auth_token=auth_token,
        )
        self._baselines[key] = evidence
        return evidence

    def add_result(
        self,
        test_name: str,
        status: TestStatus,
        details: str = "",
        endpoint_name: str = "",
        evidence: Evidence | None = None,
        duration_ms: float = 0.0,
    ):
        """Record a test result."""
        self.results.append(TestResult(
            scenario_id=self.SCENARIO_ID,
            test_name=test_name,
            endpoint_name=endpoint_name,
            status=status,
            details=details,
            evidence=evidence,
            duration_ms=duration_ms,
        ))

    def log_finding(
        self,
        severity: Severity,
        title: str,
        description: str,
        endpoint: str = "",
        evidence: Evidence | None = None,
        remediation: str = "",
    ):
        """Record a security finding."""
        self.findings.append(Finding(
            severity=severity,
            title=title,
            description=description,
            endpoint=endpoint,
            evidence=evidence,
            remediation=remediation,
            owasp_id=self.OWASP_ID,
            owasp_name=self.OWASP_NAME,
            scenario_id=self.SCENARIO_ID,
        ))

    def get_token_a(self) -> TokenContext | None:
        """Get primary user token."""
        if self.oauth:
            return self.oauth.acquire_token()
        return None

    def get_token_b(self) -> TokenContext | None:
        """Get secondary user token (for privilege/IDOR tests)."""
        if self.oauth_b:
            return self.oauth_b.acquire_token()
        return None

    def make_request(
        self,
        endpoint: Endpoint,
        token: TokenContext | None = None,
        override_headers: dict | None = None,
        override_body=None,
        override_method: str | None = None,
        override_url: str | None = None,
        auth_header_raw: str | None = None,
    ) -> Evidence:
        """Make an HTTP request to an endpoint with optional overrides."""
        method = override_method or endpoint.method
        url = override_url or endpoint.url
        headers = dict(endpoint.headers)
        if override_headers:
            headers.update(override_headers)

        body = override_body if override_body is not None else endpoint.body
        auth_token = auth_header_raw or (token.authorization_header if token else None)

        return self.http.request(
            method=method,
            url=url,
            headers=headers,
            body=body,
            auth_token=auth_token,
        )

    def is_real_success(self, evidence: Evidence, endpoint: Endpoint | None = None) -> bool:
        """Check if response represents genuine application-level success.

        Uses learned response patterns when available, falls back to
        HTTP status code check (is_success_status) when no learner or
        no pattern exists for the endpoint.
        """
        if not self.is_success_status(evidence.response_status):
            return False
        if self.response_learner is None:
            return True
        # Build endpoint key matching the learner's convention
        endpoint_key = f"{evidence.request_method}:{evidence.request_url}"
        return self.response_learner.is_real_success(evidence, endpoint_key)

    def is_success_status(self, status_code: int) -> bool:
        return 200 <= status_code < 300

    def is_auth_failure(self, status_code: int) -> bool:
        return status_code in (401, 403)
