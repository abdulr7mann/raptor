import logging
import time
from abc import ABC, abstractmethod
from datetime import datetime, timezone

from api_pentest.core.http_client import PentestHttpClient
from api_pentest.core.models import (
    Endpoint,
    EndpointClassification,
    Evidence,
    Finding,
    ScenarioApplicability,
    Severity,
    TestResult,
    TestStatus,
    TokenContext,
)
from api_pentest.core.oauth2_handler import OAuth2Handler
from api_pentest.core.finding_validator import FindingValidator
from api_pentest.core.response_formats import ResponseFormatHandler
from api_pentest.core.response_patterns import ResponsePatternLearner

logger = logging.getLogger(__name__)


class BaseScenario(ABC):
    """Abstract base class for all pentest attack scenarios."""

    SCENARIO_ID: str = ""
    SCENARIO_NAME: str = ""
    OWASP_ID: str = ""
    OWASP_NAME: str = ""
    APPLICABILITY = ScenarioApplicability()  # Empty = applies to all

    def __init__(self):
        self.endpoints: list[Endpoint] = []
        self.oauth: OAuth2Handler | None = None
        self.oauth_b: OAuth2Handler | None = None
        self.http: PentestHttpClient | None = None
        self.config: dict = {}
        self.results: list[TestResult] = []
        self.findings: list[Finding] = []
        self._baselines: dict[str, Evidence] = {}
        self.response_learner: ResponsePatternLearner | None = None
        self.prerequisite_results: dict = {}
        self.api_profile = None
        self.finding_validator: FindingValidator | None = None

    def setup(
        self,
        endpoints: list[Endpoint],
        oauth_handler: OAuth2Handler | None,
        http_client: PentestHttpClient,
        config: dict,
        oauth_handler_b: OAuth2Handler | None = None,
        response_learner: ResponsePatternLearner | None = None,
        prerequisite_results: dict | None = None,
        api_profile=None,
        finding_validator: FindingValidator | None = None,
    ):
        """Initialize the scenario with shared resources."""
        self.endpoints = endpoints
        self.oauth = oauth_handler
        self.oauth_b = oauth_handler_b
        self.http = http_client
        self.config = config
        self.results = []
        self.findings = []
        self.response_learner = response_learner
        self.prerequisite_results = prerequisite_results or {}
        self.api_profile = api_profile
        self.finding_validator = finding_validator

    def run(self) -> list[TestResult]:
        """Execute all test cases for this scenario."""
        logger.info(f"[{self.SCENARIO_ID}] Starting: {self.SCENARIO_NAME}")
        test_cases = self.get_test_cases()
        logger.info(f"[{self.SCENARIO_ID}] {len(test_cases)} test case(s) to run")

        for test_name in test_cases:
            logger.info(f"[{self.SCENARIO_ID}] Running: {test_name}")
            start = time.time()
            try:
                self.execute_test(test_name)
            except Exception as e:
                self.results.append(TestResult(
                    scenario_id=self.SCENARIO_ID,
                    test_name=test_name,
                    status=TestStatus.ERROR,
                    details=f"Unhandled exception: {e}",
                    duration_ms=(time.time() - start) * 1000,
                ))
                logger.error(f"[{self.SCENARIO_ID}] Error in {test_name}: {e}")

        passed = sum(1 for r in self.results if r.status == TestStatus.PASS)
        failed = sum(1 for r in self.results if r.status == TestStatus.FAIL)
        errors = sum(1 for r in self.results if r.status == TestStatus.ERROR)
        logger.info(
            f"[{self.SCENARIO_ID}] Complete: {passed} passed, {failed} failed, {errors} errors"
        )
        return self.results

    @abstractmethod
    def get_test_cases(self) -> list[str]:
        """Return list of test case names to run."""
        ...

    @abstractmethod
    def execute_test(self, test_name: str):
        """Execute a single named test case."""
        ...

    def capture_baseline(self, endpoint: Endpoint, token: TokenContext | None = None) -> Evidence:
        """Make a normal request to establish baseline response."""
        key = f"{endpoint.method}:{endpoint.url}"
        if key in self._baselines:
            return self._baselines[key]

        auth_token = token.authorization_header if token else None
        evidence = self.http.request(
            method=endpoint.method,
            url=endpoint.url,
            headers=endpoint.headers,
            body=endpoint.body,
            auth_token=auth_token,
        )
        self._baselines[key] = evidence
        return evidence

    def add_result(
        self,
        test_name: str,
        status: TestStatus,
        details: str = "",
        endpoint_name: str = "",
        evidence: Evidence | None = None,
        duration_ms: float = 0.0,
    ):
        """Record a test result."""
        self.results.append(TestResult(
            scenario_id=self.SCENARIO_ID,
            test_name=test_name,
            endpoint_name=endpoint_name,
            status=status,
            details=details,
            evidence=evidence,
            duration_ms=duration_ms,
        ))

    def log_finding(
        self,
        severity: Severity,
        title: str,
        description: str,
        endpoint: str = "",
        evidence: Evidence | None = None,
        remediation: str = "",
    ):
        """Record a security finding with confidence validation."""
        finding = Finding(
            severity=severity,
            title=title,
            description=description,
            endpoint=endpoint,
            evidence=evidence,
            remediation=remediation,
            owasp_id=self.OWASP_ID,
            owasp_name=self.OWASP_NAME,
            scenario_id=self.SCENARIO_ID,
        )

        # Validate and enrich with confidence if validator available
        if self.finding_validator and evidence:
            endpoint_key = f"{evidence.request_method}:{evidence.request_url}"
            finding = self.finding_validator.validate(finding, endpoint_key)

        self.findings.append(finding)

    def get_token_a(self) -> TokenContext | None:
        """Get primary user token."""
        if self.oauth:
            return self.oauth.acquire_token()
        return None

    def get_token_b(self) -> TokenContext | None:
        """Get secondary user token (for privilege/IDOR tests)."""
        if self.oauth_b:
            return self.oauth_b.acquire_token()
        return None

    def make_request(
        self,
        endpoint: Endpoint,
        token: TokenContext | None = None,
        override_headers: dict | None = None,
        override_body=None,
        override_method: str | None = None,
        override_url: str | None = None,
        auth_header_raw: str | None = None,
    ) -> Evidence:
        """Make an HTTP request to an endpoint with optional overrides."""
        method = override_method or endpoint.method
        url = override_url or endpoint.url
        headers = dict(endpoint.headers)
        if override_headers:
            headers.update(override_headers)

        body = override_body if override_body is not None else endpoint.body
        auth_token = auth_header_raw or (token.authorization_header if token else None)

        return self.http.request(
            method=method,
            url=url,
            headers=headers,
            body=body,
            auth_token=auth_token,
        )

    def is_real_success(self, evidence: Evidence, endpoint: Endpoint | None = None) -> bool:
        """Check if response represents genuine application-level success.

        Uses learned response patterns when available, falls back to
        HTTP status code check (is_success_status) when no learner or
        no pattern exists for the endpoint.
        """
        if not self.is_success_status(evidence.response_status):
            return False
        if self.response_learner is None:
            return True
        # Build endpoint key matching the learner's convention
        endpoint_key = f"{evidence.request_method}:{evidence.request_url}"
        return self.response_learner.is_real_success(evidence, endpoint_key)

    def is_success_status(self, status_code: int) -> bool:
        return 200 <= status_code < 300

    def is_auth_failure(self, status_code: int) -> bool:
        return status_code in (401, 403)

    def is_public_endpoint(self, endpoint: Endpoint) -> bool:
        """Check if endpoint is classified as public (no auth required)."""
        return endpoint.classification == EndpointClassification.PUBLIC

    def is_auth_endpoint(self, endpoint: Endpoint) -> bool:
        """Check if endpoint is classified as an auth endpoint (returns credentials by design)."""
        return endpoint.classification == EndpointClassification.AUTH_ENDPOINT

    def get_prerequisite(self, control_name: str):
        """Return the PrerequisiteResult for a control, or None if not detected."""
        return self.prerequisite_results.get(control_name)

    def add_skip_result(self, test_name: str, reason: str, control: str, endpoint_name: str = ""):
        """Record a SKIP result when a prerequisite control is not present."""
        logger.info(
            "[%s] Skipping %s: %s (precondition: %s not detected)",
            self.SCENARIO_ID, test_name, reason, control,
        )
        self.add_result(
            test_name=test_name,
            status=TestStatus.SKIP,
            details=f"Precondition not met: {reason}",
            endpoint_name=endpoint_name,
        )

    def parse_response_body(self, evidence: Evidence):
        """Parse response body based on Content-Type.

        Returns (parsed_data, format_type) where format_type is
        'json', 'xml', 'text', or 'empty'.
        """
        handler = ResponseFormatHandler()
        return handler.parse(evidence)

    def parse_json_safe(self, evidence: Evidence):
        """Parse response as JSON if possible, return None otherwise."""
        handler = ResponseFormatHandler()
        return handler.parse_json_safe(evidence)

    def get_auth_header_from_profile(self) -> str:
        """Get the appropriate auth header name from api_profile.

        Returns the auth header name to use (e.g., 'Authorization', 'X-API-Key'),
        based on detected auth schemes in api_profile. Falls back to 'Authorization'.
        """
        if not self.api_profile or not self.api_profile.auth_schemes:
            return "Authorization"

        # Prefer Bearer/OAuth, then API key, then first detected
        for scheme in self.api_profile.auth_schemes:
            # Handle both dict (from JSON) and DetectedAuthScheme objects
            if isinstance(scheme, dict):
                scheme_type = scheme.get("scheme_type", "").lower()
            else:
                scheme_type = scheme.scheme_type.value.lower() if hasattr(scheme.scheme_type, "value") else str(scheme.scheme_type).lower()

            if scheme_type in ("bearer", "oauth2", "jwt"):
                return "Authorization"
            if "api" in scheme_type and "key" in scheme_type:
                return "X-API-Key"

        # Default to Authorization for any auth scheme
        return "Authorization"

    def get_content_type_from_profile(self) -> str:
        """Get the preferred content type from api_profile.

        Returns the content type string to use in requests,
        based on detected content_types in api_profile. Falls back to 'application/json'.
        """
        if not self.api_profile or not self.api_profile.content_types_observed:
            return "application/json"

        # Prefer JSON if available
        for ct in self.api_profile.content_types_observed:
            if "json" in ct.lower():
                return ct

        # Return first detected content type
        return self.api_profile.content_types_observed[0]
