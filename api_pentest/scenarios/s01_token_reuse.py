import logging

from api_pentest.core.models import Severity, TestStatus
from api_pentest.scenarios.base_scenario import BaseScenario

logger = logging.getLogger(__name__)


class S01TokenReuse(BaseScenario):
    """S01 - Authentication Token Reuse across endpoints and scopes."""

    SCENARIO_ID = "S01"
    SCENARIO_NAME = "Authentication Token Reuse"
    OWASP_ID = "API2:2023"
    OWASP_NAME = "Broken Authentication"

    def get_test_cases(self) -> list[str]:
        cases = ["cross_endpoint_replay"]
        if self.oauth:
            cases.append("old_token_after_refresh")
        if self.oauth and self.oauth_b:
            cases.append("cross_user_token_swap")
        return cases

    def execute_test(self, test_name: str):
        if test_name == "cross_endpoint_replay":
            self._test_cross_endpoint_replay()
        elif test_name == "old_token_after_refresh":
            self._test_old_token_after_refresh()
        elif test_name == "cross_user_token_swap":
            self._test_cross_user_token_swap()

    def _test_cross_endpoint_replay(self):
        """Test if a token obtained for one endpoint works on all other endpoints."""
        token = self.get_token_a()
        if not token:
            self.add_result("cross_endpoint_replay", TestStatus.SKIP, "No token available")
            return

        accepted_pairs = []
        tested = 0

        for ep in self.endpoints:
            evidence = self.make_request(ep, token=token)

            if self.is_success_status(evidence.response_status):
                accepted_pairs.append((ep, evidence))
            tested += 1

        if tested == 0:
            self.add_result("cross_endpoint_replay", TestStatus.SKIP, "No endpoints to test")
            return

        ratio = len(accepted_pairs) / tested
        if ratio > 0.8:
            self.add_result(
                "cross_endpoint_replay",
                TestStatus.FAIL,
                f"Token accepted by {len(accepted_pairs)}/{tested} endpoints ({ratio:.0%}). "
                "Token may have excessive scope.",
            )
            for ep, evidence in accepted_pairs:
                self.log_finding(
                    severity=Severity.MEDIUM,
                    title="Token accepted across most endpoints",
                    description=(
                        "A single token was accepted at this endpoint. "
                        "Token may have excessive scope."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Implement fine-grained scope validation per endpoint.",
                )
        else:
            self.add_result(
                "cross_endpoint_replay",
                TestStatus.PASS,
                f"Token accepted by {len(accepted_pairs)}/{tested} endpoints ({ratio:.0%})",
            )

    def _test_old_token_after_refresh(self):
        """Test if an old token still works after refresh."""
        token_a = self.get_token_a()
        if not token_a:
            self.add_result("old_token_after_refresh", TestStatus.SKIP, "No token available")
            return

        old_token_value = token_a.access_token

        # Refresh the token
        new_token = self.oauth.refresh_token(token_a)
        if not new_token:
            # Try re-acquiring instead
            new_token = self.oauth.acquire_token(force_refresh=True)
        if not new_token:
            self.add_result("old_token_after_refresh", TestStatus.SKIP, "Could not refresh token")
            return

        # Test old token against endpoints
        accepted_pairs = []
        tested = 0

        for ep in self.endpoints[:10]:  # Test subset
            evidence = self.make_request(
                ep, auth_header_raw=f"Bearer {old_token_value}"
            )
            if self.is_success_status(evidence.response_status):
                accepted_pairs.append((ep, evidence))
            tested += 1

        if accepted_pairs:
            self.add_result(
                "old_token_after_refresh",
                TestStatus.FAIL,
                f"Old token still accepted by {len(accepted_pairs)}/{tested} endpoints after refresh",
            )
            for ep, evidence in accepted_pairs:
                self.log_finding(
                    severity=Severity.HIGH,
                    title="Old tokens not revoked after refresh",
                    description=(
                        "After token refresh, the previous token was still "
                        "accepted at this endpoint."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Implement token revocation on refresh. Use token blacklisting or short expiry.",
                )
        else:
            self.add_result(
                "old_token_after_refresh",
                TestStatus.PASS,
                "Old token properly rejected after refresh",
            )

    def _test_cross_user_token_swap(self):
        """Test if User A's token can access User B's resources."""
        token_a = self.get_token_a()
        token_b = self.get_token_b()

        if not token_a or not token_b:
            self.add_result("cross_user_token_swap", TestStatus.SKIP, "Need both User A and B tokens")
            return

        # Get baseline with correct tokens
        # Then try User A's token on endpoints that User B accesses
        accepted_pairs = []
        tested = 0

        for ep in self.endpoints[:10]:
            # Baseline: User B's own request
            baseline = self.make_request(ep, token=token_b)
            if not self.is_success_status(baseline.response_status):
                continue

            # Attack: User A's token on same endpoint
            evidence = self.make_request(ep, token=token_a)
            tested += 1

            if self.is_success_status(evidence.response_status):
                accepted_pairs.append((ep, evidence))

        if accepted_pairs and tested > 0:
            self.add_result(
                "cross_user_token_swap",
                TestStatus.FAIL,
                f"User A token accepted for {len(accepted_pairs)}/{tested} of User B's endpoints",
            )
            for ep, evidence in accepted_pairs:
                self.log_finding(
                    severity=Severity.HIGH,
                    title="Cross-user token swap accepted",
                    description=(
                        "User A's token was accepted at this endpoint that User B also "
                        "has access to. This may indicate insufficient user-level authorization."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Implement user-level authorization checks beyond token validation.",
                )
        else:
            self.add_result(
                "cross_user_token_swap",
                TestStatus.PASS,
                f"Cross-user token properly differentiated ({tested} tested)",
            )
