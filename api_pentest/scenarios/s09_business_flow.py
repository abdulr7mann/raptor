import logging
import time

from api_pentest.core.models import ScenarioApplicability, Severity, TestStatus
from api_pentest.scenarios.base_scenario import BaseScenario

logger = logging.getLogger(__name__)


class S09BusinessFlow(BaseScenario):
    """S09 - Sensitive Business Flow Abuse (API6:2023)."""

    SCENARIO_ID = "S09"
    SCENARIO_NAME = "Sensitive Business Flow Abuse"
    OWASP_ID = "API6:2023"
    OWASP_NAME = "Unrestricted Access to Sensitive Business Flows"
    APPLICABILITY = ScenarioApplicability()  # No restrictions - business logic can be anywhere

    def get_test_cases(self) -> list[str]:
        return [
            "mass_resource_creation",
            "resource_lifecycle_abuse",
            "duplicate_creation",
            "business_logic_validation",
            "workflow_bypass",
        ]

    def execute_test(self, test_name: str):
        if test_name == "mass_resource_creation":
            self._test_mass_creation()
        elif test_name == "resource_lifecycle_abuse":
            self._test_lifecycle_abuse()
        elif test_name == "duplicate_creation":
            self._test_duplicate_creation()
        elif test_name == "business_logic_validation":
            self._test_business_logic()
        elif test_name == "workflow_bypass":
            self._test_workflow_bypass()

    def _get_creation_endpoints(self):
        """Find POST endpoints likely used for resource creation."""
        creation_keywords = ["create", "register", "add", "new", "signup", "sign-up"]
        creation_eps = []
        for ep in self.endpoints:
            if ep.method.upper() != "POST":
                continue
            name_lower = (ep.full_name or ep.name or ep.url).lower()
            url_lower = ep.url.lower()
            if any(kw in name_lower or kw in url_lower for kw in creation_keywords):
                creation_eps.append(ep)
        if not creation_eps:
            creation_eps = [ep for ep in self.endpoints if ep.method.upper() == "POST"]
        return creation_eps[:3]

    def _test_mass_creation(self):
        """Send rapid POST requests to creation endpoints to check for rate limiting."""
        token = self.get_token_a()
        creation_eps = self._get_creation_endpoints()

        if not creation_eps:
            self.add_result("mass_resource_creation", TestStatus.SKIP, "No creation endpoints found")
            return

        burst_count = self.config.get("rate_limit", {}).get("requests_per_burst", 20)
        vuln_found = False

        for ep in creation_eps:
            successes = 0
            last_evidence = None

            for i in range(burst_count):
                body = dict(ep.body) if ep.body and isinstance(ep.body, dict) else {}
                for field in body:
                    if isinstance(body[field], str):
                        body[field] = f"{body[field]}_flood_{i}"
                if not body:
                    body = {"name": f"flood_test_{i}", "data": f"test_{i}"}

                evidence = self.make_request(ep, token=token, override_body=body)
                last_evidence = evidence
                if self.is_real_success(evidence):
                    successes += 1

            success_rate = successes / burst_count if burst_count > 0 else 0

            if success_rate > 0.9:
                vuln_found = True
                self.add_result(
                    "mass_resource_creation",
                    TestStatus.FAIL,
                    f"No rate limiting: {successes}/{burst_count} rapid POSTs succeeded on {ep.url}",
                    endpoint_name=ep.full_name,
                    evidence=last_evidence,
                )
                self.log_finding(
                    severity=Severity.MEDIUM,
                    title=f"No rate limiting on resource creation: {ep.url}",
                    description=(
                        f"{successes}/{burst_count} rapid creation requests succeeded "
                        f"without throttling on {ep.method} {ep.url}."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=last_evidence,
                    remediation="Implement rate limiting on creation endpoints. Use CAPTCHA for user-facing flows.",
                )

        if not vuln_found:
            self.add_result(
                "mass_resource_creation",
                TestStatus.PASS,
                "Creation endpoints have rate limiting or throttling",
            )

    def _test_lifecycle_abuse(self):
        """Create resources rapidly to test lifecycle controls."""
        token = self.get_token_a()
        creation_eps = self._get_creation_endpoints()

        if not creation_eps:
            self.add_result("resource_lifecycle_abuse", TestStatus.SKIP, "No creation endpoints found")
            return

        vuln_found = False
        loop_count = 10
        ep = creation_eps[0]
        successes = 0
        last_evidence = None

        for i in range(loop_count):
            body = dict(ep.body) if ep.body and isinstance(ep.body, dict) else {}
            for field in body:
                if isinstance(body[field], str):
                    body[field] = f"{body[field]}_cycle_{i}"
            if not body:
                body = {"name": f"cycle_test_{i}"}

            evidence = self.make_request(ep, token=token, override_body=body)
            last_evidence = evidence
            if self.is_real_success(evidence):
                successes += 1

        if successes >= loop_count:
            vuln_found = True
            self.add_result(
                "resource_lifecycle_abuse",
                TestStatus.FAIL,
                f"All {loop_count} lifecycle iterations succeeded without throttling",
                endpoint_name=ep.full_name,
                evidence=last_evidence,
            )
            self.log_finding(
                severity=Severity.LOW,
                title=f"Resource lifecycle abuse possible: {ep.url}",
                description=(
                    f"Rapid create cycles ({loop_count} iterations) completed "
                    f"without rate limiting on {ep.method} {ep.url}."
                ),
                endpoint=f"{ep.method} {ep.url}",
                evidence=last_evidence,
                remediation="Implement cooldown periods for resource lifecycle operations.",
            )

        if not vuln_found:
            self.add_result(
                "resource_lifecycle_abuse",
                TestStatus.PASS,
                "Resource lifecycle operations are controlled",
            )

    def _test_duplicate_creation(self):
        """Submit identical POST data twice to check for duplicate prevention."""
        token = self.get_token_a()
        creation_eps = self._get_creation_endpoints()

        if not creation_eps:
            self.add_result("duplicate_creation", TestStatus.SKIP, "No creation endpoints found")
            return

        vuln_found = False

        for ep in creation_eps:
            body = dict(ep.body) if ep.body and isinstance(ep.body, dict) else {}
            if not body:
                body = {"name": "duplicate_test_resource", "data": "test"}

            ev1 = self.make_request(ep, token=token, override_body=body)
            ev2 = self.make_request(ep, token=token, override_body=body)

            if self.is_real_success(ev1) and self.is_real_success(ev2):
                vuln_found = True
                self.add_result(
                    "duplicate_creation",
                    TestStatus.FAIL,
                    f"Duplicate creation allowed on {ep.method} {ep.url}",
                    endpoint_name=ep.full_name,
                    evidence=ev2,
                )
                self.log_finding(
                    severity=Severity.LOW,
                    title=f"Duplicate resource creation allowed: {ep.url}",
                    description=(
                        f"Identical POST requests both returned success on "
                        f"{ep.method} {ep.url}. Expected 409 Conflict on second request."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=ev2,
                    remediation="Implement idempotency keys or unique constraints to prevent duplicate creation.",
                )

        if not vuln_found:
            self.add_result(
                "duplicate_creation",
                TestStatus.PASS,
                "Duplicate creation properly prevented",
            )

    def _test_business_logic(self):
        """Send invalid business logic values (negative, empty, boundary)."""
        token = self.get_token_a()
        post_eps = [ep for ep in self.endpoints if ep.method.upper() in ("POST", "PUT") and ep.body]

        if not post_eps:
            self.add_result("business_logic_validation", TestStatus.SKIP, "No POST/PUT endpoints with body")
            return

        invalid_values = [
            ("negative_number", -1),
            ("zero", 0),
            ("large_number", 999999999),
            ("empty_string", ""),
            ("whitespace_only", "   "),
        ]

        vuln_found = False

        for ep in post_eps[:5]:
            if not isinstance(ep.body, dict):
                continue

            for val_name, val in invalid_values:
                modified_body = dict(ep.body)
                modified = False

                for field in modified_body:
                    if isinstance(modified_body[field], (int, float)):
                        modified_body[field] = val if isinstance(val, (int, float)) else -1
                        modified = True
                    elif isinstance(modified_body[field], str) and isinstance(val, str):
                        modified_body[field] = val
                        modified = True

                if not modified:
                    continue

                evidence = self.make_request(ep, token=token, override_body=modified_body)

                if self.is_real_success(evidence):
                    vuln_found = True
                    self.add_result(
                        "business_logic_validation",
                        TestStatus.FAIL,
                        f"Invalid data accepted ({val_name}): {ep.method} {ep.url}",
                        endpoint_name=ep.full_name,
                        evidence=evidence,
                    )
                    self.log_finding(
                        severity=Severity.LOW,
                        title=f"Weak business logic validation: {ep.url}",
                        description=(
                            f"Invalid data ({val_name}: {val!r}) was accepted "
                            f"by {ep.method} {ep.url}."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Validate all input against business rules. Reject negative quantities, empty required fields, etc.",
                    )
                    break

        if not vuln_found:
            self.add_result(
                "business_logic_validation",
                TestStatus.PASS,
                "Business logic validation is enforced",
            )

    def _test_workflow_bypass(self):
        """Try to access protected endpoints without completing prerequisite steps."""
        token = self.get_token_a()

        protected_keywords = ["checkout", "confirm", "verify", "finalize", "approve", "submit", "complete"]
        protected_eps = []

        for ep in self.endpoints:
            name_lower = (ep.full_name or ep.name or ep.url).lower()
            if any(kw in name_lower for kw in protected_keywords):
                protected_eps.append(ep)

        if not protected_eps:
            protected_eps = [ep for ep in self.endpoints if ep.method.upper() in ("PUT", "DELETE")][:3]

        if not protected_eps:
            self.add_result("workflow_bypass", TestStatus.SKIP, "No workflow-dependent endpoints found")
            return

        vuln_found = False

        for ep in protected_eps:
            evidence = self.make_request(ep, token=token)

            if self.is_real_success(evidence):
                vuln_found = True
                self.add_result(
                    "workflow_bypass",
                    TestStatus.FAIL,
                    f"Workflow bypass: {ep.method} {ep.url} accessible without prerequisites",
                    endpoint_name=ep.full_name,
                    evidence=evidence,
                )
                self.log_finding(
                    severity=Severity.MEDIUM,
                    title=f"Potential workflow bypass: {ep.url}",
                    description=(
                        f"{ep.method} {ep.url} returned success without completing "
                        f"prerequisite workflow steps."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Enforce workflow state validation. Require prerequisite steps before allowing progression.",
                )

        if not vuln_found:
            self.add_result(
                "workflow_bypass",
                TestStatus.PASS,
                "Workflow-dependent endpoints enforce prerequisites",
            )
