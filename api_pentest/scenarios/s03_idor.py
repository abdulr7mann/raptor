import logging
import re
import time

from api_pentest.core.api_discovery import ArchitectureType
from api_pentest.core.models import ScenarioApplicability, Severity, TestStatus
from api_pentest.scenarios.base_scenario import BaseScenario

logger = logging.getLogger(__name__)


class S03IDOR(BaseScenario):
    """S03 - Insecure Direct Object Reference (IDOR) detection."""

    SCENARIO_ID = "S03"
    SCENARIO_NAME = "Insecure Direct Object Reference"
    OWASP_ID = "API1:2023"
    OWASP_NAME = "Broken Object Level Authorization"
    APPLICABILITY = ScenarioApplicability(
        architectures=[ArchitectureType.REST, ArchitectureType.HYBRID, ArchitectureType.UNKNOWN],
        classifications=["protected"],  # Only authenticated endpoints
    )

    # Pattern to find IDs (numeric, UUID, MongoDB ObjectId, or string usernames) in URLs
    ID_PATTERNS = [
        (re.compile(r'/(\d{1,10})(?:/|$|\?)'), "numeric"),
        (re.compile(r'/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:/|$|\?)', re.I), "uuid"),
        (re.compile(r'/([0-9a-f]{24})(?:/|$|\?)', re.I), "mongodb"),
        (re.compile(r'[?&]id=(\d+)'), "query_numeric"),
        (re.compile(r'[?&]id=([0-9a-f-]{36})', re.I), "query_uuid"),
        (re.compile(r'[?&]username=([a-zA-Z0-9_-]+)', re.I), "query_username"),
    ]

    # Static path segments to ignore when detecting string usernames
    STATIC_SEGMENTS = {
        "api", "v1", "v2", "v3", "v4", "users", "books", "posts", "comments",
        "auth", "login", "logout", "register", "admin", "public", "private",
        "internal", "external", "health", "status", "metrics", "docs", "swagger",
        "password", "email", "profile", "settings", "account", "debug",
    }

    # Password-related endpoint patterns
    PASSWORD_ENDPOINT_PATTERNS = re.compile(
        r"(password|passwd|pwd|change-password|reset-password|update-password)",
        re.IGNORECASE,
    )

    def get_test_cases(self) -> list[str]:
        cases = ["id_enumeration", "path_username_idor"]
        if self.oauth and self.oauth_b:
            cases.append("cross_user_idor")
        cases.extend(["id_in_body", "unauthorized_password_change"])
        return cases

    def execute_test(self, test_name: str):
        if test_name == "id_enumeration":
            self._test_id_enumeration()
        elif test_name == "path_username_idor":
            self._test_path_username_idor()
        elif test_name == "cross_user_idor":
            self._test_cross_user_idor()
        elif test_name == "id_in_body":
            self._test_id_in_body()
        elif test_name == "unauthorized_password_change":
            self._test_unauthorized_password_change()

    def _find_ids_in_url(self, url: str) -> list[tuple[str, str, str]]:
        """Find IDs in a URL. Returns [(match_value, id_type, full_pattern_match)]."""
        found = []
        for pattern, id_type in self.ID_PATTERNS:
            for match in pattern.finditer(url):
                found.append((match.group(1), id_type, match.group(0)))
        return found

    def _modify_id(self, original: str, id_type: str) -> list[str]:
        """Generate modified IDs for testing."""
        modified = []

        if id_type in ("numeric", "query_numeric"):
            try:
                num = int(original)
                modified.extend([str(num + 1), str(num - 1), str(num + 100), "0", "999999"])
            except ValueError:
                modified.append("1")
        elif id_type in ("uuid", "query_uuid"):
            # Modify last character of UUID
            if len(original) > 1:
                last_char = original[-1]
                new_char = "a" if last_char != "a" else "b"
                modified.append(original[:-1] + new_char)
            modified.append("00000000-0000-0000-0000-000000000000")

        return modified

    def _test_id_enumeration(self):
        """Test IDOR by modifying IDs in URLs."""
        token = self.get_token_a()
        idor_found = False
        tested = 0

        for ep in self.endpoints:
            ids_found = self._find_ids_in_url(ep.url)
            if not ids_found:
                continue

            # Baseline request
            baseline = self.make_request(ep, token=token)
            if not self.is_success_status(baseline.response_status):
                continue

            for original_id, id_type, pattern_match in ids_found:
                modified_ids = self._modify_id(original_id, id_type)

                for new_id in modified_ids:
                    modified_url = ep.url.replace(original_id, new_id, 1)
                    evidence = self.make_request(
                        ep, token=token, override_url=modified_url
                    )
                    tested += 1

                    if self.is_success_status(evidence.response_status):
                        # Compare response to see if different data is returned
                        if evidence.response_body != baseline.response_body:
                            idor_found = True
                            self.add_result(
                                "id_enumeration",
                                TestStatus.FAIL,
                                f"IDOR: {ep.method} {modified_url} returned different data "
                                f"(ID {original_id} -> {new_id})",
                                endpoint_name=ep.full_name,
                                evidence=evidence,
                            )
                            self.log_finding(
                                severity=Severity.HIGH,
                                title=f"IDOR via ID enumeration on {ep.method} {ep.url}",
                                description=(
                                    f"Changing {id_type} ID from '{original_id}' to '{new_id}' "
                                    f"returned a successful response with different data."
                                ),
                                endpoint=f"{ep.method} {ep.url}",
                                evidence=evidence,
                                remediation=(
                                    "Implement object-level authorization checks. "
                                    "Verify the authenticated user has permission to access the requested resource."
                                ),
                            )

        if not idor_found:
            self.add_result(
                "id_enumeration",
                TestStatus.PASS,
                f"No IDOR found via ID enumeration ({tested} variations tested)",
            )

    def _test_cross_user_idor(self):
        """Test if User A can access User B's resources by swapping tokens."""
        token_a = self.get_token_a()
        token_b = self.get_token_b()

        if not token_a or not token_b:
            self.add_result("cross_user_idor", TestStatus.SKIP, "Need both User A and B tokens")
            return

        idor_found = False
        tested = 0

        for ep in self.endpoints:
            ids_found = self._find_ids_in_url(ep.url)
            if not ids_found:
                continue

            # First, get User B's response (to get IDs from their context)
            response_b = self.make_request(ep, token=token_b)
            if not self.is_success_status(response_b.response_status):
                continue

            # Try accessing same endpoint with User A's token
            evidence = self.make_request(ep, token=token_a)
            tested += 1

            if self.is_success_status(evidence.response_status):
                # If User A gets a success response with the same data as User B
                if evidence.response_body and response_b.response_body:
                    idor_found = True
                    self.add_result(
                        "cross_user_idor",
                        TestStatus.FAIL,
                        f"Cross-user IDOR: User A accessed {ep.method} {ep.url} with User B's resource ID",
                        endpoint_name=ep.full_name,
                        evidence=evidence,
                    )
                    self.log_finding(
                        severity=Severity.CRITICAL,
                        title=f"Cross-user IDOR on {ep.method} {ep.url}",
                        description=(
                            "User A was able to access resources belonging to User B "
                            "by using User A's authentication token with User B's resource identifiers."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation=(
                            "Implement object-level authorization. Check that the authenticated user "
                            "owns or has permission to access the requested object."
                        ),
                    )

        if not idor_found:
            self.add_result(
                "cross_user_idor",
                TestStatus.PASS,
                f"No cross-user IDOR detected ({tested} endpoints tested)",
            )

    def _test_id_in_body(self):
        """Test IDOR by modifying IDs in request bodies."""
        token = self.get_token_a()
        idor_found = False
        tested = 0

        id_fields = ["id", "user_id", "userId", "account_id", "accountId", "owner_id", "ownerId"]

        for ep in self.endpoints:
            if not ep.body or not isinstance(ep.body, dict):
                continue

            for field in id_fields:
                if field not in ep.body:
                    continue

                original_value = ep.body[field]

                # Try modified values
                test_values = []
                if isinstance(original_value, int):
                    test_values = [original_value + 1, original_value - 1, 0, 999999]
                elif isinstance(original_value, str):
                    if original_value.isdigit():
                        num = int(original_value)
                        test_values = [str(num + 1), str(num - 1), "0"]
                    else:
                        test_values = ["test_idor_id", "00000000-0000-0000-0000-000000000000"]

                for test_val in test_values:
                    modified_body = dict(ep.body)
                    modified_body[field] = test_val

                    evidence = self.make_request(ep, token=token, override_body=modified_body)
                    tested += 1

                    if self.is_success_status(evidence.response_status):
                        idor_found = True
                        self.add_result(
                            "id_in_body",
                            TestStatus.FAIL,
                            f"IDOR in body: {ep.method} {ep.url} accepted modified '{field}' = {test_val}",
                            endpoint_name=ep.full_name,
                            evidence=evidence,
                        )
                        self.log_finding(
                            severity=Severity.HIGH,
                            title=f"IDOR via body parameter '{field}' on {ep.method} {ep.url}",
                            description=(
                                f"Modifying the '{field}' field in the request body from "
                                f"'{original_value}' to '{test_val}' returned a successful response."
                            ),
                            endpoint=f"{ep.method} {ep.url}",
                            evidence=evidence,
                            remediation="Validate that body-level resource IDs match the authenticated user's permissions.",
                        )
                        break  # Move to next endpoint
                if idor_found:
                    break

        if not idor_found:
            self.add_result(
                "id_in_body",
                TestStatus.PASS,
                f"No IDOR found via body parameter manipulation ({tested} variations tested)",
            )

    def _test_path_username_idor(self):
        """Test IDOR via string-based path parameters like /users/v1/{username}.

        Many APIs use string usernames in paths instead of numeric IDs.
        This test detects them and tries to access other users' resources.
        """
        token = self.get_token_a()
        idor_found = False
        tested = 0

        # Test usernames to try when we find a username-like path segment
        test_usernames = [
            "admin", "administrator", "root", "user", "test",
            "demo", "guest", "operator", "system", "api",
        ]

        for ep in self.endpoints:
            # Find string-based path parameters that look like usernames
            username_segments = self._find_username_in_path(ep.url)
            if not username_segments:
                continue

            # Baseline request with original username
            baseline = self.make_request(ep, token=token)
            if not self.is_success_status(baseline.response_status):
                continue

            for idx, original_username in username_segments:
                for test_username in test_usernames:
                    if test_username.lower() == original_username.lower():
                        continue

                    modified_url = self.inject_into_path(ep.url, idx, test_username)
                    evidence = self.make_request(ep, token=token, override_url=modified_url)
                    tested += 1

                    if self.is_success_status(evidence.response_status):
                        # Different data returned indicates IDOR
                        if evidence.response_body and evidence.response_body != baseline.response_body:
                            idor_found = True
                            self.add_result(
                                "path_username_idor",
                                TestStatus.FAIL,
                                f"IDOR: {ep.method} {ep.url} - accessed user '{test_username}' "
                                f"(was '{original_username}')",
                                endpoint_name=ep.full_name,
                                evidence=evidence,
                            )
                            self.log_finding(
                                severity=Severity.HIGH,
                                title=f"IDOR via path username on {ep.method} {ep.url}",
                                description=(
                                    f"Changing username in path from '{original_username}' "
                                    f"to '{test_username}' returned different user's data."
                                ),
                                endpoint=f"{ep.method} {ep.url}",
                                evidence=evidence,
                                remediation=(
                                    "Verify the authenticated user has permission to access "
                                    "resources for the requested username. Use session-based "
                                    "user identification instead of path parameters."
                                ),
                            )
                            break
                if idor_found:
                    break

        if not idor_found:
            self.add_result(
                "path_username_idor",
                TestStatus.PASS,
                f"No IDOR found via path username manipulation ({tested} variations tested)",
            )

    def _find_username_in_path(self, url: str) -> list[tuple[int, str]]:
        """Find likely username segments in URL path.

        Returns list of (segment_index, username) for segments that look
        like usernames (not static paths like 'api', 'v1', 'users').
        """
        from urllib.parse import urlparse

        parsed = urlparse(url)
        segments = [s for s in parsed.path.split("/") if s]
        username_segments = []

        for idx, segment in enumerate(segments):
            # Skip known static segments
            if segment.lower() in self.STATIC_SEGMENTS:
                continue

            # Skip if it matches ID patterns (numeric, UUID, MongoDB)
            if re.match(r'^\d+$', segment):
                continue
            if re.match(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$', segment, re.I):
                continue
            if re.match(r'^[0-9a-f]{24}$', segment, re.I):
                continue

            # Looks like a username: alphanumeric with optional underscores/hyphens
            if re.match(r'^[a-zA-Z][a-zA-Z0-9_-]{1,30}$', segment):
                username_segments.append((idx, segment))

        return username_segments

    def _test_unauthorized_password_change(self):
        """Test if password can be changed for other users (BOLA on password endpoints).

        VAmPI-style vulnerability: PUT /users/v1/{username}/password allows
        changing any user's password if only username is checked, not ownership.
        """
        token = self.get_token_a()
        vuln_found = False
        tested = 0

        # Find password change endpoints
        password_endpoints = []
        for ep in self.endpoints:
            if ep.method.upper() not in ("PUT", "PATCH", "POST"):
                continue

            url_lower = ep.url.lower()
            name_lower = (ep.full_name or ep.name or "").lower()

            if self.PASSWORD_ENDPOINT_PATTERNS.search(url_lower) or \
               self.PASSWORD_ENDPOINT_PATTERNS.search(name_lower):
                password_endpoints.append(ep)

        if not password_endpoints:
            self.add_result(
                "unauthorized_password_change",
                TestStatus.SKIP,
                "No password change endpoints found",
            )
            return

        # Test usernames to try
        target_users = ["admin", "administrator", "root", "user1", "test"]

        for ep in password_endpoints:
            # Check if endpoint has username in path
            username_segments = self._find_username_in_path(ep.url)

            if username_segments:
                # Try changing password for other usernames via path
                for idx, original_username in username_segments:
                    for target_user in target_users:
                        if target_user.lower() == original_username.lower():
                            continue

                        modified_url = self.inject_into_path(ep.url, idx, target_user)

                        # Create password change body
                        body = self._make_password_body(ep)

                        evidence = self.make_request(
                            ep, token=token, override_url=modified_url, override_body=body
                        )
                        tested += 1

                        if self.is_success_status(evidence.response_status):
                            vuln_found = True
                            self.add_result(
                                "unauthorized_password_change",
                                TestStatus.FAIL,
                                f"Unauthorized password change: {ep.method} {modified_url} "
                                f"changed password for '{target_user}'",
                                endpoint_name=ep.full_name,
                                evidence=evidence,
                            )
                            self.log_finding(
                                severity=Severity.CRITICAL,
                                title=f"Unauthorized Password Change on {ep.method} {ep.url}",
                                description=(
                                    f"User A was able to change the password for user '{target_user}' "
                                    f"by modifying the username in the URL path. This is a critical "
                                    "BOLA vulnerability allowing account takeover."
                                ),
                                endpoint=f"{ep.method} {ep.url}",
                                evidence=evidence,
                                remediation=(
                                    "Verify the authenticated user owns the account before "
                                    "allowing password changes. Use session-based user "
                                    "identification, not path parameters."
                                ),
                            )
                            break
                    if vuln_found:
                        break
            else:
                # No username in path, try username in body
                body = self._make_password_body(ep)

                for target_user in target_users:
                    # Add username to body
                    body_with_user = dict(body)
                    for field in ["username", "user", "email", "user_id"]:
                        if field in body_with_user or field in (ep.body or {}):
                            body_with_user[field] = target_user
                            break
                    else:
                        body_with_user["username"] = target_user

                    evidence = self.make_request(ep, token=token, override_body=body_with_user)
                    tested += 1

                    if self.is_success_status(evidence.response_status):
                        vuln_found = True
                        self.add_result(
                            "unauthorized_password_change",
                            TestStatus.FAIL,
                            f"Unauthorized password change: {ep.method} {ep.url} "
                            f"accepted username '{target_user}' in body",
                            endpoint_name=ep.full_name,
                            evidence=evidence,
                        )
                        self.log_finding(
                            severity=Severity.CRITICAL,
                            title=f"Unauthorized Password Change on {ep.method} {ep.url}",
                            description=(
                                f"User A was able to change the password for user '{target_user}' "
                                f"by specifying the target username in the request body."
                            ),
                            endpoint=f"{ep.method} {ep.url}",
                            evidence=evidence,
                            remediation=(
                                "Only allow password changes for the authenticated user. "
                                "Ignore username in request body; use the authenticated identity."
                            ),
                        )
                        break

            if vuln_found:
                break

        if not vuln_found:
            self.add_result(
                "unauthorized_password_change",
                TestStatus.PASS,
                f"No unauthorized password change detected ({tested} attempts)",
            )

    def _make_password_body(self, ep) -> dict:
        """Create a password change request body."""
        body = dict(ep.body) if ep.body and isinstance(ep.body, dict) else {}

        # Ensure we have password field
        password_fields = ["password", "new_password", "newPassword", "passwd"]
        has_password = any(f in body for f in password_fields)

        if not has_password:
            body["password"] = "NewP@ssw0rd123!"

        return body
