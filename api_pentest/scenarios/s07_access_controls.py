import logging

from api_pentest.core.models import Severity, TestStatus
from api_pentest.core.oauth2_handler import OAuth2Handler
from api_pentest.core.prerequisite_detector import DetectionStatus
from api_pentest.scenarios.base_scenario import BaseScenario

logger = logging.getLogger(__name__)


class S07AccessControls(BaseScenario):
    """S07 - Improper Access Controls testing."""

    SCENARIO_ID = "S07"
    SCENARIO_NAME = "Improper Access Controls"
    OWASP_ID = "API5:2023"
    OWASP_NAME = "Broken Function Level Authorization"

    DEBUG_PATHS = [
        "/debug", "/debug/vars", "/debug/pprof",
        "/_debug", "/__debug__",
        "/admin", "/admin/", "/admin/login",
        "/swagger", "/swagger/", "/swagger-ui", "/swagger-ui.html",
        "/api-docs", "/openapi.json", "/openapi.yaml",
        "/graphql", "/graphiql",
        "/actuator", "/actuator/health", "/actuator/env", "/actuator/beans",
        "/metrics", "/prometheus/metrics",
        "/health", "/healthz", "/readyz",
        "/status", "/info", "/env",
        "/.env", "/config", "/phpinfo.php",
        "/server-status", "/server-info",
        "/trace", "/dump",
    ]

    UNDOCUMENTED_METHODS = ["PUT", "DELETE", "PATCH", "OPTIONS", "TRACE"]

    def get_test_cases(self) -> list[str]:
        return [
            "no_auth_access",
            "malformed_token_access",
            "undocumented_methods",
            "cors_misconfiguration",
            "debug_endpoint_probing",
        ]

    def execute_test(self, test_name: str):
        if test_name == "no_auth_access":
            self._test_no_auth_access()
        elif test_name == "malformed_token_access":
            self._test_malformed_token_access()
        elif test_name == "undocumented_methods":
            self._test_undocumented_methods()
        elif test_name == "cors_misconfiguration":
            self._test_cors_misconfiguration()
        elif test_name == "debug_endpoint_probing":
            self._test_debug_endpoints()

    def _test_no_auth_access(self):
        """Test endpoints without any authentication header."""
        accessible = 0
        tested = 0

        for ep in self.endpoints:
            # Skip public endpoints -- no auth expected
            if self.is_public_endpoint(ep):
                logger.debug(
                    "Skipping no-auth test for %s %s: %s",
                    ep.method, ep.url, ep.classification_reason,
                )
                continue

            evidence = self.make_request(ep, token=None)
            tested += 1

            if self.is_success_status(evidence.response_status):
                accessible += 1
                self.add_result(
                    "no_auth_access",
                    TestStatus.FAIL,
                    f"No-auth access: {ep.method} {ep.url} (HTTP {evidence.response_status})",
                    endpoint_name=ep.full_name,
                    evidence=evidence,
                )
                self.log_finding(
                    severity=Severity.HIGH,
                    title=f"Endpoint accessible without authentication",
                    description=(
                        f"{ep.method} {ep.url} returned HTTP {evidence.response_status} "
                        "without any Authorization header."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Require authentication for all non-public endpoints.",
                )

        if accessible == 0:
            self.add_result(
                "no_auth_access",
                TestStatus.PASS,
                f"All {tested} endpoints require authentication",
            )
        else:
            self.add_result(
                "no_auth_access",
                TestStatus.FAIL,
                f"{accessible}/{tested} endpoints accessible without auth",
            )

    def _test_malformed_token_access(self):
        """Test endpoints with malformed/invalid tokens."""
        malformed = OAuth2Handler.malformed_tokens()
        accessible_any = False
        tested = 0

        # Test a subset of non-public endpoints
        test_eps = [ep for ep in self.endpoints if not self.is_public_endpoint(ep)][:5]

        for ep in test_eps:
            for bad_token in malformed:
                auth_value = bad_token if bad_token.startswith("Bearer") or bad_token.startswith("Basic") else f"Bearer {bad_token}" if bad_token else ""

                evidence = self.make_request(
                    ep,
                    auth_header_raw=auth_value if auth_value else None,
                )
                tested += 1

                if self.is_success_status(evidence.response_status):
                    accessible_any = True
                    self.add_result(
                        "malformed_token_access",
                        TestStatus.FAIL,
                        f"Malformed token accepted: '{bad_token[:30]}...' at {ep.method} {ep.url}",
                        endpoint_name=ep.full_name,
                        evidence=evidence,
                    )
                    self.log_finding(
                        severity=Severity.HIGH,
                        title="Malformed token accepted",
                        description=(
                            f"The token '{bad_token[:50]}' was accepted by "
                            f"{ep.method} {ep.url}."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Validate token format before processing. Reject empty/malformed tokens.",
                    )
                    break

        if not accessible_any:
            self.add_result(
                "malformed_token_access",
                TestStatus.PASS,
                f"All malformed tokens properly rejected ({tested} tested)",
            )

    def _test_undocumented_methods(self):
        """Test if undocumented HTTP methods are accepted."""
        token = self.get_token_a()
        found = False
        tested = 0

        for ep in self.endpoints[:10]:
            documented_method = ep.method.upper()

            for method in self.UNDOCUMENTED_METHODS:
                if method == documented_method:
                    continue

                evidence = self.make_request(
                    ep, token=token, override_method=method
                )
                tested += 1

                if self.is_success_status(evidence.response_status):
                    found = True
                    self.add_result(
                        "undocumented_methods",
                        TestStatus.FAIL,
                        f"Undocumented {method} accepted at {ep.url} (documented: {documented_method})",
                        endpoint_name=ep.full_name,
                        evidence=evidence,
                    )
                    self.log_finding(
                        severity=Severity.MEDIUM,
                        title=f"Undocumented HTTP method {method} accepted",
                        description=(
                            f"{method} method returned HTTP {evidence.response_status} "
                            f"at {ep.url} (only {documented_method} is documented)."
                        ),
                        endpoint=f"{method} {ep.url}",
                        evidence=evidence,
                        remediation="Restrict allowed HTTP methods per endpoint. Return 405 for unsupported methods.",
                    )

        if not found:
            self.add_result(
                "undocumented_methods",
                TestStatus.PASS,
                f"No undocumented methods accepted ({tested} tested)",
            )

    def _test_cors_misconfiguration(self):
        """Test for CORS misconfigurations."""
        # Check if CORS is configured before testing bypass
        cors_prereq = self.get_prerequisite("cors")
        if cors_prereq and cors_prereq.status == DetectionStatus.ABSENT:
            self.add_skip_result(
                test_name="cors_misconfiguration",
                reason=cors_prereq.reason,
                control="cors",
            )
            return

        token = self.get_token_a()
        misconfig_found = False

        evil_origins = [
            "https://evil.com",
            "https://attacker.example.com",
            "null",
        ]

        for ep in self.endpoints[:5]:
            for origin in evil_origins:
                evidence = self.make_request(
                    ep,
                    token=token,
                    override_headers={"Origin": origin},
                )

                acao = evidence.response_headers.get(
                    "Access-Control-Allow-Origin",
                    evidence.response_headers.get("access-control-allow-origin", ""),
                )
                acac = evidence.response_headers.get(
                    "Access-Control-Allow-Credentials",
                    evidence.response_headers.get("access-control-allow-credentials", ""),
                )

                if acao == "*":
                    misconfig_found = True
                    self.log_finding(
                        severity=Severity.MEDIUM,
                        title="CORS wildcard origin",
                        description=(
                            f"{ep.method} {ep.url} returns Access-Control-Allow-Origin: * "
                            "which allows any website to read responses."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Restrict CORS to specific trusted origins.",
                    )
                elif acao == origin and origin != "null":
                    misconfig_found = True
                    severity = Severity.HIGH if acac.lower() == "true" else Severity.MEDIUM
                    self.log_finding(
                        severity=severity,
                        title=f"CORS reflects arbitrary origin: {origin}",
                        description=(
                            f"{ep.method} {ep.url} reflects the attacker-controlled origin "
                            f"'{origin}' in Access-Control-Allow-Origin"
                            + (" with credentials" if acac.lower() == "true" else "")
                            + "."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Validate Origin header against a whitelist. Never reflect arbitrary origins.",
                    )
                elif acao == "null":
                    misconfig_found = True
                    self.log_finding(
                        severity=Severity.MEDIUM,
                        title="CORS allows null origin",
                        description=(
                            f"{ep.method} {ep.url} accepts 'null' origin, which can be "
                            "triggered from sandboxed iframes."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Do not allow 'null' as a valid origin.",
                    )

        status = TestStatus.FAIL if misconfig_found else TestStatus.PASS
        self.add_result(
            "cors_misconfiguration",
            status,
            "CORS misconfiguration " + ("detected" if misconfig_found else "not detected"),
        )

    def _test_debug_endpoints(self):
        """Probe for debug/internal/admin endpoints."""
        token = self.get_token_a()

        # Extract base URLs from endpoints
        base_urls = set()
        for ep in self.endpoints:
            from urllib.parse import urlparse
            parsed = urlparse(ep.url)
            base_urls.add(f"{parsed.scheme}://{parsed.netloc}")

        if not base_urls:
            self.add_result("debug_endpoint_probing", TestStatus.SKIP, "No base URLs")
            return

        found = []
        tested = 0

        for base_url in base_urls:
            for path in self.DEBUG_PATHS:
                url = f"{base_url}{path}"
                evidence = self.make_request(
                    self.endpoints[0],
                    token=token,
                    override_url=url,
                    override_method="GET",
                )
                tested += 1

                if evidence.response_status in range(200, 400) and evidence.response_status != 404:
                    found.append((url, evidence.response_status))
                    self.log_finding(
                        severity=Severity.MEDIUM if evidence.response_status < 300 else Severity.LOW,
                        title=f"Debug/internal endpoint discovered: {path}",
                        description=(
                            f"GET {url} returned HTTP {evidence.response_status}. "
                            "This may expose internal information."
                        ),
                        endpoint=f"GET {url}",
                        evidence=evidence,
                        remediation="Remove or restrict access to debug/internal endpoints in production.",
                    )

        if found:
            self.add_result(
                "debug_endpoint_probing",
                TestStatus.FAIL,
                f"Found {len(found)} debug/internal endpoints ({tested} probed)",
            )
        else:
            self.add_result(
                "debug_endpoint_probing",
                TestStatus.PASS,
                f"No debug/internal endpoints found ({tested} probed)",
            )
