import logging
import re
from urllib.parse import urlparse

from api_pentest.core.models import ScenarioApplicability, Severity, TestStatus
from api_pentest.scenarios.base_scenario import BaseScenario

logger = logging.getLogger(__name__)


class S12InventoryManagement(BaseScenario):
    """S12 - Improper Inventory Management testing."""

    SCENARIO_ID = "S12"
    SCENARIO_NAME = "Improper Inventory Management"
    OWASP_ID = "API9:2023"
    OWASP_NAME = "Improper Inventory Management"
    APPLICABILITY = ScenarioApplicability()  # Inventory issues affect all APIs

    VERSION_PATTERNS = ["/v0/", "/v2/", "/v3/", "/v4/"]
    VERSIONLESS_PATTERNS = [""]  # Try removing version segment

    SHADOW_PATHS = [
        "/admin", "/admin/", "/admin/users", "/admin/config",
        "/internal", "/internal/", "/internal/status",
        "/backup", "/backup/", "/backups",
        "/export", "/export/data", "/import",
        "/console", "/console/",
        "/dashboard", "/dashboard/",
        "/test", "/testing", "/dev", "/development",
        "/staging", "/stage",
        "/api", "/api/v1", "/api/v2",
        "/private", "/secret", "/hidden",
        "/system", "/system/info",
        "/management", "/manage",
        "/config", "/configuration",
        "/setup", "/install",
    ]

    DOC_PATHS = [
        "/swagger", "/swagger/", "/swagger.json", "/swagger.yaml",
        "/swagger-ui", "/swagger-ui.html", "/swagger-ui/",
        "/openapi.json", "/openapi.yaml", "/openapi/",
        "/api-docs", "/api-docs/", "/api-docs.json",
        "/redoc", "/redoc/",
        "/docs", "/docs/", "/documentation",
        "/graphql", "/graphiql", "/graphql/playground",
        "/explorer", "/api-explorer",
        "/.well-known/openapi", "/.well-known/security.txt",
    ]

    TRAVERSAL_PAYLOADS = [
        "/../admin",
        "/./admin",
        "/%2e%2e/admin",
        "/%2e%2e%2fadmin",
        "/..%2fadmin",
        "/..;/admin",
        "/%252e%252e/admin",
    ]

    ALL_HTTP_METHODS = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]

    def get_test_cases(self) -> list[str]:
        return [
            "api_version_enumeration",
            "shadow_endpoint_discovery",
            "documentation_exposure",
            "deprecated_endpoint_access",
            "content_type_negotiation",
            "path_traversal_probing",
        ]

    def execute_test(self, test_name: str):
        if test_name == "api_version_enumeration":
            self._test_version_enumeration()
        elif test_name == "shadow_endpoint_discovery":
            self._test_shadow_endpoints()
        elif test_name == "documentation_exposure":
            self._test_doc_exposure()
        elif test_name == "deprecated_endpoint_access":
            self._test_deprecated()
        elif test_name == "content_type_negotiation":
            self._test_content_negotiation()
        elif test_name == "path_traversal_probing":
            self._test_path_traversal()

    def _get_base_urls(self):
        """Extract unique base URLs from endpoints."""
        base_urls = set()
        for ep in self.endpoints:
            parsed = urlparse(ep.url)
            base_urls.add(f"{parsed.scheme}://{parsed.netloc}")
        return base_urls

    def _test_version_enumeration(self):
        """Probe for undocumented API versions."""
        token = self.get_token_a()
        found_versions = []

        # Find endpoints with version in path
        version_regex = re.compile(r'/v(\d+)/')
        versioned_eps = []

        for ep in self.endpoints:
            match = version_regex.search(ep.url)
            if match:
                versioned_eps.append((ep, match.group(0), match.group(1)))

        if not versioned_eps:
            self.add_result("api_version_enumeration", TestStatus.SKIP,
                            "No versioned endpoints found")
            return

        tested = set()

        for ep, version_segment, current_ver in versioned_eps[:5]:
            for alt_version in self.VERSION_PATTERNS:
                alt_url = ep.url.replace(version_segment, alt_version)
                if alt_url == ep.url or alt_url in tested:
                    continue
                tested.add(alt_url)

                evidence = self.make_request(
                    ep, token=token, override_url=alt_url,
                )

                if self.is_success_status(evidence.response_status):
                    body = str(evidence.response_body or "")
                    if len(body) > 10 and "not found" not in body.lower():
                        found_versions.append((alt_url, evidence))
                        self.log_finding(
                            severity=Severity.MEDIUM,
                            title=f"Undocumented API version accessible: {alt_version}",
                            description=(
                                f"Replacing version in {ep.url} with {alt_version} "
                                f"returned HTTP {evidence.response_status} at {alt_url}. "
                                "Undocumented API versions may lack security controls."
                            ),
                            endpoint=f"{ep.method} {alt_url}",
                            evidence=evidence,
                            remediation="Decommission old API versions. Ensure all versions are documented and secured.",
                        )

            # Try versionless
            versionless_url = version_regex.sub("/", ep.url)
            if versionless_url != ep.url and versionless_url not in tested:
                tested.add(versionless_url)
                evidence = self.make_request(ep, token=token, override_url=versionless_url)
                if self.is_success_status(evidence.response_status):
                    body = str(evidence.response_body or "")
                    if len(body) > 10 and "not found" not in body.lower():
                        found_versions.append((versionless_url, evidence))

        status = TestStatus.FAIL if found_versions else TestStatus.PASS
        self.add_result(
            "api_version_enumeration",
            status,
            f"Found {len(found_versions)} undocumented versions" if found_versions
            else f"No undocumented versions found ({len(tested)} tested)",
        )

    def _test_shadow_endpoints(self):
        """Probe for undocumented/shadow endpoints."""
        token = self.get_token_a()
        found = []
        tested = 0

        base_urls = self._get_base_urls()

        for base_url in base_urls:
            for path in self.SHADOW_PATHS:
                url = f"{base_url}{path}"
                tested += 1

                evidence = self.make_request(
                    self.endpoints[0], token=token,
                    override_url=url, override_method="GET",
                )

                if self.is_success_status(evidence.response_status):
                    body = str(evidence.response_body or "")
                    if len(body) > 20 and "not found" not in body.lower() and "<!doctype" not in body.lower()[:50]:
                        # Check it's not in our known endpoints
                        known_urls = {ep.url for ep in self.endpoints}
                        if url not in known_urls:
                            found.append((path, evidence.response_status, evidence))

                # Also try without auth
                evidence_noauth = self.make_request(
                    self.endpoints[0], token=None,
                    override_url=url, override_method="GET",
                )

                if self.is_success_status(evidence_noauth.response_status):
                    body = str(evidence_noauth.response_body or "")
                    if len(body) > 20 and "not found" not in body.lower():
                        known_urls = {ep.url for ep in self.endpoints}
                        if url not in known_urls and (path, evidence_noauth.response_status, evidence_noauth) not in found:
                            found.append((path, evidence_noauth.response_status, evidence_noauth))

        for path, status_code, evidence in found:
            self.log_finding(
                severity=Severity.MEDIUM,
                title=f"Shadow endpoint discovered: {path}",
                description=(
                    f"Undocumented endpoint '{path}' returned HTTP {status_code}. "
                    "This endpoint is not in the API specification."
                ),
                endpoint=f"GET {path}",
                evidence=evidence,
                remediation="Remove undocumented endpoints or add them to the API specification with proper security controls.",
            )

        status = TestStatus.FAIL if found else TestStatus.PASS
        self.add_result(
            "shadow_endpoint_discovery",
            status,
            f"Found {len(found)} shadow endpoints ({tested} probed)" if found
            else f"No shadow endpoints found ({tested} probed)",
        )

    def _test_doc_exposure(self):
        """Check for exposed API documentation endpoints."""
        token = self.get_token_a()
        exposed = []

        base_urls = self._get_base_urls()

        for base_url in base_urls:
            for path in self.DOC_PATHS:
                url = f"{base_url}{path}"

                # Test without auth (docs shouldn't need auth ideally, but exposure is the issue)
                evidence = self.make_request(
                    self.endpoints[0], token=None,
                    override_url=url, override_method="GET",
                )

                if evidence.response_status in range(200, 300):
                    body = str(evidence.response_body or "")
                    # Verify it's actual documentation content
                    doc_indicators = ["swagger", "openapi", "paths", "schemas", "graphql",
                                      "query", "mutation", "api", "endpoint"]
                    if any(ind in body.lower() for ind in doc_indicators) and len(body) > 50:
                        exposed.append((path, evidence))

        for path, evidence in exposed:
            self.log_finding(
                severity=Severity.MEDIUM,
                title=f"API documentation exposed: {path}",
                description=(
                    f"API documentation is publicly accessible at {path} without authentication. "
                    "This reveals endpoint structure, parameters, and schemas to attackers."
                ),
                endpoint=f"GET {path}",
                evidence=evidence,
                remediation="Restrict API documentation access in production. Require authentication or IP whitelisting.",
            )

        status = TestStatus.FAIL if exposed else TestStatus.PASS
        self.add_result(
            "documentation_exposure",
            status,
            f"Found {len(exposed)} exposed doc endpoints" if exposed
            else "No documentation exposure detected",
        )

    def _test_deprecated(self):
        """Check if deprecated endpoints (from spec) are still active."""
        token = self.get_token_a()
        deprecated_eps = [ep for ep in self.endpoints if "deprecated" in ep.tags]

        if not deprecated_eps:
            self.add_result("deprecated_endpoint_access", TestStatus.SKIP,
                            "No deprecated endpoints in spec")
            return

        active_deprecated = []

        for ep in deprecated_eps:
            evidence = self.make_request(ep, token=token)

            if self.is_success_status(evidence.response_status):
                active_deprecated.append((ep, evidence))
                self.log_finding(
                    severity=Severity.LOW,
                    title=f"Deprecated endpoint still active: {ep.name}",
                    description=(
                        f"Deprecated endpoint {ep.method} {ep.url} still responds with "
                        f"HTTP {evidence.response_status}. Deprecated endpoints may lack "
                        "current security patches."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Decommission deprecated endpoints or ensure they have current security controls.",
                )

        status = TestStatus.FAIL if active_deprecated else TestStatus.PASS
        self.add_result(
            "deprecated_endpoint_access",
            status,
            f"{len(active_deprecated)}/{len(deprecated_eps)} deprecated endpoints still active",
        )

    def _test_content_negotiation(self):
        """Test if undocumented content types are accepted."""
        token = self.get_token_a()
        alt_types_accepted = []

        alt_content_types = [
            "application/xml",
            "text/yaml",
            "text/csv",
            "application/x-www-form-urlencoded",
        ]

        alt_accept_types = [
            "application/xml",
            "text/yaml",
            "text/csv",
        ]

        for ep in self.endpoints[:5]:
            for accept_type in alt_accept_types:
                evidence = self.make_request(
                    ep, token=token,
                    override_headers={"Accept": accept_type},
                )

                content_type = ""
                for key, value in evidence.response_headers.items():
                    if key.lower() == "content-type":
                        content_type = value.lower()
                        break

                if accept_type.split("/")[1] in content_type and self.is_success_status(evidence.response_status):
                    alt_types_accepted.append((ep.url, accept_type, evidence))

        for url, content_type, evidence in alt_types_accepted:
            self.log_finding(
                severity=Severity.INFO,
                title=f"Undocumented content type supported: {content_type}",
                description=(
                    f"Endpoint {url} responds with {content_type} format when requested. "
                    "Undocumented content types may have different security handling."
                ),
                endpoint=url,
                evidence=evidence,
                remediation="Document all supported content types. Ensure consistent security across formats.",
            )

        self.add_result(
            "content_type_negotiation",
            TestStatus.FAIL if alt_types_accepted else TestStatus.PASS,
            f"Found {len(alt_types_accepted)} undocumented content types" if alt_types_accepted
            else "Only documented content types accepted",
        )

    def _test_path_traversal(self):
        """Test for path traversal vulnerabilities in API routes."""
        token = self.get_token_a()
        traversal_found = False

        base_urls = self._get_base_urls()

        for base_url in base_urls:
            for payload in self.TRAVERSAL_PAYLOADS:
                url = f"{base_url}{payload}"

                evidence = self.make_request(
                    self.endpoints[0], token=token,
                    override_url=url, override_method="GET",
                )

                if self.is_success_status(evidence.response_status):
                    body = str(evidence.response_body or "")
                    sensitive_indicators = [
                        "root:", "/bin/", "passwd", "shadow",
                        "admin", "config", "secret", "private_key",
                    ]
                    if any(ind in body.lower() for ind in sensitive_indicators) and len(body) > 20:
                        traversal_found = True
                        self.log_finding(
                            severity=Severity.HIGH,
                            title=f"Path traversal successful: {payload}",
                            description=(
                                f"Path traversal payload '{payload}' at {url} returned "
                                f"sensitive content (HTTP {evidence.response_status})."
                            ),
                            endpoint=f"GET {url}",
                            evidence=evidence,
                            remediation="Sanitize path segments. Use allowlists for route parameters.",
                        )
                        break

        status = TestStatus.FAIL if traversal_found else TestStatus.PASS
        self.add_result(
            "path_traversal_probing",
            status,
            f"Path traversal {'successful' if traversal_found else 'blocked'}",
        )
