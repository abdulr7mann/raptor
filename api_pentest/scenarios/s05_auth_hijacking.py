import logging

from api_pentest.core.api_discovery import ArchitectureType
from api_pentest.core.models import ScenarioApplicability, Severity, TestStatus
from api_pentest.core.oauth2_handler import OAuth2Handler
from api_pentest.scenarios.base_scenario import BaseScenario

logger = logging.getLogger(__name__)


class S05AuthHijacking(BaseScenario):
    """S05 - Authentication Hijacking via JWT manipulation."""

    SCENARIO_ID = "S05"
    SCENARIO_NAME = "Authentication Hijacking"
    OWASP_ID = "API2:2023"
    OWASP_NAME = "Broken Authentication"
    APPLICABILITY = ScenarioApplicability(
        architectures=[ArchitectureType.REST, ArchitectureType.GRAPHQL, ArchitectureType.HYBRID],
        classifications=["protected", "auth-endpoint"],
    )

    def get_test_cases(self) -> list[str]:
        cases = []
        if self.oauth:
            cases.extend([
                "expired_jwt_acceptance",
                "tampered_signature",
                "alg_none_attack",
                "stripped_signature",
                "tampered_claims",
            ])
        return cases if cases else ["no_oauth_skip"]

    def execute_test(self, test_name: str):
        if test_name == "no_oauth_skip":
            self.add_result("no_oauth_skip", TestStatus.SKIP, "No OAuth configured")
            return
        if test_name == "expired_jwt_acceptance":
            self._test_expired_jwt()
        elif test_name == "tampered_signature":
            self._test_tampered_signature()
        elif test_name == "alg_none_attack":
            self._test_alg_none()
        elif test_name == "stripped_signature":
            self._test_stripped_signature()
        elif test_name == "tampered_claims":
            self._test_tampered_claims()

    def _test_expired_jwt(self):
        """Test if expired JWTs are still accepted."""
        token = self.get_token_a()
        if not token:
            self.add_result("expired_jwt_acceptance", TestStatus.SKIP, "No token")
            return

        expired_jwt = OAuth2Handler.force_expired(token)
        accepted_pairs = []
        tested = 0

        for ep in self.endpoints[:10]:
            evidence = self.make_request(
                ep, auth_header_raw=f"Bearer {expired_jwt}"
            )
            tested += 1
            if self.is_success_status(evidence.response_status):
                accepted_pairs.append((ep, evidence))

        if accepted_pairs:
            self.add_result(
                "expired_jwt_acceptance",
                TestStatus.FAIL,
                f"Expired JWT accepted by {len(accepted_pairs)}/{tested} endpoints",
            )
            for ep, evidence in accepted_pairs:
                self.log_finding(
                    severity=Severity.HIGH,
                    title="Expired JWT tokens accepted",
                    description=(
                        "A JWT with exp set to 24 hours in the past was "
                        "accepted at this endpoint."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Always validate JWT expiration (exp claim). Reject expired tokens.",
                )
        else:
            self.add_result(
                "expired_jwt_acceptance",
                TestStatus.PASS,
                f"Expired JWT properly rejected by all {tested} endpoints",
            )

    def _test_tampered_signature(self):
        """Test if tokens with corrupted signatures are accepted."""
        token = self.get_token_a()
        if not token:
            self.add_result("tampered_signature", TestStatus.SKIP, "No token")
            return

        tampered = OAuth2Handler.flip_signature(token)
        accepted_pairs = []
        tested = 0

        for ep in self.endpoints[:10]:
            evidence = self.make_request(
                ep, auth_header_raw=f"Bearer {tampered}"
            )
            tested += 1
            if self.is_success_status(evidence.response_status):
                accepted_pairs.append((ep, evidence))

        if accepted_pairs:
            self.add_result(
                "tampered_signature",
                TestStatus.FAIL,
                f"Tampered signature accepted by {len(accepted_pairs)}/{tested} endpoints",
            )
            for ep, evidence in accepted_pairs:
                self.log_finding(
                    severity=Severity.CRITICAL,
                    title="JWT signature verification bypassed",
                    description=(
                        "A JWT with corrupted signature bytes was accepted at this "
                        "endpoint. Signature verification may be disabled."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Always verify JWT signatures. Use a well-tested JWT library.",
                )
        else:
            self.add_result(
                "tampered_signature",
                TestStatus.PASS,
                f"Tampered signatures properly rejected by all {tested} endpoints",
            )

    def _test_alg_none(self):
        """Test the JWT alg:none attack."""
        token = self.get_token_a()
        if not token:
            self.add_result("alg_none_attack", TestStatus.SKIP, "No token")
            return

        none_jwt = OAuth2Handler.forge_alg_none(token)
        accepted_pairs = []
        tested = 0

        for ep in self.endpoints[:10]:
            evidence = self.make_request(
                ep, auth_header_raw=f"Bearer {none_jwt}"
            )
            tested += 1
            if self.is_success_status(evidence.response_status):
                accepted_pairs.append((ep, evidence))

        if accepted_pairs:
            self.add_result(
                "alg_none_attack",
                TestStatus.FAIL,
                f"alg:none JWT accepted by {len(accepted_pairs)}/{tested} endpoints",
            )
            for ep, evidence in accepted_pairs:
                self.log_finding(
                    severity=Severity.CRITICAL,
                    title="JWT alg:none attack successful",
                    description=(
                        "A JWT with algorithm set to 'none' and empty signature "
                        "was accepted at this endpoint."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation=(
                        "Explicitly reject alg:none tokens. Whitelist allowed algorithms. "
                        "Use a JWT library that does not accept 'none' by default."
                    ),
                )
        else:
            self.add_result(
                "alg_none_attack",
                TestStatus.PASS,
                f"alg:none JWT properly rejected by all {tested} endpoints",
            )

    def _test_stripped_signature(self):
        """Test if tokens with completely removed signatures are accepted."""
        token = self.get_token_a()
        if not token:
            self.add_result("stripped_signature", TestStatus.SKIP, "No token")
            return

        stripped = OAuth2Handler.strip_signature(token)
        accepted_pairs = []
        tested = 0

        for ep in self.endpoints[:10]:
            evidence = self.make_request(
                ep, auth_header_raw=f"Bearer {stripped}"
            )
            tested += 1
            if self.is_success_status(evidence.response_status):
                accepted_pairs.append((ep, evidence))

        if accepted_pairs:
            self.add_result(
                "stripped_signature",
                TestStatus.FAIL,
                f"Signature-stripped JWT accepted by {len(accepted_pairs)}/{tested} endpoints",
            )
            for ep, evidence in accepted_pairs:
                self.log_finding(
                    severity=Severity.CRITICAL,
                    title="JWT with stripped signature accepted",
                    description=(
                        "A JWT with the signature completely removed was "
                        "accepted at this endpoint."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Always require and validate JWT signatures.",
                )
        else:
            self.add_result(
                "stripped_signature",
                TestStatus.PASS,
                f"Stripped signatures properly rejected ({tested} tested)",
            )

    def _test_tampered_claims(self):
        """Test if tokens with modified claims (sub, role) are accepted."""
        token = self.get_token_a()
        if not token:
            self.add_result("tampered_claims", TestStatus.SKIP, "No token")
            return

        claim_variations = [
            {"sub": "admin"},
            {"role": "admin"},
            {"scope": "admin read write delete"},
            {"is_admin": True},
        ]

        accepted_any = False
        tested = 0

        for claims in claim_variations:
            tampered = OAuth2Handler.tamper_claims(token, claims)

            for ep in self.endpoints[:5]:
                evidence = self.make_request(
                    ep, auth_header_raw=f"Bearer {tampered}"
                )
                tested += 1
                if self.is_success_status(evidence.response_status):
                    accepted_any = True
                    claim_str = ", ".join(f"{k}={v}" for k, v in claims.items())
                    self.add_result(
                        "tampered_claims",
                        TestStatus.FAIL,
                        f"Tampered claims ({claim_str}) accepted at {ep.method} {ep.url}",
                        endpoint_name=ep.full_name,
                        evidence=evidence,
                    )
                    self.log_finding(
                        severity=Severity.HIGH,
                        title=f"JWT with tampered claims accepted",
                        description=(
                            f"Modified JWT claims ({claim_str}) were accepted by "
                            f"{ep.method} {ep.url}. The server may not be validating "
                            "the JWT signature against the claims."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Verify JWT signature before trusting claims. Use server-side session validation.",
                    )
                    break

        if not accepted_any:
            self.add_result(
                "tampered_claims",
                TestStatus.PASS,
                f"Tampered claims properly rejected ({tested} variations tested)",
            )
