import logging
import re
import time

from api_pentest.core.api_discovery import ArchitectureType
from api_pentest.core.models import ScenarioApplicability, Severity, TestStatus
from api_pentest.core.oauth2_handler import OAuth2Handler
from api_pentest.scenarios.base_scenario import BaseScenario

logger = logging.getLogger(__name__)


class S05AuthHijacking(BaseScenario):
    """S05 - Authentication Hijacking via JWT manipulation."""

    SCENARIO_ID = "S05"
    SCENARIO_NAME = "Authentication Hijacking"
    OWASP_ID = "API2:2023"
    OWASP_NAME = "Broken Authentication"
    APPLICABILITY = ScenarioApplicability(
        architectures=[ArchitectureType.REST, ArchitectureType.GRAPHQL, ArchitectureType.HYBRID],
        classifications=["protected", "auth-endpoint"],
    )

    # Patterns to identify auth-related endpoints
    AUTH_ENDPOINT_PATTERNS = re.compile(
        r"(login|signin|sign-in|authenticate|auth|session|token)",
        re.IGNORECASE,
    )

    # Test usernames for enumeration
    NONEXISTENT_USERS = [
        "nonexistent_user_xyz_12345",
        "fake_account_abc_67890",
        "test_invalid_user_00000",
    ]

    def get_test_cases(self) -> list[str]:
        cases = ["user_enumeration"]  # Always test this
        if self.oauth:
            cases.extend([
                "expired_jwt_acceptance",
                "tampered_signature",
                "alg_none_attack",
                "stripped_signature",
                "tampered_claims",
            ])
        return cases

    def execute_test(self, test_name: str):
        if test_name == "user_enumeration":
            self._test_user_enumeration()
        elif test_name == "expired_jwt_acceptance":
            self._test_expired_jwt()
        elif test_name == "tampered_signature":
            self._test_tampered_signature()
        elif test_name == "alg_none_attack":
            self._test_alg_none()
        elif test_name == "stripped_signature":
            self._test_stripped_signature()
        elif test_name == "tampered_claims":
            self._test_tampered_claims()

    def _test_expired_jwt(self):
        """Test if expired JWTs are still accepted."""
        token = self.get_token_a()
        if not token:
            self.add_result("expired_jwt_acceptance", TestStatus.SKIP, "No token")
            return

        expired_jwt = OAuth2Handler.force_expired(token)
        accepted_pairs = []
        tested = 0

        for ep in self.endpoints[:10]:
            evidence = self.make_request(
                ep, auth_header_raw=f"Bearer {expired_jwt}"
            )
            tested += 1
            if self.is_success_status(evidence.response_status):
                accepted_pairs.append((ep, evidence))

        if accepted_pairs:
            self.add_result(
                "expired_jwt_acceptance",
                TestStatus.FAIL,
                f"Expired JWT accepted by {len(accepted_pairs)}/{tested} endpoints",
            )
            for ep, evidence in accepted_pairs:
                self.log_finding(
                    severity=Severity.HIGH,
                    title="Expired JWT tokens accepted",
                    description=(
                        "A JWT with exp set to 24 hours in the past was "
                        "accepted at this endpoint."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Always validate JWT expiration (exp claim). Reject expired tokens.",
                )
        else:
            self.add_result(
                "expired_jwt_acceptance",
                TestStatus.PASS,
                f"Expired JWT properly rejected by all {tested} endpoints",
            )

    def _test_tampered_signature(self):
        """Test if tokens with corrupted signatures are accepted."""
        token = self.get_token_a()
        if not token:
            self.add_result("tampered_signature", TestStatus.SKIP, "No token")
            return

        tampered = OAuth2Handler.flip_signature(token)
        accepted_pairs = []
        tested = 0

        for ep in self.endpoints[:10]:
            evidence = self.make_request(
                ep, auth_header_raw=f"Bearer {tampered}"
            )
            tested += 1
            if self.is_success_status(evidence.response_status):
                accepted_pairs.append((ep, evidence))

        if accepted_pairs:
            self.add_result(
                "tampered_signature",
                TestStatus.FAIL,
                f"Tampered signature accepted by {len(accepted_pairs)}/{tested} endpoints",
            )
            for ep, evidence in accepted_pairs:
                self.log_finding(
                    severity=Severity.CRITICAL,
                    title="JWT signature verification bypassed",
                    description=(
                        "A JWT with corrupted signature bytes was accepted at this "
                        "endpoint. Signature verification may be disabled."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Always verify JWT signatures. Use a well-tested JWT library.",
                )
        else:
            self.add_result(
                "tampered_signature",
                TestStatus.PASS,
                f"Tampered signatures properly rejected by all {tested} endpoints",
            )

    def _test_alg_none(self):
        """Test the JWT alg:none attack."""
        token = self.get_token_a()
        if not token:
            self.add_result("alg_none_attack", TestStatus.SKIP, "No token")
            return

        none_jwt = OAuth2Handler.forge_alg_none(token)
        accepted_pairs = []
        tested = 0

        for ep in self.endpoints[:10]:
            evidence = self.make_request(
                ep, auth_header_raw=f"Bearer {none_jwt}"
            )
            tested += 1
            if self.is_success_status(evidence.response_status):
                accepted_pairs.append((ep, evidence))

        if accepted_pairs:
            self.add_result(
                "alg_none_attack",
                TestStatus.FAIL,
                f"alg:none JWT accepted by {len(accepted_pairs)}/{tested} endpoints",
            )
            for ep, evidence in accepted_pairs:
                self.log_finding(
                    severity=Severity.CRITICAL,
                    title="JWT alg:none attack successful",
                    description=(
                        "A JWT with algorithm set to 'none' and empty signature "
                        "was accepted at this endpoint."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation=(
                        "Explicitly reject alg:none tokens. Whitelist allowed algorithms. "
                        "Use a JWT library that does not accept 'none' by default."
                    ),
                )
        else:
            self.add_result(
                "alg_none_attack",
                TestStatus.PASS,
                f"alg:none JWT properly rejected by all {tested} endpoints",
            )

    def _test_stripped_signature(self):
        """Test if tokens with completely removed signatures are accepted."""
        token = self.get_token_a()
        if not token:
            self.add_result("stripped_signature", TestStatus.SKIP, "No token")
            return

        stripped = OAuth2Handler.strip_signature(token)
        accepted_pairs = []
        tested = 0

        for ep in self.endpoints[:10]:
            evidence = self.make_request(
                ep, auth_header_raw=f"Bearer {stripped}"
            )
            tested += 1
            if self.is_success_status(evidence.response_status):
                accepted_pairs.append((ep, evidence))

        if accepted_pairs:
            self.add_result(
                "stripped_signature",
                TestStatus.FAIL,
                f"Signature-stripped JWT accepted by {len(accepted_pairs)}/{tested} endpoints",
            )
            for ep, evidence in accepted_pairs:
                self.log_finding(
                    severity=Severity.CRITICAL,
                    title="JWT with stripped signature accepted",
                    description=(
                        "A JWT with the signature completely removed was "
                        "accepted at this endpoint."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    evidence=evidence,
                    remediation="Always require and validate JWT signatures.",
                )
        else:
            self.add_result(
                "stripped_signature",
                TestStatus.PASS,
                f"Stripped signatures properly rejected ({tested} tested)",
            )

    def _test_tampered_claims(self):
        """Test if tokens with modified claims (sub, role) are accepted."""
        token = self.get_token_a()
        if not token:
            self.add_result("tampered_claims", TestStatus.SKIP, "No token")
            return

        claim_variations = [
            {"sub": "admin"},
            {"role": "admin"},
            {"scope": "admin read write delete"},
            {"is_admin": True},
        ]

        accepted_any = False
        tested = 0

        for claims in claim_variations:
            tampered = OAuth2Handler.tamper_claims(token, claims)

            for ep in self.endpoints[:5]:
                evidence = self.make_request(
                    ep, auth_header_raw=f"Bearer {tampered}"
                )
                tested += 1
                if self.is_success_status(evidence.response_status):
                    accepted_any = True
                    claim_str = ", ".join(f"{k}={v}" for k, v in claims.items())
                    self.add_result(
                        "tampered_claims",
                        TestStatus.FAIL,
                        f"Tampered claims ({claim_str}) accepted at {ep.method} {ep.url}",
                        endpoint_name=ep.full_name,
                        evidence=evidence,
                    )
                    self.log_finding(
                        severity=Severity.HIGH,
                        title=f"JWT with tampered claims accepted",
                        description=(
                            f"Modified JWT claims ({claim_str}) were accepted by "
                            f"{ep.method} {ep.url}. The server may not be validating "
                            "the JWT signature against the claims."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Verify JWT signature before trusting claims. Use server-side session validation.",
                    )
                    break

        if not accepted_any:
            self.add_result(
                "tampered_claims",
                TestStatus.PASS,
                f"Tampered claims properly rejected ({tested} variations tested)",
            )

    def _test_user_enumeration(self):
        """Test for user enumeration vulnerabilities in login/auth endpoints.

        User enumeration occurs when an attacker can determine valid usernames
        by comparing error messages, response times, or status codes between
        requests with valid vs invalid usernames.
        """
        # Find login/auth endpoints
        login_endpoints = self._find_login_endpoints()

        if not login_endpoints:
            self.add_result(
                "user_enumeration",
                TestStatus.SKIP,
                "No login/authentication endpoints found",
            )
            return

        vuln_found = False

        for ep in login_endpoints:
            # Get baseline with valid-looking but nonexistent user
            nonexistent_responses = []
            for fake_user in self.NONEXISTENT_USERS:
                body = self._make_login_body(ep, fake_user, "wrong_password_123")
                if body is None:
                    continue

                start = time.time()
                evidence = self.make_request(ep, override_body=body)
                elapsed = (time.time() - start) * 1000

                nonexistent_responses.append({
                    "username": fake_user,
                    "status": evidence.response_status,
                    "body": evidence.response_body,
                    "time_ms": elapsed,
                    "evidence": evidence,
                })

            if not nonexistent_responses:
                continue

            # Test with potentially valid usernames (common patterns)
            valid_candidates = ["admin", "user", "test", "demo", "root", "administrator"]
            valid_responses = []

            for candidate in valid_candidates:
                body = self._make_login_body(ep, candidate, "wrong_password_123")
                if body is None:
                    continue

                start = time.time()
                evidence = self.make_request(ep, override_body=body)
                elapsed = (time.time() - start) * 1000

                valid_responses.append({
                    "username": candidate,
                    "status": evidence.response_status,
                    "body": evidence.response_body,
                    "time_ms": elapsed,
                    "evidence": evidence,
                })

            if not valid_responses:
                continue

            # Compare responses for enumeration indicators
            enumeration_found = self._detect_enumeration(
                ep, nonexistent_responses, valid_responses
            )

            if enumeration_found:
                vuln_found = True

        if not vuln_found:
            self.add_result(
                "user_enumeration",
                TestStatus.PASS,
                f"No user enumeration detected ({len(login_endpoints)} endpoints tested)",
            )

    def _find_login_endpoints(self) -> list:
        """Find endpoints that look like login/authentication."""
        login_eps = []
        for ep in self.endpoints:
            if ep.method.upper() != "POST":
                continue

            # Check URL and name for auth patterns
            url_lower = ep.url.lower()
            name_lower = (ep.full_name or ep.name or "").lower()

            if self.AUTH_ENDPOINT_PATTERNS.search(url_lower) or \
               self.AUTH_ENDPOINT_PATTERNS.search(name_lower):
                login_eps.append(ep)

        return login_eps

    def _make_login_body(self, ep, username: str, password: str) -> dict | None:
        """Create a login request body, inferring field names from endpoint spec."""
        if not ep.body or not isinstance(ep.body, dict):
            # Default login body structure
            return {"username": username, "password": password}

        body = dict(ep.body)

        # Find and replace username field
        username_fields = ["username", "user", "email", "login", "user_id", "account"]
        for field in username_fields:
            if field in body:
                body[field] = username
                break
        else:
            # No username field found, try to add one
            body["username"] = username

        # Find and replace password field
        password_fields = ["password", "passwd", "pass", "pwd", "secret"]
        for field in password_fields:
            if field in body:
                body[field] = password
                break
        else:
            body["password"] = password

        return body

    def _detect_enumeration(self, ep, nonexistent: list, valid_candidates: list) -> bool:
        """Detect enumeration based on response differences."""
        # Get typical nonexistent response characteristics
        nonexistent_statuses = {r["status"] for r in nonexistent}
        nonexistent_times = [r["time_ms"] for r in nonexistent]
        avg_nonexistent_time = sum(nonexistent_times) / len(nonexistent_times)

        # Normalize error messages for comparison
        nonexistent_messages = set()
        for r in nonexistent:
            normalized = self._normalize_error_message(r["body"])
            if normalized:
                nonexistent_messages.add(normalized)

        enumeration_indicators = []

        for resp in valid_candidates:
            # 1. Status code difference
            if resp["status"] not in nonexistent_statuses:
                enumeration_indicators.append(
                    f"Status code differs for '{resp['username']}': "
                    f"{resp['status']} vs {nonexistent_statuses}"
                )

            # 2. Response message difference
            normalized_msg = self._normalize_error_message(resp["body"])
            if normalized_msg and normalized_msg not in nonexistent_messages:
                # Check for enumeration-revealing messages
                if self._is_enumeration_message(resp["body"], nonexistent[0]["body"]):
                    enumeration_indicators.append(
                        f"Different error message for '{resp['username']}'"
                    )

            # 3. Timing difference (> 100ms difference is suspicious)
            time_diff = abs(resp["time_ms"] - avg_nonexistent_time)
            if time_diff > 100:
                enumeration_indicators.append(
                    f"Timing difference for '{resp['username']}': "
                    f"{resp['time_ms']:.0f}ms vs avg {avg_nonexistent_time:.0f}ms"
                )

        if enumeration_indicators:
            self.add_result(
                "user_enumeration",
                TestStatus.FAIL,
                f"User enumeration at {ep.method} {ep.url}: {enumeration_indicators[0]}",
                endpoint_name=ep.full_name,
                evidence=valid_candidates[0]["evidence"] if valid_candidates else None,
            )
            self.log_finding(
                severity=Severity.MEDIUM,
                title=f"User Enumeration vulnerability in {ep.method} {ep.url}",
                description=(
                    f"The login endpoint reveals whether a username exists through "
                    f"different responses. Indicators: {'; '.join(enumeration_indicators[:3])}"
                ),
                endpoint=f"{ep.method} {ep.url}",
                evidence=valid_candidates[0]["evidence"] if valid_candidates else None,
                remediation=(
                    "Return identical error messages for invalid username and invalid "
                    "password. Use consistent response times (add artificial delay if needed). "
                    "Example: 'Invalid credentials' for both cases."
                ),
            )
            return True

        return False

    def _normalize_error_message(self, body: str) -> str | None:
        """Extract and normalize error message from response body."""
        if not body:
            return None

        # Try to extract error message from JSON
        data = self.parse_json_safe(type("Ev", (), {"response_body": body})())
        if data and isinstance(data, dict):
            for key in ["message", "error", "msg", "detail", "status"]:
                if key in data and isinstance(data[key], str):
                    return data[key].lower().strip()

        # Fallback: use truncated body
        return body[:200].lower().strip()

    def _is_enumeration_message(self, resp1: str, resp2: str) -> bool:
        """Check if two responses indicate user enumeration."""
        # Known enumeration-revealing patterns
        user_not_found_patterns = [
            "user not found", "user does not exist", "no user",
            "account not found", "unknown user", "invalid user",
            "user doesn't exist", "no account", "unregistered",
        ]
        wrong_password_patterns = [
            "wrong password", "incorrect password", "invalid password",
            "password mismatch", "bad password", "password incorrect",
        ]

        resp1_lower = resp1.lower()
        resp2_lower = resp2.lower()

        # Check if one says "user not found" and other says "wrong password"
        resp1_user_not_found = any(p in resp1_lower for p in user_not_found_patterns)
        resp1_wrong_password = any(p in resp1_lower for p in wrong_password_patterns)
        resp2_user_not_found = any(p in resp2_lower for p in user_not_found_patterns)
        resp2_wrong_password = any(p in resp2_lower for p in wrong_password_patterns)

        # Enumeration if responses reveal different error types
        if (resp1_user_not_found and resp2_wrong_password) or \
           (resp1_wrong_password and resp2_user_not_found):
            return True

        return False
