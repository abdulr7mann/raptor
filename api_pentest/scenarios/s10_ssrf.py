import json
import logging
import re
import time

from api_pentest.core.models import ScenarioApplicability, Severity, TestStatus
from api_pentest.scenarios.base_scenario import BaseScenario

logger = logging.getLogger(__name__)


class S10SSRF(BaseScenario):
    """S10 - Server Side Request Forgery testing."""

    SCENARIO_ID = "S10"
    SCENARIO_NAME = "Server Side Request Forgery"
    OWASP_ID = "API7:2023"
    OWASP_NAME = "Server Side Request Forgery"
    APPLICABILITY = ScenarioApplicability()  # SSRF can occur on any endpoint type

    URL_PARAM_NAMES = {
        "url", "uri", "callback", "webhook", "redirect", "redirect_uri",
        "redirect_url", "link", "href", "fetch", "image", "avatar",
        "icon", "logo", "proxy", "target", "dest", "destination",
        "next", "return", "return_url", "continue", "forward",
    }

    INTERNAL_URLS = [
        "http://127.0.0.1",
        "http://localhost",
        "http://[::1]",
        "http://0.0.0.0",
        "http://0177.0.0.1",
        "http://2130706433",
        "http://10.0.0.1",
        "http://172.16.0.1",
        "http://192.168.0.1",
    ]

    CLOUD_METADATA_URLS = [
        "http://169.254.169.254/latest/meta-data/",
        "http://169.254.169.254/computeMetadata/v1/",
        "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
    ]

    PROTOCOL_PAYLOADS = [
        "file:///etc/passwd",
        "file:///etc/hosts",
        "gopher://127.0.0.1:25/",
        "dict://127.0.0.1:11211/",
        "ftp://127.0.0.1/",
    ]

    def get_test_cases(self) -> list[str]:
        return [
            "url_parameter_detection",
            "internal_url_injection",
            "cloud_metadata_probe",
            "protocol_smuggling",
            "redirect_ssrf",
        ]

    def execute_test(self, test_name: str):
        if test_name == "url_parameter_detection":
            self._test_url_param_detection()
        elif test_name == "internal_url_injection":
            self._test_internal_url_injection()
        elif test_name == "cloud_metadata_probe":
            self._test_cloud_metadata()
        elif test_name == "protocol_smuggling":
            self._test_protocol_smuggling()
        elif test_name == "redirect_ssrf":
            self._test_redirect_ssrf()

    def _find_url_params(self):
        """Scan endpoints for parameters that could accept URLs."""
        url_params = []
        for ep in self.endpoints:
            # Check query params
            for param_name in (ep.query_params or {}):
                if param_name.lower() in self.URL_PARAM_NAMES:
                    url_params.append((ep, "query", param_name))

            # Check body fields
            if ep.body and isinstance(ep.body, dict):
                for field_name in ep.body:
                    if field_name.lower() in self.URL_PARAM_NAMES:
                        url_params.append((ep, "body", field_name))

            # Check path for URL-like segments
            for param_name in (ep.path_params or {}):
                if param_name.lower() in self.URL_PARAM_NAMES:
                    url_params.append((ep, "path", param_name))

        return url_params

    def _find_string_params(self):
        """Find all string-type parameters across endpoints for injection."""
        targets = []
        for ep in self.endpoints:
            if ep.body and isinstance(ep.body, dict):
                for field_name, value in ep.body.items():
                    if isinstance(value, str):
                        targets.append((ep, field_name))
            for param_name, value in (ep.query_params or {}).items():
                if isinstance(value, str):
                    targets.append((ep, param_name))
        return targets[:10]  # Limit to 10 for performance

    def _test_url_param_detection(self):
        """Identify endpoints with URL-capable parameters."""
        url_params = self._find_url_params()

        if url_params:
            for ep, location, param in url_params:
                self.log_finding(
                    severity=Severity.INFO,
                    title=f"URL-capable parameter found: {param} ({location})",
                    description=(
                        f"Parameter '{param}' in {location} of {ep.method} {ep.url} "
                        "may accept URLs. Manual SSRF testing recommended."
                    ),
                    endpoint=f"{ep.method} {ep.url}",
                    remediation="Validate and whitelist URLs. Block internal/private IP ranges.",
                )

        self.add_result(
            "url_parameter_detection",
            TestStatus.FAIL if url_params else TestStatus.PASS,
            f"Found {len(url_params)} URL-capable parameters" if url_params
            else "No URL-capable parameters detected",
        )

    def _test_internal_url_injection(self):
        """Inject internal URLs into string parameters and detect via timing."""
        token = self.get_token_a()
        targets = self._find_string_params()
        url_params = self._find_url_params()

        all_targets = []
        for ep, location, param in url_params:
            all_targets.append((ep, param, location))
        for ep, param in targets:
            all_targets.append((ep, param, "body"))

        if not all_targets:
            self.add_result("internal_url_injection", TestStatus.SKIP, "No injectable parameters")
            return

        ssrf_detected = False

        for ep, param, location in all_targets[:5]:
            # Get baseline timing
            baseline_ev = self.make_request(ep, token=token)
            baseline_time = baseline_ev.response_time_ms

            for internal_url in self.INTERNAL_URLS[:3]:
                if location == "body" and ep.body and isinstance(ep.body, dict):
                    body = dict(ep.body)
                    body[param] = internal_url
                    evidence = self.make_request(ep, token=token, override_body=body)
                elif location == "query":
                    override_url = ep.url
                    sep = "&" if "?" in override_url else "?"
                    override_url = f"{override_url}{sep}{param}={internal_url}"
                    evidence = self.make_request(ep, token=token, override_url=override_url)
                else:
                    continue

                time_diff = abs(evidence.response_time_ms - baseline_time)
                body_lower = str(evidence.response_body or "").lower()

                # Check for SSRF indicators
                connection_errors = any(
                    indicator in body_lower
                    for indicator in ["connection refused", "connection reset", "timeout",
                                      "name or service not known", "no route"]
                )

                if time_diff > 2000 or connection_errors:
                    ssrf_detected = True
                    self.log_finding(
                        severity=Severity.HIGH,
                        title=f"Possible SSRF via {param} parameter",
                        description=(
                            f"Injecting '{internal_url}' into '{param}' at {ep.method} {ep.url} "
                            f"caused {'timing anomaly' if time_diff > 2000 else 'connection error indicators'}. "
                            f"Time diff: {time_diff:.0f}ms. This suggests the server attempted to connect."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Validate URLs against a whitelist. Block internal/private IP ranges and localhost.",
                    )
                    break

        status = TestStatus.FAIL if ssrf_detected else TestStatus.PASS
        self.add_result(
            "internal_url_injection",
            status,
            f"SSRF {'indicators detected' if ssrf_detected else 'not detected'}",
        )

    def _test_cloud_metadata(self):
        """Probe for cloud metadata endpoint access via SSRF."""
        token = self.get_token_a()
        url_params = self._find_url_params()
        targets = self._find_string_params()

        all_targets = [(ep, param, loc) for ep, loc, param in url_params]
        all_targets += [(ep, param, "body") for ep, param in targets]

        if not all_targets:
            self.add_result("cloud_metadata_probe", TestStatus.SKIP, "No injectable parameters")
            return

        metadata_found = False

        for ep, param, location in all_targets[:3]:
            for meta_url in self.CLOUD_METADATA_URLS:
                if location == "body" and ep.body and isinstance(ep.body, dict):
                    body = dict(ep.body)
                    body[param] = meta_url
                    evidence = self.make_request(ep, token=token, override_body=body)
                elif location == "query":
                    override_url = ep.url
                    sep = "&" if "?" in override_url else "?"
                    override_url = f"{override_url}{sep}{param}={meta_url}"
                    evidence = self.make_request(ep, token=token, override_url=override_url)
                else:
                    continue

                body_text = str(evidence.response_body or "")
                metadata_indicators = ["ami-id", "instance-id", "local-ipv4", "public-hostname",
                                       "iam/", "security-credentials"]

                if any(ind in body_text.lower() for ind in metadata_indicators):
                    metadata_found = True
                    self.log_finding(
                        severity=Severity.CRITICAL,
                        title=f"Cloud metadata accessible via SSRF: {param}",
                        description=(
                            f"Cloud metadata content detected when injecting '{meta_url}' "
                            f"into '{param}' at {ep.method} {ep.url}."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Block access to cloud metadata IPs (169.254.169.254). Use IMDSv2 with token requirement.",
                    )

        status = TestStatus.FAIL if metadata_found else TestStatus.PASS
        self.add_result(
            "cloud_metadata_probe",
            status,
            f"Cloud metadata {'exposed' if metadata_found else 'not accessible'}",
        )

    def _test_protocol_smuggling(self):
        """Test if non-HTTP protocols are processed."""
        token = self.get_token_a()
        url_params = self._find_url_params()
        targets = self._find_string_params()

        all_targets = [(ep, param, loc) for ep, loc, param in url_params]
        all_targets += [(ep, param, "body") for ep, param in targets]

        if not all_targets:
            self.add_result("protocol_smuggling", TestStatus.SKIP, "No injectable parameters")
            return

        smuggling_found = False

        for ep, param, location in all_targets[:3]:
            for payload in self.PROTOCOL_PAYLOADS:
                if location == "body" and ep.body and isinstance(ep.body, dict):
                    body = dict(ep.body)
                    body[param] = payload
                    evidence = self.make_request(ep, token=token, override_body=body)
                elif location == "query":
                    override_url = ep.url
                    sep = "&" if "?" in override_url else "?"
                    override_url = f"{override_url}{sep}{param}={payload}"
                    evidence = self.make_request(ep, token=token, override_url=override_url)
                else:
                    continue

                body_text = str(evidence.response_body or "")

                file_indicators = ["root:", "/bin/bash", "/bin/sh", "localhost", "127.0.0.1"]
                if payload.startswith("file://") and any(ind in body_text for ind in file_indicators):
                    smuggling_found = True
                    self.log_finding(
                        severity=Severity.CRITICAL,
                        title=f"File protocol SSRF via {param}",
                        description=(
                            f"file:// protocol payload returned system file content "
                            f"when injected into '{param}' at {ep.method} {ep.url}."
                        ),
                        endpoint=f"{ep.method} {ep.url}",
                        evidence=evidence,
                        remediation="Restrict allowed URL schemes to http and https only.",
                    )

        status = TestStatus.FAIL if smuggling_found else TestStatus.PASS
        self.add_result(
            "protocol_smuggling",
            status,
            f"Protocol smuggling {'detected' if smuggling_found else 'not detected'}",
        )

    def _test_redirect_ssrf(self):
        """Check API redirect-following behavior."""
        token = self.get_token_a()

        if not self.endpoints:
            self.add_result("redirect_ssrf", TestStatus.SKIP, "No endpoints")
            return

        ep = self.endpoints[0]
        evidence = self.make_request(ep, token=token)

        # Check if the client follows redirects by default
        redirect_info = "API redirect behavior observed."
        if evidence.response_status in (301, 302, 303, 307, 308):
            location = evidence.response_headers.get("Location", evidence.response_headers.get("location", ""))
            self.log_finding(
                severity=Severity.INFO,
                title="API returns redirects",
                description=(
                    f"{ep.method} {ep.url} returned HTTP {evidence.response_status} "
                    f"with Location: {location}. Verify redirect targets are validated."
                ),
                endpoint=f"{ep.method} {ep.url}",
                evidence=evidence,
                remediation="Validate redirect targets. Do not follow redirects to internal or untrusted destinations.",
            )

        self.add_result(
            "redirect_ssrf",
            TestStatus.PASS,
            "Redirect behavior checked - manual review recommended",
        )
