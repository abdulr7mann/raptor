#!/usr/bin/env python3
"""
API Pentest Toolkit - CLI Entry Point

Usage:
    python run_pentest.py --input collection.json --config pentest.yaml
    python run_pentest.py --input swagger.yaml --config pentest.yaml --scenarios s01,s03
    python run_pentest.py --input collection.json --env my_env.json --config pentest.yaml
    python run_pentest.py --input collection.json --config pentest.yaml --list-endpoints
"""

import argparse
import logging
import subprocess
import sys
from pathlib import Path

import yaml

from api_pentest.runner import PentestRunner


def check_for_updates(verbose: bool = False) -> bool:
    """Check for and apply updates from git remote.

    Returns True if updates were applied, False otherwise.
    Fails silently on errors to not block the main tool.
    """
    try:
        # Get the directory where this script lives
        script_dir = Path(__file__).parent.absolute()

        # Check if we're in a git repo
        result = subprocess.run(
            ["git", "rev-parse", "--git-dir"],
            cwd=script_dir,
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode != 0:
            return False

        # Fetch latest from remote (silently)
        subprocess.run(
            ["git", "fetch", "--quiet"],
            cwd=script_dir,
            capture_output=True,
            timeout=30,
        )

        # Check if we're behind remote
        result = subprocess.run(
            ["git", "rev-list", "--count", "HEAD..@{u}"],
            cwd=script_dir,
            capture_output=True,
            text=True,
            timeout=5,
        )

        if result.returncode != 0:
            return False

        commits_behind = int(result.stdout.strip() or "0")

        if commits_behind > 0:
            print(f"ðŸ”„ {commits_behind} update(s) available. Pulling latest changes...")

            # Pull updates
            pull_result = subprocess.run(
                ["git", "pull", "--ff-only"],
                cwd=script_dir,
                capture_output=True,
                text=True,
                timeout=60,
            )

            if pull_result.returncode == 0:
                print("âœ… Updated successfully!")
                if verbose:
                    print(pull_result.stdout)
                return True
            else:
                print("âš ï¸  Auto-update failed (local changes?). Run 'git pull' manually.")
                if verbose:
                    print(pull_result.stderr)
                return False

        return False

    except subprocess.TimeoutExpired:
        if verbose:
            print("âš ï¸  Update check timed out")
        return False
    except FileNotFoundError:
        # git not installed
        return False
    except Exception as e:
        if verbose:
            print(f"âš ï¸  Update check failed: {e}")
        return False


def load_config(config_path: str, cli_overrides: dict) -> dict:
    """Load YAML config and merge CLI overrides."""
    config = {}

    if config_path and Path(config_path).exists():
        with open(config_path, "r", encoding="utf-8") as f:
            config = yaml.safe_load(f) or {}

    # Apply CLI overrides
    if cli_overrides.get("input"):
        config["input_file"] = cli_overrides["input"]
    if cli_overrides.get("url"):
        config["discovery_url"] = cli_overrides["url"]
        # Clear input_file when using URL mode (URL takes precedence)
        config.pop("input_file", None)
    if cli_overrides.get("env"):
        config["environment_file"] = cli_overrides["env"]
    if cli_overrides.get("base_url"):
        config["base_url"] = cli_overrides["base_url"]
    if cli_overrides.get("output_dir"):
        config["output_dir"] = cli_overrides["output_dir"]

    return config


def main():
    parser = argparse.ArgumentParser(
        description="API Penetration Testing Toolkit",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --input collection.json --config pentest.yaml
  %(prog)s --input swagger.yaml --config pentest.yaml --scenarios s01,s03,s05
  %(prog)s --input collection.json --env env.json --config pentest.yaml
  %(prog)s --input collection.json --config pentest.yaml --list-endpoints
  %(prog)s --url http://api.example.com --config pentest.yaml
        """,
    )

    parser.add_argument(
        "--input", "-i",
        help="Path to Postman collection (.json) or Swagger/OpenAPI spec (.json/.yaml)",
    )
    parser.add_argument(
        "--url", "-u",
        help="Base URL for auto-discovery (alternative to --input). "
             "Discovers API spec at common paths (/openapi.json, /swagger.json, etc.), "
             "falls back to endpoint fuzzing if no spec found.",
    )
    parser.add_argument(
        "--config", "-c",
        default="pentest.yaml",
        help="Path to pentest configuration file (default: pentest.yaml)",
    )
    parser.add_argument(
        "--env", "-e",
        help="Path to Postman environment file (.json) for variable resolution",
    )
    parser.add_argument(
        "--scenarios", "-s",
        help="Comma-separated list of scenarios to run (e.g., s01,s03,s05). Default: all",
    )
    parser.add_argument(
        "--base-url",
        help="Override base URL for all endpoints",
    )
    parser.add_argument(
        "--output-dir", "-o",
        help="Directory for report output (default: ./reports)",
    )
    parser.add_argument(
        "--list-endpoints",
        action="store_true",
        help="List all discovered endpoints without running tests",
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose/debug logging",
    )
    parser.add_argument(
        "--relevance-threshold",
        type=float,
        default=0.3,
        metavar="SCORE",
        help="Minimum relevance score (0.0-1.0) to run a test. "
             "Lower = more tests, higher coverage. "
             "Higher = faster, fewer tests. Default: 0.3",
    )
    parser.add_argument(
        "--fast",
        action="store_true",
        help="Fast mode: raise relevance threshold to 0.6 for quicker scans "
             "(reduces test coverage)",
    )
    parser.add_argument(
        "--no-update",
        action="store_true",
        help="Skip automatic git pull check for updates",
    )

    args = parser.parse_args()

    # Check for updates (unless disabled)
    if not args.no_update:
        check_for_updates(verbose=args.verbose)

    # Validate --input XOR --url required
    if not args.input and not args.url:
        parser.error("Either --input or --url is required")
    if args.input and args.url:
        parser.error("Cannot use both --input and --url")

    # Setup logging
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(
        level=log_level,
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
        datefmt="%H:%M:%S",
    )

    # Validate input file exists (only when using --input)
    if args.input and not Path(args.input).exists():
        print(f"Error: Input file not found: {args.input}", file=sys.stderr)
        sys.exit(1)

    # Load config
    cli_overrides = {
        "input": args.input,
        "url": args.url,
        "env": args.env,
        "base_url": args.base_url,
        "output_dir": args.output_dir,
    }
    config = load_config(args.config, cli_overrides)

    # Apply relevance threshold from CLI
    if args.relevance_threshold:
        config["relevance_threshold"] = args.relevance_threshold

    # Fast mode overrides threshold
    if args.fast:
        config["relevance_threshold"] = max(0.6, config.get("relevance_threshold", 0.3))
        print(f"Fast mode enabled: relevance threshold set to {config['relevance_threshold']}")

    # Validate threshold range
    threshold = config.get("relevance_threshold", 0.3)
    if not 0.0 <= threshold <= 1.0:
        print(f"Error: relevance-threshold must be between 0.0 and 1.0", file=sys.stderr)
        sys.exit(1)

    # Create runner
    runner = PentestRunner(config)

    # Parse scenario list
    scenario_ids = None
    if args.scenarios:
        scenario_ids = [s.strip() for s in args.scenarios.split(",")]

    # Run pentest
    try:
        if args.list_endpoints:
            runner.list_endpoints()
        else:
            runner.run(scenario_ids=scenario_ids)
    except KeyboardInterrupt:
        print("\nInterrupted by user (Ctrl+C).")
        sys.exit(130)
    except Exception as e:
        print(f"\nFatal error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
