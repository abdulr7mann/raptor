---
phase: 06-adaptive-test-execution
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - api_pentest/scenarios/base_scenario.py
  - api_pentest/scenarios/s01_token_reuse.py
  - api_pentest/scenarios/s02_rate_limiting.py
  - api_pentest/scenarios/s03_idor.py
  - api_pentest/scenarios/s04_injection.py
  - api_pentest/scenarios/s05_auth_hijacking.py
  - api_pentest/scenarios/s06_privileged_access.py
  - api_pentest/scenarios/s07_access_controls.py
  - api_pentest/scenarios/s08_api_responses.py
  - api_pentest/scenarios/s09_business_flow.py
  - api_pentest/scenarios/s10_ssrf.py
  - api_pentest/scenarios/s11_security_misconfig.py
  - api_pentest/scenarios/s12_inventory_management.py
  - api_pentest/scenarios/s13_unsafe_consumption.py
autonomous: true

must_haves:
  truths:
    - "BaseScenario has a default APPLICABILITY class attribute"
    - "All 13 scenarios declare explicit APPLICABILITY for their architecture and classification requirements"
    - "GraphQL-specific tests are annotated to only run on GraphQL architectures"
    - "Tests can adapt auth headers and content-types based on api_profile (TEST-02)"
  artifacts:
    - path: "api_pentest/scenarios/base_scenario.py"
      provides: "Default APPLICABILITY, format handling methods, profile adaptation helpers"
      contains: "APPLICABILITY = ScenarioApplicability()"
    - path: "api_pentest/scenarios/s03_idor.py"
      provides: "IDOR scenario with REST/HYBRID applicability"
      contains: "APPLICABILITY = ScenarioApplicability"
    - path: "api_pentest/scenarios/s07_access_controls.py"
      provides: "Access controls with classification requirements"
      contains: "APPLICABILITY = ScenarioApplicability"
  key_links:
    - from: "api_pentest/scenarios/base_scenario.py"
      to: "api_pentest/core/models.py"
      via: "import ScenarioApplicability"
      pattern: "from api_pentest.core.models import.*ScenarioApplicability"
    - from: "api_pentest/scenarios/s01_token_reuse.py"
      to: "api_pentest/core/api_discovery.py"
      via: "import ArchitectureType for APPLICABILITY"
      pattern: "from api_pentest.core.api_discovery import ArchitectureType"
---

<objective>
Add APPLICABILITY declarations to BaseScenario and all 13 scenarios to enable architecture and classification-based test filtering.

Purpose: Each scenario declares what API types it applies to. GraphQL tests won't run on REST APIs. Auth tests won't run on public endpoints. This metadata enables the runner to filter before executing.

Output: All scenarios annotated with explicit applicability declarations.
</objective>

<execution_context>
@/home/abdulr7man/.claude/get-shit-done/workflows/execute-plan.md
@/home/abdulr7man/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-adaptive-test-execution/06-CONTEXT.md
@.planning/phases/06-adaptive-test-execution/06-RESEARCH.md
@.planning/phases/06-adaptive-test-execution/06-01-SUMMARY.md
@api_pentest/scenarios/base_scenario.py
@api_pentest/core/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add default APPLICABILITY and format handling to BaseScenario</name>
  <files>api_pentest/scenarios/base_scenario.py</files>
  <action>
    Update BaseScenario with:

    1. **Import additions** at top of file:
       ```python
       from api_pentest.core.models import ScenarioApplicability
       from api_pentest.core.response_formats import ResponseFormatHandler
       ```

    2. **Default APPLICABILITY class attribute** (after OWASP_NAME):
       ```python
       APPLICABILITY = ScenarioApplicability()  # Empty = applies to all
       ```

    3. **Add api_profile attribute** in __init__:
       ```python
       self.api_profile = None
       ```

    4. **Update setup() signature and body** to accept and store api_profile:
       - Add parameter: `api_profile=None`
       - Store: `self.api_profile = api_profile`

    5. **Add response format helper methods**:
       ```python
       def parse_response_body(self, evidence):
           """Parse response body based on Content-Type.

           Returns (parsed_data, format_type) where format_type is
           'json', 'xml', 'text', or 'empty'.
           """
           handler = ResponseFormatHandler()
           return handler.parse(evidence)

       def parse_json_safe(self, evidence):
           """Parse response as JSON if possible, return None otherwise."""
           handler = ResponseFormatHandler()
           return handler.parse_json_safe(evidence)
       ```

    6. **Add auth header adaptation helper method** (uses api_profile):
       ```python
       def get_auth_header_from_profile(self):
           """Get the appropriate auth header name from api_profile.

           Returns the auth header name to use (e.g., 'Authorization', 'X-API-Key'),
           based on detected auth schemes in api_profile. Falls back to 'Authorization'.
           """
           if not self.api_profile or not self.api_profile.auth_schemes:
               return "Authorization"

           # Prefer Bearer/OAuth, then API key, then first detected
           for scheme in self.api_profile.auth_schemes:
               if scheme.lower() in ("bearer", "oauth2", "jwt"):
                   return "Authorization"
               if "api" in scheme.lower() and "key" in scheme.lower():
                   return "X-API-Key"

           # Default to Authorization for any auth scheme
           return "Authorization"
       ```

    7. **Add content-type adaptation helper method** (uses api_profile):
       ```python
       def get_content_type_from_profile(self):
           """Get the preferred content type from api_profile.

           Returns the content type string to use in requests,
           based on detected content_types in api_profile. Falls back to 'application/json'.
           """
           if not self.api_profile or not self.api_profile.content_types:
               return "application/json"

           # Prefer JSON if available
           for ct in self.api_profile.content_types:
               if "json" in ct.lower():
                   return ct

           # Return first detected content type
           return self.api_profile.content_types[0]
       ```

    These methods give all scenarios access to safe format parsing and profile-based request adaptation.
  </action>
  <verify>
    Run: python -c "
from api_pentest.scenarios.base_scenario import BaseScenario
print(f'APPLICABILITY: {BaseScenario.APPLICABILITY}')
print('parse_response_body method exists:', hasattr(BaseScenario, 'parse_response_body'))
"

    Expected: Shows default ScenarioApplicability() and True for method existence.

    Also run: python -c "
from api_pentest.scenarios.base_scenario import BaseScenario
print('get_auth_header_from_profile exists:', hasattr(BaseScenario, 'get_auth_header_from_profile'))
print('get_content_type_from_profile exists:', hasattr(BaseScenario, 'get_content_type_from_profile'))
"

    Expected: Both methods exist (True, True).
  </verify>
  <done>
    BaseScenario has default APPLICABILITY, accepts api_profile in setup(), and provides:
    - parse_response_body() and parse_json_safe() for format handling
    - get_auth_header_from_profile() for auth header adaptation (TEST-02)
    - get_content_type_from_profile() for content-type adaptation (TEST-02)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add APPLICABILITY declarations to all 13 scenarios</name>
  <files>
    api_pentest/scenarios/s01_token_reuse.py
    api_pentest/scenarios/s02_rate_limiting.py
    api_pentest/scenarios/s03_idor.py
    api_pentest/scenarios/s04_injection.py
    api_pentest/scenarios/s05_auth_hijacking.py
    api_pentest/scenarios/s06_privileged_access.py
    api_pentest/scenarios/s07_access_controls.py
    api_pentest/scenarios/s08_api_responses.py
    api_pentest/scenarios/s09_business_flow.py
    api_pentest/scenarios/s10_ssrf.py
    api_pentest/scenarios/s11_security_misconfig.py
    api_pentest/scenarios/s12_inventory_management.py
    api_pentest/scenarios/s13_unsafe_consumption.py
  </files>
  <action>
    Add APPLICABILITY to each scenario based on its test purpose:

    **Import required** for each scenario (if not already present):
    ```python
    from api_pentest.core.models import ScenarioApplicability
    from api_pentest.core.api_discovery import ArchitectureType
    ```

    **Scenario-specific APPLICABILITY declarations** (add after OWASP_NAME):

    **S01 Token Reuse** - Tests token security, applies to all architectures with auth:
    ```python
    APPLICABILITY = ScenarioApplicability(
        architectures=[ArchitectureType.REST, ArchitectureType.GRAPHQL, ArchitectureType.HYBRID],
        classifications=["protected"],  # Only test authenticated endpoints
    )
    ```

    **S02 Rate Limiting** - Already has prerequisite gating, applies to all:
    ```python
    APPLICABILITY = ScenarioApplicability(
        requires_prerequisites=["rate_limiting"],  # Only if rate limiting detected
    )
    ```

    **S03 IDOR** - Object reference tests, REST/HYBRID focus (GraphQL uses different patterns):
    ```python
    APPLICABILITY = ScenarioApplicability(
        architectures=[ArchitectureType.REST, ArchitectureType.HYBRID, ArchitectureType.UNKNOWN],
        classifications=["protected"],  # Only authenticated endpoints
    )
    ```

    **S04 Injection** - SQL/NoSQL injection, applies broadly:
    ```python
    APPLICABILITY = ScenarioApplicability(
        architectures=[ArchitectureType.REST, ArchitectureType.GRAPHQL, ArchitectureType.HYBRID, ArchitectureType.UNKNOWN],
        # No classification restriction - injection can affect any endpoint
    )
    ```

    **S05 Auth Hijacking** - Session/token attacks, needs auth:
    ```python
    APPLICABILITY = ScenarioApplicability(
        architectures=[ArchitectureType.REST, ArchitectureType.GRAPHQL, ArchitectureType.HYBRID],
        classifications=["protected", "auth-endpoint"],
    )
    ```

    **S06 Privileged Access** - Privilege escalation, protected endpoints only:
    ```python
    APPLICABILITY = ScenarioApplicability(
        architectures=[ArchitectureType.REST, ArchitectureType.GRAPHQL, ArchitectureType.HYBRID, ArchitectureType.UNKNOWN],
        classifications=["protected"],
    )
    ```

    **S07 Access Controls** - Already uses classification, skip public:
    ```python
    APPLICABILITY = ScenarioApplicability(
        classifications=["protected"],  # Skip public endpoints (existing behavior)
    )
    ```

    **S08 API Responses** - Data exposure checks, skip auth endpoints:
    ```python
    APPLICABILITY = ScenarioApplicability(
        classifications=["public", "protected"],  # Exclude auth-endpoint (returns creds by design)
    )
    ```

    **S09 Business Flow** - Business logic attacks, applies broadly:
    ```python
    APPLICABILITY = ScenarioApplicability()  # No restrictions - business logic can be anywhere
    ```

    **S10 SSRF** - Server-side request forgery, applies to all:
    ```python
    APPLICABILITY = ScenarioApplicability()  # SSRF can occur on any endpoint type
    ```

    **S11 Security Misconfig** - Header/config checks, applies to all:
    ```python
    APPLICABILITY = ScenarioApplicability()  # Config issues affect all endpoints
    ```

    **S12 Inventory Management** - Undocumented endpoints, applies to all:
    ```python
    APPLICABILITY = ScenarioApplicability()  # Inventory issues affect all APIs
    ```

    **S13 Unsafe Consumption** - Third-party integrations, applies to all:
    ```python
    APPLICABILITY = ScenarioApplicability()  # Integration issues can be anywhere
    ```
  </action>
  <verify>
    Run: python -c "
from api_pentest.scenarios.s01_token_reuse import S01TokenReuse
from api_pentest.scenarios.s03_idor import S03IDOR
from api_pentest.scenarios.s07_access_controls import S07AccessControls
print(f'S01: {S01TokenReuse.APPLICABILITY}')
print(f'S03: {S03IDOR.APPLICABILITY}')
print(f'S07: {S07AccessControls.APPLICABILITY}')
"

    Expected: Each scenario shows its specific APPLICABILITY with architectures and classifications.
  </verify>
  <done>
    All 13 scenarios have explicit APPLICABILITY declarations appropriate to their test purpose.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify all scenarios have APPLICABILITY:
   ```bash
   python -c "
   import importlib
   scenarios = ['s01_token_reuse', 's02_rate_limiting', 's03_idor', 's04_injection',
                's05_auth_hijacking', 's06_privileged_access', 's07_access_controls',
                's08_api_responses', 's09_business_flow', 's10_ssrf',
                's11_security_misconfig', 's12_inventory_management', 's13_unsafe_consumption']
   for s in scenarios:
       mod = importlib.import_module(f'api_pentest.scenarios.{s}')
       cls = [getattr(mod, n) for n in dir(mod) if n.startswith('S0') or n.startswith('S1')][0]
       print(f'{s}: {cls.APPLICABILITY is not None}')
   "
   ```

2. Check no import errors:
   ```bash
   python -c "from api_pentest.runner import PentestRunner; print('Runner imports OK')"
   ```

3. Verify architecture-specific scenarios:
   ```bash
   python -c "
   from api_pentest.scenarios.s03_idor import S03IDOR
   from api_pentest.core.api_discovery import ArchitectureType
   assert ArchitectureType.GRAPHQL not in S03IDOR.APPLICABILITY.architectures, 'S03 should not apply to GraphQL'
   print('Architecture filtering verified')
   "
   ```
</verification>

<success_criteria>
- BaseScenario has default APPLICABILITY = ScenarioApplicability()
- BaseScenario.setup() accepts api_profile parameter
- parse_response_body() and parse_json_safe() methods available on all scenarios
- get_auth_header_from_profile() returns correct auth header based on api_profile.auth_schemes (TEST-02)
- get_content_type_from_profile() returns correct content-type based on api_profile.content_types (TEST-02)
- All 13 scenarios declare explicit APPLICABILITY
- Architecture-specific scenarios (S03) exclude GraphQL
- Classification-specific scenarios (S07) exclude public
- No import cycles or errors

Note: 14-file modification warning acknowledged - changes are repetitive APPLICABILITY additions, low risk.
</success_criteria>

<output>
After completion, create `.planning/phases/06-adaptive-test-execution/06-02-SUMMARY.md`
</output>
