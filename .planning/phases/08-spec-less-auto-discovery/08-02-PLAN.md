---
phase: 08-spec-less-auto-discovery
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - api_pentest/core/kiterunner_adapter.py
  - api_pentest/core/endpoint_wordlist.py
  - api_pentest/core/endpoint_fuzzer.py
  - api_pentest/core/__init__.py
autonomous: true

must_haves:
  truths:
    - "KiterunnerAdapter detects if Kiterunner binary is installed via shutil.which"
    - "KiterunnerAdapter runs Kiterunner via subprocess with JSON output and yields discovered endpoints"
    - "EndpointFuzzer falls back to built-in wordlist when Kiterunner is unavailable"
    - "Discovered endpoints are converted to Endpoint model objects"
  artifacts:
    - path: "api_pentest/core/kiterunner_adapter.py"
      provides: "KiterunnerAdapter subprocess wrapper"
      exports: ["KiterunnerAdapter", "KiterunnerNotFoundError"]
      min_lines: 80
    - path: "api_pentest/core/endpoint_wordlist.py"
      provides: "Built-in API endpoint wordlist"
      exports: ["API_ENDPOINTS"]
      min_lines: 150
    - path: "api_pentest/core/endpoint_fuzzer.py"
      provides: "EndpointFuzzer with Kiterunner integration and fallback"
      exports: ["EndpointFuzzer"]
      min_lines: 100
  key_links:
    - from: "api_pentest/core/endpoint_fuzzer.py"
      to: "api_pentest/core/kiterunner_adapter.py"
      via: "KiterunnerAdapter import"
      pattern: "from api_pentest\\.core\\.kiterunner_adapter import"
    - from: "api_pentest/core/endpoint_fuzzer.py"
      to: "api_pentest/core/endpoint_wordlist.py"
      via: "API_ENDPOINTS fallback"
      pattern: "from api_pentest\\.core\\.endpoint_wordlist import API_ENDPOINTS"
    - from: "api_pentest/core/endpoint_fuzzer.py"
      to: "api_pentest/core/models.py"
      via: "Endpoint model creation"
      pattern: "Endpoint\\("
---

<objective>
Build EndpointFuzzer with Kiterunner integration and built-in wordlist fallback.

Purpose: When spec discovery fails (08-01), the toolkit needs a second stage that discovers API endpoints via fuzzing. Kiterunner is the preferred tool, but a built-in wordlist ensures the toolkit works even without Kiterunner installed.

Output: Three new modules - KiterunnerAdapter for subprocess invocation, endpoint_wordlist.py with built-in paths, and EndpointFuzzer that orchestrates fuzzing with graceful fallback.
</objective>

<execution_context>
@/home/abdulr7man/.claude/get-shit-done/workflows/execute-plan.md
@/home/abdulr7man/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-spec-less-auto-discovery/08-RESEARCH.md
@api_pentest/core/models.py (Endpoint, EndpointClassification)
@api_pentest/core/api_discovery.py (RequestBudget)
@api_pentest/core/http_client.py (PentestHttpClient)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KiterunnerAdapter subprocess wrapper</name>
  <files>api_pentest/core/kiterunner_adapter.py</files>
  <action>
Create new module `api_pentest/core/kiterunner_adapter.py` with:

1. **KiterunnerNotFoundError exception class** (inherits from Exception)

2. **KiterunnerAdapter class** with:
   - Constructor: `__init__(self, timeout: int = 300)`
   - Store timeout
   - Detect binary: `self.kr_path = shutil.which("kr") or shutil.which("kiterunner")`

3. **is_available() method** returning `bool`:
   - Return `self.kr_path is not None`

4. **scan(target: str, wordlist: str | None = None) method** as generator yielding `dict`:
   - If not is_available(), raise KiterunnerNotFoundError with descriptive message
   - Build command list:
     ```python
     cmd = [
         self.kr_path, "scan",
         target,
         "-o", "json",     # JSON output
         "-x", "5",        # max 5 connections per host
     ]
     ```
   - Add wordlist flag if provided:
     - If wordlist ends with ".kite": `cmd.extend(["-w", wordlist])`
     - Else: `cmd.extend(["-w", wordlist])`
   - If no wordlist, use Assetnote remote: `cmd.extend(["-A", "apiroutes-210228:5000"])`
   - Run subprocess:
     ```python
     result = subprocess.run(
         cmd,
         capture_output=True,
         text=True,
         timeout=self.timeout,
     )
     ```
   - Parse JSON output from stdout (line by line):
     ```python
     for line in result.stdout.strip().split("\n"):
         if line:
             try:
                 yield json.loads(line)
             except json.JSONDecodeError:
                 continue  # Skip non-JSON lines
     ```
   - Handle subprocess.TimeoutExpired by logging warning and returning empty
   - Handle other subprocess errors gracefully

5. Add module docstring and logging via `logger = logging.getLogger(__name__)`

Import requirements: `import json`, `import shutil`, `import subprocess`, `import logging`
  </action>
  <verify>
```bash
python -c "from api_pentest.core.kiterunner_adapter import KiterunnerAdapter, KiterunnerNotFoundError; a = KiterunnerAdapter(); print(f'Available: {a.is_available()}')"
```
  </verify>
  <done>KiterunnerAdapter class exists with is_available() and scan() methods</done>
</task>

<task type="auto">
  <name>Task 2: Create built-in endpoint wordlist</name>
  <files>api_pentest/core/endpoint_wordlist.py</files>
  <action>
Create new module `api_pentest/core/endpoint_wordlist.py` with:

1. Module docstring explaining this is the fallback when Kiterunner is unavailable

2. **API_ENDPOINTS constant** - list of ~200 common API paths (curated from SecLists and common patterns):
   ```python
   API_ENDPOINTS = [
       # API versioning
       "/api",
       "/api/v1",
       "/api/v2",
       "/api/v3",
       "/v1",
       "/v2",
       "/v3",
       # Authentication
       "/auth",
       "/api/auth",
       "/login",
       "/api/login",
       "/signin",
       "/api/signin",
       "/logout",
       "/api/logout",
       "/register",
       "/api/register",
       "/signup",
       "/api/signup",
       "/token",
       "/api/token",
       "/oauth/token",
       "/api/oauth/token",
       "/refresh",
       "/api/refresh",
       "/password",
       "/api/password",
       "/forgot-password",
       "/reset-password",
       # Users/Accounts
       "/users",
       "/api/users",
       "/user",
       "/api/user",
       "/accounts",
       "/api/accounts",
       "/account",
       "/api/account",
       "/profile",
       "/api/profile",
       "/me",
       "/api/me",
       # Common resources
       "/items",
       "/api/items",
       "/products",
       "/api/products",
       "/orders",
       "/api/orders",
       "/messages",
       "/api/messages",
       "/posts",
       "/api/posts",
       "/comments",
       "/api/comments",
       "/files",
       "/api/files",
       "/uploads",
       "/api/uploads",
       "/images",
       "/api/images",
       "/documents",
       "/api/documents",
       # Admin/Management
       "/admin",
       "/api/admin",
       "/dashboard",
       "/api/dashboard",
       "/settings",
       "/api/settings",
       "/config",
       "/api/config",
       "/manage",
       "/api/manage",
       # Health/Status/Debug
       "/health",
       "/api/health",
       "/healthcheck",
       "/api/healthcheck",
       "/status",
       "/api/status",
       "/ping",
       "/api/ping",
       "/version",
       "/api/version",
       "/info",
       "/api/info",
       "/debug",
       "/api/debug",
       "/.env",
       "/env",
       # Spring Boot Actuator
       "/actuator",
       "/actuator/health",
       "/actuator/info",
       "/actuator/env",
       "/actuator/beans",
       "/actuator/mappings",
       "/actuator/heapdump",
       "/actuator/threaddump",
       # Common frameworks
       "/metrics",
       "/api/metrics",
       "/graphql",
       "/api/graphql",
       "/query",
       "/api/query",
       # Search/Query
       "/search",
       "/api/search",
       "/find",
       "/api/find",
       "/filter",
       "/api/filter",
       # CRUD common patterns
       "/create",
       "/read",
       "/update",
       "/delete",
       "/list",
       "/get",
       "/set",
       "/add",
       "/remove",
       # Notifications
       "/notifications",
       "/api/notifications",
       "/alerts",
       "/api/alerts",
       # Webhooks
       "/webhooks",
       "/api/webhooks",
       "/hooks",
       "/api/hooks",
       "/callback",
       "/api/callback",
       # Payment/Billing
       "/payment",
       "/api/payment",
       "/payments",
       "/api/payments",
       "/billing",
       "/api/billing",
       "/invoice",
       "/api/invoice",
       "/checkout",
       "/api/checkout",
       # Reports/Analytics
       "/reports",
       "/api/reports",
       "/analytics",
       "/api/analytics",
       "/stats",
       "/api/stats",
       # Export/Import
       "/export",
       "/api/export",
       "/import",
       "/api/import",
       "/download",
       "/api/download",
       "/upload",
       "/api/upload",
       # Internal/Private
       "/internal",
       "/api/internal",
       "/private",
       "/api/private",
       "/secret",
       "/api/secret",
       # Batch operations
       "/batch",
       "/api/batch",
       "/bulk",
       "/api/bulk",
       # Misc common
       "/data",
       "/api/data",
       "/resources",
       "/api/resources",
       "/assets",
       "/api/assets",
       "/public",
       "/api/public",
       # Common ID patterns
       "/users/1",
       "/api/users/1",
       "/items/1",
       "/api/items/1",
   ]
   ```

3. **HTTP_METHODS constant** for methods to try:
   ```python
   HTTP_METHODS = ["GET", "POST", "PUT", "DELETE", "PATCH"]
   ```
  </action>
  <verify>
```bash
python -c "from api_pentest.core.endpoint_wordlist import API_ENDPOINTS, HTTP_METHODS; print(f'Endpoints: {len(API_ENDPOINTS)}, Methods: {len(HTTP_METHODS)}')"
```
  </verify>
  <done>endpoint_wordlist.py exists with API_ENDPOINTS list containing ~200 common paths</done>
</task>

<task type="auto">
  <name>Task 3: Create EndpointFuzzer orchestrator with fallback</name>
  <files>api_pentest/core/endpoint_fuzzer.py, api_pentest/core/__init__.py</files>
  <action>
Create new module `api_pentest/core/endpoint_fuzzer.py` with:

1. **EndpointFuzzer class** with:
   - Constructor: `__init__(self, base_url: str, http_client, budget: RequestBudget)`
   - Store base_url (strip trailing slash), http_client, budget
   - Create KiterunnerAdapter instance: `self.kr = KiterunnerAdapter()`

2. **fuzz() method** returning `list[Endpoint]`:
   - Check if Kiterunner is available: `self.kr.is_available()`
   - If available:
     - Log info "Using Kiterunner for endpoint discovery"
     - Call `self._fuzz_with_kiterunner()`
   - If not available:
     - Log warning "Kiterunner not found, falling back to built-in wordlist"
     - Call `self._fuzz_with_wordlist()`

3. **_fuzz_with_kiterunner() method** returning `list[Endpoint]`:
   - Call `self.kr.scan(self.base_url)` and collect results
   - Convert each result to Endpoint via `_discovered_to_endpoint()`
   - Filter out duplicates by (method, url)
   - Validate discovered endpoints with follow-up request (use budget)
   - Return list of validated Endpoint objects

4. **_fuzz_with_wordlist() method** returning `list[Endpoint]`:
   - Import API_ENDPOINTS from endpoint_wordlist
   - For each path in API_ENDPOINTS:
     - Check budget.can_request() - break if exhausted
     - Make GET request to base_url + path
     - Call budget.record()
     - If response status is 200 and content-type suggests API response:
       - Create Endpoint object with method="GET", url=base_url+path
       - Add to results
   - Log info with count of discovered endpoints
   - Return list of Endpoint objects

5. **_discovered_to_endpoint(discovered: dict) method** returning `Endpoint`:
   - Extract method (default "GET"), path from discovered dict
   - Handle Kiterunner JSON output format (may have "method", "path", "status", "length" fields)
   - Create Endpoint:
     ```python
     Endpoint(
         method=method.upper(),
         url=f"{self.base_url}{path}",
         name=f"{method.upper()} {path}",
         classification=EndpointClassification.PROTECTED,  # Conservative default
         classification_reason="Discovered via fuzzing",
     )
     ```

6. **_is_api_response(evidence: Evidence) method** returning `bool`:
   - Check content-type header contains "application/json", "application/xml", "text/json", "text/xml"
   - Check response body looks like JSON (starts with { or [) or XML (starts with <)
   - Return True if looks like API response

Update `api_pentest/core/__init__.py` to export:
```python
from api_pentest.core.kiterunner_adapter import KiterunnerAdapter, KiterunnerNotFoundError
from api_pentest.core.endpoint_wordlist import API_ENDPOINTS, HTTP_METHODS
from api_pentest.core.endpoint_fuzzer import EndpointFuzzer
```
  </action>
  <verify>
```bash
python -c "from api_pentest.core.endpoint_fuzzer import EndpointFuzzer; from api_pentest.core import KiterunnerAdapter, API_ENDPOINTS; print('Import OK')"
```
  </verify>
  <done>EndpointFuzzer exists with fuzz() method that uses Kiterunner when available, falls back to built-in wordlist when not</done>
</task>

</tasks>

<verification>
1. Run import tests for all new modules
2. Verify KiterunnerAdapter.is_available() returns correct value based on binary presence
3. Verify API_ENDPOINTS contains at least 150 entries
4. Verify EndpointFuzzer can be instantiated and logs appropriate fallback message
5. Run existing tests to ensure no regressions: `python -m pytest tests/ -v --tb=short` (if tests exist)
</verification>

<success_criteria>
- KiterunnerAdapter wraps subprocess and handles Kiterunner CLI invocation
- KiterunnerAdapter detects binary availability via shutil.which("kr")
- endpoint_wordlist.py contains ~200 curated API paths
- EndpointFuzzer orchestrates discovery with Kiterunner or fallback
- Discovered endpoints converted to Endpoint model with PROTECTED classification
- Graceful fallback when Kiterunner not installed (DISC-10 requirement)
- All modules exportable from api_pentest.core
</success_criteria>

<output>
After completion, create `.planning/phases/08-spec-less-auto-discovery/08-02-SUMMARY.md`
</output>
