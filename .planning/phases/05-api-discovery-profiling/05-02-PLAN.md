---
phase: 05-api-discovery-profiling
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - api_pentest/core/api_discovery.py
  - api_pentest/runner.py
autonomous: true

must_haves:
  truths:
    - "Running discovery against VAmPI produces a profile with auth_scheme=Bearer, architecture=REST, and correct endpoint count"
    - "Profile is saved as JSON file in profiles/ directory and can be loaded back"
    - "Profile includes content hash from spec + base_url for staleness detection"
    - "Cached profile is reused when hash matches (no re-discovery)"
    - "Stale profile triggers re-discovery automatically"
    - "Profile aggregates Phase 2 response pattern count, Phase 3 classifications, and Phase 4 prerequisite results"
    - "Discovery runs after prerequisite detection and before scenario loop in runner"
  artifacts:
    - path: "api_pentest/core/api_discovery.py"
      provides: "ApiProfiler, ApiProfile, compute_content_hash, save_profile, load_profile, is_profile_stale"
      contains: "class ApiProfiler"
    - path: "api_pentest/core/api_discovery.py"
      provides: "ApiProfile dataclass with all profile fields"
      contains: "class ApiProfile"
    - path: "api_pentest/runner.py"
      provides: "Discovery step wired into run() after prereq detection"
      contains: "ApiProfiler"
  key_links:
    - from: "api_pentest/core/api_discovery.py ApiProfiler.discover()"
      to: "AuthDetector.detect() and ArchitectureDetector.detect()"
      via: "calling both detectors and aggregating results"
      pattern: "auth_detector\\.detect|architecture_detector\\.detect"
    - from: "api_pentest/core/api_discovery.py save_profile()"
      to: "profiles/ directory"
      via: "json.dump with dataclasses.asdict"
      pattern: "json\\.dump.*asdict"
    - from: "api_pentest/runner.py PentestRunner.run()"
      to: "api_pentest/core/api_discovery.py ApiProfiler"
      via: "import and call discover() or load cached profile"
      pattern: "from api_pentest\\.core\\.api_discovery import"
    - from: "api_pentest/core/api_discovery.py compute_content_hash()"
      to: "hashlib.sha256"
      via: "hash of spec JSON + base_url for staleness"
      pattern: "hashlib\\.sha256"
---

<objective>
Build the ApiProfiler that orchestrates detection, aggregates all discovery results (auth, architecture, classifications, response patterns, prerequisites) into a unified ApiProfile, persists it as JSON with staleness detection, and wire the entire discovery step into runner.py.

Purpose: The profile is the single source of truth about a target API -- it feeds Phase 6 (adaptive test selection) and Phase 7 (validation). Profile caching avoids redundant discovery on repeat scans.

Output: ApiProfiler and ApiProfile classes appended to `api_discovery.py`, runner.py modified with discovery step after prerequisites.
</objective>

<execution_context>
@/home/abdulr7man/.claude/get-shit-done/workflows/execute-plan.md
@/home/abdulr7man/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-api-discovery-profiling/05-CONTEXT.md
@.planning/phases/05-api-discovery-profiling/05-RESEARCH.md
@.planning/phases/05-api-discovery-profiling/05-01-SUMMARY.md
@api_pentest/core/api_discovery.py
@api_pentest/core/models.py
@api_pentest/runner.py
@api_pentest/core/response_patterns.py
@api_pentest/core/endpoint_classifier.py
@api_pentest/core/prerequisite_detector.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build ApiProfile dataclass, ApiProfiler orchestrator, and profile persistence</name>
  <files>api_pentest/core/api_discovery.py</files>
  <action>
Append to `api_pentest/core/api_discovery.py` (which already has AuthDetector, ArchitectureDetector, RequestBudget from Plan 01):

1. **PROFILE_VERSION constant**: Set to `1`. Increment on breaking schema changes.

2. **ApiProfile dataclass** (the profile schema):
   - `profile_version: int = PROFILE_VERSION`
   - `created_at: str = ""` (ISO 8601 timestamp)
   - `content_hash: str = ""` (SHA-256 of spec + base_url)
   - `base_url: str = ""`
   - `input_format: str = ""` (e.g. "openapi_3.0", "swagger_2.0", "postman_v2.1")
   - `endpoint_count: int = 0`
   - `auth_schemes: list[dict] = field(default_factory=list)` (serialized DetectedAuthScheme list)
   - `architecture_type: str = ""` (ArchitectureType.value)
   - `architecture_details: dict = field(default_factory=dict)`
   - `classifications: dict = field(default_factory=dict)` (e.g. {"public": 3, "protected": 7, "auth-endpoint": 1})
   - `response_pattern_count: int = 0`
   - `server_fingerprint: str = ""`
   - `content_types_observed: list[str] = field(default_factory=list)`
   - `security_headers: dict = field(default_factory=dict)`
   - `prerequisites: dict = field(default_factory=dict)` (e.g. {"rate_limiting": {"status": "ABSENT", "reason": "..."}})
   - `gaps: list[str] = field(default_factory=list)` (discovery gaps logged as strings)

3. **compute_content_hash(spec_data: dict | None, base_url: str) -> str**:
   - `json.dumps(spec_data, sort_keys=True)` if spec_data else ""
   - Append `|{base_url}`
   - Return `hashlib.sha256(content.encode("utf-8")).hexdigest()`

4. **save_profile(profile: ApiProfile, profiles_dir: str, target_name: str) -> Path**:
   - Create `profiles_dir` with `parents=True, exist_ok=True`
   - Sanitize `target_name`: replace non-alphanumeric chars (except hyphen/dot) with hyphen
   - Write `{target_name}.profile.json` using `json.dump(asdict(profile), f, indent=2, default=str)`
   - Return the file Path

5. **load_profile(file_path: Path) -> ApiProfile | None**:
   - Return None if file doesn't exist
   - Parse JSON, check `profile_version` matches PROFILE_VERSION, return None if incompatible
   - Return `ApiProfile(**data)`

6. **is_profile_stale(profile: ApiProfile, current_hash: str) -> bool**:
   - Return `profile.content_hash != current_hash`

7. **derive_target_name(input_file: str, base_url: str) -> str**:
   - If input_file provided: derive from filename (strip extension, sanitize)
   - If no input_file: derive from base_url hostname + port (e.g. "localhost-5000")
   - Sanitize: replace non-alphanumeric/hyphen/dot with hyphen, strip trailing hyphens

8. **ApiProfiler class** (orchestrates the full discovery):
   - `__init__(self, openapi_spec, http_client, endpoints, config, response_learner=None, prerequisite_results=None)`:
     - Store all params
     - Extract `base_url` from config or first endpoint URL
     - Create shared `RequestBudget(max_requests=30)`
     - Create `AuthDetector(spec, http_client, endpoints, base_url, budget)`
     - Create `ArchitectureDetector(spec, http_client, base_url, budget)`
   - `discover() -> ApiProfile`:
     - Run `auth_detector.detect()` -> list of DetectedAuthScheme
     - Run `architecture_detector.detect()` -> (type, details)
     - Collect server info from any evidence gathered during probing via `architecture_detector._collect_server_info()`
     - Aggregate endpoint classifications: count endpoints per classification enum value
     - Count response patterns from `response_learner.patterns` if available
     - Serialize prerequisite results if available
     - Build and return `ApiProfile` with all fields populated
     - Log discovery summary at INFO level
     - Record gaps for anything incomplete (e.g. "Auth probing skipped: budget exhausted")
   - `load_cached_profile() -> ApiProfile | None`:
     - Compute `target_name` from config
     - Build expected file path in `profiles/` directory
     - Call `load_profile()`, return result
   - `is_stale(profile: ApiProfile) -> bool`:
     - Compute current content hash
     - Call `is_profile_stale(profile, current_hash)`
   - `save(profile: ApiProfile) -> Path`:
     - Compute target_name, call `save_profile()`

Pitfalls to handle (from RESEARCH.md):
- Use `default=str` in json.dumps to handle Enum values and other non-serializable types
- Normalize DetectedAuthScheme to dict using a `to_dict()` method or manual conversion (Enum .value for scheme_type)
- Handle missing response_learner or prerequisite_results gracefully (produce partial profile, log gap)
- created_at uses `datetime.now(timezone.utc).isoformat()`
  </action>
  <verify>
Run: `python -c "
from api_pentest.core.api_discovery import ApiProfiler, ApiProfile, compute_content_hash, save_profile, load_profile, is_profile_stale, PROFILE_VERSION
print('All profile classes import OK')
print('PROFILE_VERSION:', PROFILE_VERSION)

# Test content hash
h1 = compute_content_hash({'openapi': '3.0'}, 'http://localhost:5000')
h2 = compute_content_hash({'openapi': '3.0'}, 'http://localhost:5000')
h3 = compute_content_hash({'openapi': '3.0'}, 'http://localhost:5001')
assert h1 == h2, 'Same input should produce same hash'
assert h1 != h3, 'Different base_url should produce different hash'
print('Content hash test PASSED')

# Test staleness
profile = ApiProfile(content_hash=h1)
assert not is_profile_stale(profile, h1), 'Same hash should not be stale'
assert is_profile_stale(profile, h3), 'Different hash should be stale'
print('Staleness test PASSED')
"` -- all assertions pass.

Run: `python -c "
import tempfile, os
from pathlib import Path
from api_pentest.core.api_discovery import ApiProfile, save_profile, load_profile, PROFILE_VERSION
profile = ApiProfile(profile_version=PROFILE_VERSION, base_url='http://test', endpoint_count=5, architecture_type='REST')
with tempfile.TemporaryDirectory() as tmpdir:
    path = save_profile(profile, tmpdir, 'test-api')
    assert path.exists(), 'Profile file should exist'
    loaded = load_profile(path)
    assert loaded is not None, 'Should load successfully'
    assert loaded.base_url == 'http://test'
    assert loaded.endpoint_count == 5
    print('Save/load round-trip test PASSED')
"` -- round-trip serialization works.
  </verify>
  <done>ApiProfile dataclass captures all discovery fields. compute_content_hash produces deterministic SHA-256. save_profile/load_profile round-trip JSON correctly. is_profile_stale detects content changes. ApiProfiler orchestrates AuthDetector + ArchitectureDetector and aggregates results.</done>
</task>

<task type="auto">
  <name>Task 2: Wire discovery into runner.py after prerequisite detection</name>
  <files>api_pentest/runner.py</files>
  <action>
Modify `api_pentest/runner.py` to add the discovery step:

1. **Add import** at top of file (with existing imports):
   ```python
   from api_pentest.core.api_discovery import ApiProfiler
   ```

2. **Add `self.api_profile` attribute** in `__init__`:
   - Add `self.api_profile = None` alongside existing `self.prerequisite_results`

3. **Add discovery step** in `run()` method, AFTER prerequisite detection and BEFORE the scenario loop (after `self.prerequisite_results = prereq_checker.check_all()`):
   ```python
   # Discover API characteristics and build profile
   profiler = ApiProfiler(
       openapi_spec=self._get_raw_spec(),
       http_client=self.http,
       endpoints=self.endpoints,
       config=self.config,
       response_learner=self.response_learner,
       prerequisite_results=self.prerequisite_results,
   )

   # Check for cached profile first
   cached = profiler.load_cached_profile()
   if cached and not profiler.is_stale(cached):
       self.api_profile = cached
       print(f"{Fore.CYAN}API profile loaded from cache{Style.RESET_ALL}")
   else:
       self.api_profile = profiler.discover()
       profiler.save(self.api_profile)
       print(f"{Fore.CYAN}API discovery complete - profile saved{Style.RESET_ALL}")

   # Print discovery summary
   if self.api_profile:
       schemes = self.api_profile.auth_schemes
       arch = self.api_profile.architecture_type
       ep_count = self.api_profile.endpoint_count
       print(f"  Auth: {', '.join(s.get('scheme_type', '?') for s in schemes) if schemes else 'none detected'}")
       print(f"  Architecture: {arch or 'unknown'}")
       print(f"  Endpoints: {ep_count}")
   ```

4. **Do NOT modify** scenario.setup() call or any other existing code. The api_profile is stored on self for future Phase 6 integration. No scenarios consume it yet.

Flow after modification:
parse_input -> init_oauth -> init_http -> learn response patterns -> classify endpoints -> detect prerequisites -> **discover API profile** -> run scenarios
  </action>
  <verify>
Run: `python -c "from api_pentest.runner import PentestRunner; r = PentestRunner({}); assert hasattr(r, 'api_profile'); print('Runner has api_profile attribute')"` -- attribute exists.

Run: `python -c "
import ast, inspect
from api_pentest.runner import PentestRunner
source = inspect.getsource(PentestRunner.run)
assert 'ApiProfiler' in source or 'profiler' in source, 'run() should reference ApiProfiler'
assert 'load_cached_profile' in source, 'run() should check for cached profile'
print('Runner integration verified in source')
"` -- discovery code present in run() method.

Run: `python -c "from api_pentest.core.api_discovery import ApiProfiler; from api_pentest.runner import PentestRunner; print('Both import without circular dependency')"` -- no circular imports.
  </verify>
  <done>Discovery step is wired into runner.py after prerequisite detection and before scenario loop. Profile is cached and reused when hash matches. Discovery summary printed to console. No changes to scenario execution -- api_profile is stored for Phase 6 consumption.</done>
</task>

</tasks>

<verification>
1. `python -c "from api_pentest.core.api_discovery import ApiProfiler, ApiProfile, AuthDetector, ArchitectureDetector"` -- all classes importable
2. `python -c "from api_pentest.runner import PentestRunner"` -- runner imports cleanly (no circular deps)
3. Content hash is deterministic: same spec + base_url -> same hash
4. Profile save/load round-trips correctly through JSON
5. Runner.run() contains discovery step between prerequisites and scenarios
6. Stale profile triggers re-discovery, fresh profile is loaded from cache
</verification>

<success_criteria>
- ApiProfile dataclass captures: auth_schemes, architecture_type, classifications, response_pattern_count, prerequisites, server_fingerprint, content_types, security_headers, gaps
- ApiProfiler.discover() calls AuthDetector + ArchitectureDetector and produces complete ApiProfile
- Profile is saved to profiles/{target_name}.profile.json
- Profile loaded from cache when content hash matches
- Runner flow: parse -> oauth -> http -> learn -> classify -> prereq -> **discover** -> scenarios
- No regression: existing scenarios run unchanged after runner modification
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-discovery-profiling/05-02-SUMMARY.md`
</output>
