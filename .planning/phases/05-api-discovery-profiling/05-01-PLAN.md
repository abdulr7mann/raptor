---
phase: 05-api-discovery-profiling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api_pentest/core/api_discovery.py
autonomous: true

must_haves:
  truths:
    - "AuthDetector extracts Bearer auth scheme from VAmPI OpenAPI 3.x spec"
    - "AuthDetector maps Swagger 2.0 type:'basic' correctly (not just OpenAPI 3.x type:'http')"
    - "AuthDetector falls back to probing when no spec or spec lacks security info"
    - "WWW-Authenticate header parsing identifies Bearer, Basic, and OAuth scheme names"
    - "ArchitectureDetector identifies REST from OpenAPI/Swagger spec signals"
    - "ArchitectureDetector probes common GraphQL endpoints and attempts introspection"
    - "GraphQL introspection POST is allowed as read-only exception to no-mutation rule"
    - "RequestBudget tracks request count across all detection subsystems and stops at cap"
  artifacts:
    - path: "api_pentest/core/api_discovery.py"
      provides: "AuthDetector, ArchitectureDetector, RequestBudget, enums, dataclasses"
      contains: "class AuthDetector"
    - path: "api_pentest/core/api_discovery.py"
      provides: "Architecture detection with GraphQL introspection"
      contains: "class ArchitectureDetector"
    - path: "api_pentest/core/api_discovery.py"
      provides: "Request budget tracking"
      contains: "class RequestBudget"
  key_links:
    - from: "api_pentest/core/api_discovery.py AuthDetector._extract_from_spec"
      to: "OpenAPI spec dict (securityDefinitions or components.securitySchemes)"
      via: "dict traversal matching both Swagger 2.0 and OpenAPI 3.x locations"
      pattern: "securityDefinitions|components.*securitySchemes"
    - from: "api_pentest/core/api_discovery.py AuthDetector._probe_unauthenticated"
      to: "PentestHttpClient.request()"
      via: "sending unauthenticated requests to representative endpoints"
      pattern: "self\\.http\\.request"
    - from: "api_pentest/core/api_discovery.py ArchitectureDetector._probe_graphql"
      to: "PentestHttpClient.request()"
      via: "POST introspection query to GraphQL endpoints"
      pattern: "GRAPHQL_INTROSPECTION_QUERY"
---

<objective>
Build the core detection engine for API discovery: AuthDetector (spec extraction + active probing), ArchitectureDetector (REST/GraphQL/SOAP detection + GraphQL introspection), and RequestBudget (shared request counter).

Purpose: These detectors produce the raw discovery data that the ApiProfiler (Plan 02) aggregates into a reusable profile. Auth scheme detection is the highest-value output -- it feeds Phase 6 test selection and Phase 7 validation.

Output: `api_pentest/core/api_discovery.py` containing AuthDetector, ArchitectureDetector, RequestBudget, plus supporting enums (AuthSchemeType, ArchitectureType) and dataclasses (DetectedAuthScheme).
</objective>

<execution_context>
@/home/abdulr7man/.claude/get-shit-done/workflows/execute-plan.md
@/home/abdulr7man/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-api-discovery-profiling/05-CONTEXT.md
@.planning/phases/05-api-discovery-profiling/05-RESEARCH.md
@api_pentest/core/models.py
@api_pentest/core/http_client.py
@api_pentest/core/prerequisite_detector.py
@api_pentest/core/openapi_parser.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create enums, dataclasses, AuthDetector with spec extraction and active probing</name>
  <files>api_pentest/core/api_discovery.py</files>
  <action>
Create `api_pentest/core/api_discovery.py` with:

1. **Enums** (follow models.py pattern):
   - `AuthSchemeType(Enum)`: BEARER, API_KEY, BASIC, OAUTH2, SESSION_COOKIE, OPENID_CONNECT, UNKNOWN
   - `ArchitectureType(Enum)`: REST, GRAPHQL, SOAP, GRPC_WEB, HYBRID, UNKNOWN

2. **DetectedAuthScheme dataclass**:
   - `scheme_type: AuthSchemeType`
   - `name: str` (e.g. "bearerAuth", "api_key")
   - `source: str` ("spec" or "probe")
   - `details: dict` (scheme-specific: apiKey has "in"/"name", bearer has "format", oauth2 has "flows")
   - `endpoints: list[str]` (which endpoints use this scheme, e.g. "POST /books/v1")

3. **RequestBudget class** (shared counter):
   - `__init__(self, max_requests: int = 30)` with `self.used = 0`
   - `can_request() -> bool`, `record()`, `remaining` property
   - All detector subsystems share one RequestBudget instance

4. **AuthDetector class**:
   - `__init__(self, openapi_spec: dict | None, http_client, endpoints: list, base_url: str, budget: RequestBudget)`
   - `detect() -> list[DetectedAuthScheme]`: Two-tier strategy:
     - Tier 1: `_extract_from_spec()` -- check both `securityDefinitions` (Swagger 2.0) and `components.securitySchemes` (OpenAPI 3.x)
     - Tier 2: `_probe_unauthenticated()` -- only if Tier 1 found nothing. Send unauthenticated requests to 3-5 representative GET endpoints, parse 401/403 responses
   - `_map_spec_type(scheme_def: dict) -> AuthSchemeType`: Handle BOTH formats:
     - OpenAPI 3.x: `type:"http"` + `scheme:"bearer"` -> BEARER; `type:"http"` + `scheme:"basic"` -> BASIC
     - OpenAPI 3.x: `type:"apiKey"` -> API_KEY; `type:"oauth2"` -> OAUTH2; `type:"openIdConnect"` -> OPENID_CONNECT
     - Swagger 2.0: `type:"basic"` (direct, no scheme field) -> BASIC
   - `_extract_scheme_details(scheme_def: dict) -> dict`: Pull relevant details (bearerFormat, apiKey in/name, oauth2 flows)
   - `_find_endpoints_using_scheme(scheme_name: str) -> list[str]`: Check per-operation `security` array, fall back to global `security`. Format: "METHOD /path"
   - `_select_probe_endpoints(count: int = 5) -> list`: Select representative endpoints, prefer GET, mix paths
   - `_probe_unauthenticated() -> list[DetectedAuthScheme]`: For each selected endpoint, send unauthenticated request (GET only or HEAD for non-safe methods), check budget before each request. On 401/403: parse WWW-Authenticate, detect session cookies from Set-Cookie
   - `_parse_www_authenticate(evidence) -> list[DetectedAuthScheme]`: Regex match known scheme names (Bearer, Basic, Digest, OAuth) per RFC 7235. Extract realm if present. Keep parser simple -- match keywords, don't try full RFC compliance
   - `_detect_session_cookie(evidence) -> DetectedAuthScheme | None`: Check for Set-Cookie header with session-like names (session, sid, JSESSIONID, connect.sid)
   - `_infer_from_status(evidence) -> list[DetectedAuthScheme]`: When no WWW-Authenticate header but got 401/403, return UNKNOWN scheme with details noting the status code

Key pitfalls to handle (from RESEARCH.md):
- Swagger 2.0 uses `type:"basic"` directly -- do NOT require `scheme` field for this case
- Empty spec or missing security sections should return empty list (not crash)
- Budget check before every HTTP request
- Only probe with safe methods (GET, HEAD, OPTIONS) -- never POST/PUT/DELETE for auth probing
  </action>
  <verify>
Run: `python -c "from api_pentest.core.api_discovery import AuthDetector, AuthSchemeType, DetectedAuthScheme, RequestBudget; print('AuthDetector imports OK')"` -- should print without errors.

Run: `python -c "
from api_pentest.core.api_discovery import AuthDetector, AuthSchemeType, RequestBudget
# Test spec extraction with VAmPI-like spec
spec = {'components': {'securitySchemes': {'bearerAuth': {'type': 'http', 'scheme': 'bearer', 'bearerFormat': 'JWT'}}}, 'security': [{'bearerAuth': []}], 'paths': {'/me': {'get': {}}}}
budget = RequestBudget()
detector = AuthDetector(openapi_spec=spec, http_client=None, endpoints=[], base_url='http://localhost:5000', budget=budget)
schemes = detector._extract_from_spec()
assert len(schemes) == 1
assert schemes[0].scheme_type == AuthSchemeType.BEARER
assert schemes[0].source == 'spec'
assert schemes[0].name == 'bearerAuth'
print('Spec extraction test PASSED')

# Test Swagger 2.0 basic auth mapping
swagger_spec = {'securityDefinitions': {'basic_auth': {'type': 'basic'}}, 'paths': {}}
detector2 = AuthDetector(openapi_spec=swagger_spec, http_client=None, endpoints=[], base_url='http://localhost', budget=budget)
schemes2 = detector2._extract_from_spec()
assert len(schemes2) == 1
assert schemes2[0].scheme_type == AuthSchemeType.BASIC
print('Swagger 2.0 basic auth test PASSED')
"` -- both assertions should pass.
  </verify>
  <done>AuthDetector correctly extracts auth schemes from OpenAPI 3.x and Swagger 2.0 specs. WWW-Authenticate parser handles Bearer, Basic, OAuth keywords. RequestBudget tracks and limits requests.</done>
</task>

<task type="auto">
  <name>Task 2: Build ArchitectureDetector with GraphQL introspection and request budget integration</name>
  <files>api_pentest/core/api_discovery.py</files>
  <action>
Add to `api_pentest/core/api_discovery.py`:

1. **GRAPHQL_INTROSPECTION_QUERY constant**: The standard top-level introspection query from RESEARCH.md Pattern 4. Use `locations` field (modern) not legacy `onOperation`/`onFragment`/`onField`. Include queryType, mutationType, subscriptionType, types (with fields, args, inputFields, interfaces, enumValues, possibleTypes), and directives.

2. **ArchitectureDetector class**:
   - `GRAPHQL_PATHS = ["/graphql", "/api/graphql", "/gql", "/query"]`
   - `__init__(self, openapi_spec: dict | None, http_client, base_url: str, budget: RequestBudget)`
   - `detect() -> tuple[ArchitectureType, dict]`: Collect signals from spec + probing:
     - Spec signals: if `openapi` or `swagger` key present -> `rest = True`. If any path contains a GraphQL path -> `graphql = True`
     - Active probing: call `_probe_graphql()` to check common endpoints
     - Return logic: multiple signals -> HYBRID, single signal -> that type, no signals -> UNKNOWN
   - `_probe_graphql() -> dict | None`: For each path in GRAPHQL_PATHS:
     - Check budget before each request
     - Step 1: POST introspection query with `Content-Type: application/json`. This is the read-only exception to the no-mutation rule
     - On 200 response: parse JSON. If `data.__schema` exists -> introspection available, extract summary (queryType name, mutationType name, subscriptionType name, type_count, directive_count). If `errors` key -> endpoint exists but introspection disabled
     - Step 2 fallback: GET with `?query={__typename}`. If returns 200 with `data` key -> GraphQL detected without introspection
     - Return dict with endpoint, introspection_available, and summary stats, or None if no GraphQL found
     - Handle JSONDecodeError gracefully (continue to next path)
   - `_collect_server_info(evidence_list: list) -> dict`: Extract from all evidence gathered during probing:
     - `server_fingerprint`: First non-empty Server header value, or "unknown"
     - `content_types_observed`: Normalized content types (strip charset), sorted, deduplicated
     - `security_headers`: Dict of security header name -> value for known headers (x-content-type-options, x-frame-options, strict-transport-security, x-xss-protection, content-security-policy, referrer-policy, permissions-policy)

Key constraints:
- GraphQL POST is explicitly allowed for introspection (read-only query, not mutation)
- Budget must be checked before EVERY HTTP request across both detectors
- If budget exhausted mid-probe, log warning and return partial results (never raise)
- All HTTP errors during probing are caught and logged, never propagated as exceptions
  </action>
  <verify>
Run: `python -c "from api_pentest.core.api_discovery import ArchitectureDetector, ArchitectureType, GRAPHQL_INTROSPECTION_QUERY, RequestBudget; print('ArchitectureDetector imports OK'); print('Query length:', len(GRAPHQL_INTROSPECTION_QUERY))"` -- imports succeed, query is non-empty.

Run: `python -c "
from api_pentest.core.api_discovery import ArchitectureDetector, ArchitectureType, RequestBudget
# Test REST detection from spec
spec = {'openapi': '3.0.0', 'paths': {'/users': {'get': {}}}}
budget = RequestBudget()
det = ArchitectureDetector(openapi_spec=spec, http_client=None, base_url='http://localhost:5000', budget=budget)
# Mock _probe_graphql to return None (no live server)
det._probe_graphql = lambda: None
arch_type, details = det.detect()
assert arch_type == ArchitectureType.REST, f'Expected REST, got {arch_type}'
print('REST detection test PASSED')

# Test HYBRID when spec has GraphQL path
spec2 = {'openapi': '3.0.0', 'paths': {'/graphql': {'post': {}}, '/users': {'get': {}}}}
det2 = ArchitectureDetector(openapi_spec=spec2, http_client=None, base_url='http://localhost:5000', budget=budget)
det2._probe_graphql = lambda: {'endpoint': 'http://localhost:5000/graphql', 'introspection_available': True}
arch_type2, details2 = det2.detect()
assert arch_type2 == ArchitectureType.HYBRID, f'Expected HYBRID, got {arch_type2}'
print('HYBRID detection test PASSED')
"` -- both tests pass.
  </verify>
  <done>ArchitectureDetector identifies REST from spec signals, probes GraphQL endpoints with introspection query, handles disabled introspection, collects server fingerprint info. RequestBudget shared across both detectors. All detection classes importable and unit-testable.</done>
</task>

</tasks>

<verification>
1. `python -c "from api_pentest.core.api_discovery import AuthDetector, ArchitectureDetector, AuthSchemeType, ArchitectureType, DetectedAuthScheme, RequestBudget"` -- all classes import without error
2. AuthDetector correctly maps VAmPI-style spec (type:http, scheme:bearer) to AuthSchemeType.BEARER
3. AuthDetector correctly maps Swagger 2.0 spec (type:basic) to AuthSchemeType.BASIC
4. ArchitectureDetector returns REST when spec has openapi/swagger key
5. GRAPHQL_INTROSPECTION_QUERY is a non-empty string containing "__schema"
6. RequestBudget.can_request() returns False after max_requests reached
</verification>

<success_criteria>
- api_discovery.py exists with AuthDetector, ArchitectureDetector, RequestBudget, AuthSchemeType, ArchitectureType, DetectedAuthScheme
- AuthDetector.detect() works with spec-only (no http_client needed)
- AuthDetector handles both OpenAPI 3.x and Swagger 2.0 security scheme formats
- ArchitectureDetector.detect() works with spec-only (no live probing needed)
- GraphQL introspection query is the standard top-level query with modern `locations` field
- All classes follow codebase conventions: snake_case methods, PascalCase classes, dataclass pattern, logging via getLogger(__name__)
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-discovery-profiling/05-01-SUMMARY.md`
</output>
