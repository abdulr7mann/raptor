---
phase: 03-endpoint-classification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api_pentest/core/endpoint_classifier.py
  - api_pentest/core/models.py
  - api_pentest/runner.py
autonomous: true

must_haves:
  truths:
    - "Every endpoint has a classification field (public, protected, or auth-endpoint) after parsing"
    - "Classification uses three-tier priority: manual overrides > OpenAPI security definitions > path heuristics"
    - "VAmPI endpoints /, /books/v1, /createdb are classified as public"
    - "VAmPI endpoint /users/v1/login is classified as auth-endpoint"
    - "Endpoints with security schemes are classified as protected"
    - "Default classification is protected when no signal matches"
  artifacts:
    - path: "api_pentest/core/endpoint_classifier.py"
      provides: "EndpointClassifier with three-tier classification strategy"
      contains: "class EndpointClassifier"
    - path: "api_pentest/core/models.py"
      provides: "EndpointClassification enum and classification fields on Endpoint"
      contains: "class EndpointClassification"
    - path: "api_pentest/runner.py"
      provides: "Classifier invocation between parse and scenario execution"
      contains: "EndpointClassifier"
  key_links:
    - from: "api_pentest/runner.py"
      to: "api_pentest/core/endpoint_classifier.py"
      via: "import and classify_all() call after parse_input()"
      pattern: "classifier\\.classify_all"
    - from: "api_pentest/core/endpoint_classifier.py"
      to: "api_pentest/core/models.py"
      via: "uses EndpointClassification enum and Endpoint.classification field"
      pattern: "EndpointClassification"
---

<objective>
Build the EndpointClassifier and integrate it into the runner pipeline so every endpoint is classified before scenarios execute.

Purpose: Provides the classification infrastructure that Plan 02 will consume to skip irrelevant tests and eliminate 5 false positives.
Output: New `endpoint_classifier.py` module, updated `Endpoint` dataclass with classification fields, runner wiring.
</objective>

<execution_context>
@/home/abdulr7man/.claude/get-shit-done/workflows/execute-plan.md
@/home/abdulr7man/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-endpoint-classification/03-RESEARCH.md
@api_pentest/core/models.py
@api_pentest/core/openapi_parser.py
@api_pentest/runner.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EndpointClassification enum and classification fields to Endpoint dataclass</name>
  <files>api_pentest/core/models.py</files>
  <action>
Add an `EndpointClassification` enum to `models.py` with three values:
- `PUBLIC = "public"` -- no auth required
- `PROTECTED = "protected"` -- auth required (default)
- `AUTH_ENDPOINT = "auth-endpoint"` -- returns credentials by design (e.g. login)

Add two new fields to the `Endpoint` dataclass:
- `classification: EndpointClassification = EndpointClassification.PROTECTED`
- `classification_reason: str = ""` -- audit trail explaining why this classification was assigned

Place the enum BEFORE the Endpoint dataclass. Import `Enum` is already present. No other changes to models.py.
  </action>
  <verify>
`python -c "from api_pentest.core.models import EndpointClassification, Endpoint; e = Endpoint(method='GET', url='/test'); print(e.classification, e.classification_reason)"` prints `EndpointClassification.PROTECTED` and empty string.
  </verify>
  <done>EndpointClassification enum exists with PUBLIC, PROTECTED, AUTH_ENDPOINT. Endpoint dataclass has classification and classification_reason fields defaulting to PROTECTED and empty string.</done>
</task>

<task type="auto">
  <name>Task 2: Create EndpointClassifier with three-tier classification strategy</name>
  <files>api_pentest/core/endpoint_classifier.py</files>
  <action>
Create `api_pentest/core/endpoint_classifier.py` with class `EndpointClassifier`.

**Constructor** accepts:
- `endpoints: list[Endpoint]` -- the endpoints to classify
- `openapi_spec: dict | None = None` -- raw OpenAPI spec for global security check
- `config: dict | None = None` -- user config for manual overrides

**Public method `classify_all()`**: Iterates endpoints, calls `_classify(ep)` for each, sets `ep.classification` and `ep.classification_reason`. Logs a summary at INFO level: "Classified N endpoints: X public, Y protected, Z auth-endpoint".

**Private `_classify(endpoint)` -> EndpointClassification**: Implements three-tier priority chain:

1. **Manual overrides** (`_check_overrides`): Read `endpoint_overrides` from config (list of dicts with `path` and `classification` keys). Match endpoint URL path against override path. If match found, return the classification. Reason: "manual override".

2. **OpenAPI security definitions** (`_classify_from_openapi`): Only runs when `openapi_spec` is not None.
   - If `"public-no-auth"` in `endpoint.tags` -> PUBLIC. Reason: "OpenAPI security: [] (explicitly public)".
   - If `endpoint.security_schemes` is non-empty -> PROTECTED. Reason: "OpenAPI security scheme: {schemes}".
   - If neither tag nor schemes, check global security via `_has_global_security()`:
     - If global security exists -> PROTECTED. Reason: "inherits global security".
     - If no global security -> PUBLIC. Reason: "no per-operation or global security defined".

3. **Path-pattern heuristics** (`_classify_from_path_patterns`): Uses regex matching on the URL path.
   - `AUTH_ENDPOINT_PATTERNS`: compiled regex matching `/(login|signin|sign-in|authenticate|auth/token|oauth/token|token$|session$)` with `re.IGNORECASE`.
   - `PUBLIC_PATH_PATTERNS`: compiled regex matching `/(register|signup|sign-up|health|healthz|readyz|status|ping|version|createdb|resetdb|initdb|docs|swagger|openapi|api-docs|redoc)$` with `re.IGNORECASE`.
   - Root path check: `path.rstrip("/") == "" or path == "/"` -> PUBLIC.
   - Check auth patterns first (more specific), then public patterns, then default to PROTECTED.
   - Reason includes which pattern matched, e.g. "path heuristic: matches /login pattern".

**`_has_global_security()`**: Returns True if the raw OpenAPI spec has a non-empty top-level `security` key. Check both `security` key existence and that it's a non-empty list. For Swagger 2.0, same key name.

Use `urllib.parse.urlparse` to extract path from endpoint URL. Use `logging.getLogger(__name__)` for the logger. Import only from stdlib + `api_pentest.core.models`.
  </action>
  <verify>
`python -c "
from api_pentest.core.models import Endpoint, EndpointClassification
from api_pentest.core.endpoint_classifier import EndpointClassifier

# Simulate VAmPI: no global security, no per-operation security
eps = [
    Endpoint(method='GET', url='http://localhost:5000/', name='root'),
    Endpoint(method='GET', url='http://localhost:5000/books/v1', name='books'),
    Endpoint(method='GET', url='http://localhost:5000/createdb', name='createdb'),
    Endpoint(method='POST', url='http://localhost:5000/users/v1/login', name='login'),
    Endpoint(method='GET', url='http://localhost:5000/users/v1', name='users', security_schemes=['bearerAuth']),
]
spec = {'openapi': '3.0.0', 'paths': {}}  # no global security
c = EndpointClassifier(endpoints=eps, openapi_spec=spec)
c.classify_all()
for e in eps:
    print(f'{e.method} {e.url}: {e.classification.value} ({e.classification_reason})')
"` should show: root=public, books=public (no global security), createdb=public, login=auth-endpoint (path heuristic), users=protected (security scheme).
  </verify>
  <done>EndpointClassifier classifies VAmPI endpoints correctly: /, /books/v1, /createdb as public; /users/v1/login as auth-endpoint; endpoints with security_schemes as protected. Three-tier strategy works with override > OpenAPI > heuristic priority.</done>
</task>

<task type="auto">
  <name>Task 3: Wire EndpointClassifier into PentestRunner between parsing and scenario execution</name>
  <files>api_pentest/runner.py</files>
  <action>
In `runner.py`:

1. Add import: `from api_pentest.core.endpoint_classifier import EndpointClassifier`

2. In the `run()` method, AFTER `self.response_learner.learn()` and BEFORE the scenario loop, add classifier invocation:

```python
# Classify endpoints before running scenarios
classifier = EndpointClassifier(
    endpoints=self.endpoints,
    openapi_spec=self._get_raw_spec(),
    config=self.config,
)
classifier.classify_all()
```

3. Add a new private method `_get_raw_spec()` that returns the raw OpenAPI spec dict if available, or None. Implementation:
   - Access the input file path from `self.config.get("input_file", "")`
   - Create an `InputDetector` to load and detect format
   - If format is OpenAPI/Swagger, return the loaded data dict
   - If Postman or error, return None
   - Cache the result to avoid re-parsing

Keep it simple: the InputDetector already loads and detects. Reuse it. If the spec was already parsed, the data is lightweight to re-load (it's just JSON).

Do NOT modify `parse_input()` -- the classifier runs later in `run()` after both parsing and response learning are complete.
  </action>
  <verify>
`python -c "from api_pentest.runner import PentestRunner; print('import OK')"` succeeds without error. Verify the EndpointClassifier import resolves and _get_raw_spec method exists.
  </verify>
  <done>Runner calls EndpointClassifier.classify_all() after response pattern learning and before scenario execution. Raw spec is available for OpenAPI security classification. Postman inputs gracefully fall through to heuristic-only classification.</done>
</task>

</tasks>

<verification>
1. `python -c "from api_pentest.core.models import EndpointClassification; print(list(EndpointClassification))"` shows three enum values
2. `python -c "from api_pentest.core.endpoint_classifier import EndpointClassifier; print('OK')"` imports without error
3. `python -c "from api_pentest.runner import PentestRunner; print('OK')"` imports without error
4. Run the Task 2 verification script to confirm VAmPI endpoint classification
</verification>

<success_criteria>
- EndpointClassification enum has PUBLIC, PROTECTED, AUTH_ENDPOINT values
- Endpoint dataclass has classification (default PROTECTED) and classification_reason fields
- EndpointClassifier implements three-tier priority: overrides > OpenAPI > heuristics
- VAmPI public endpoints (/, /books/v1, /createdb) classified as PUBLIC
- VAmPI login endpoint (/users/v1/login) classified as AUTH_ENDPOINT
- Runner invokes classifier between learning and scenario execution
- No existing behavior changed -- classification is additive
</success_criteria>

<output>
After completion, create `.planning/phases/03-endpoint-classification/03-01-SUMMARY.md`
</output>
