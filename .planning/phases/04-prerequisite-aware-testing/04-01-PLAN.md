---
phase: 04-prerequisite-aware-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api_pentest/core/prerequisite_detector.py
  - api_pentest/scenarios/base_scenario.py
  - api_pentest/scenarios/s02_rate_limiting.py
  - api_pentest/runner.py
autonomous: true

must_haves:
  truths:
    - "Rate limit bypass tests (header_bypass_attempt) do not run when no rate limiting exists on target"
    - "Detection probes the target for rate limiting presence before bypass tests execute"
    - "Skipped bypass tests are logged at info level with reason in console output"
    - "Detection returns three-state result: PRESENT, ABSENT, or UNCERTAIN"
    - "When detection is UNCERTAIN, bypass tests still run (conservative)"
  artifacts:
    - path: "api_pentest/core/prerequisite_detector.py"
      provides: "DetectionStatus enum, PrerequisiteResult dataclass, RateLimitDetector, CORSDetector, CSPDetector, PrerequisiteChecker facade"
      min_lines: 100
    - path: "api_pentest/scenarios/base_scenario.py"
      provides: "get_prerequisite() and add_skip_result() helpers on BaseScenario"
      contains: "def get_prerequisite"
    - path: "api_pentest/scenarios/s02_rate_limiting.py"
      provides: "Prerequisite gate on _test_header_bypass()"
      contains: "Precondition not met"
    - path: "api_pentest/runner.py"
      provides: "PrerequisiteChecker integration in run() flow"
      contains: "prerequisite"
  key_links:
    - from: "api_pentest/runner.py"
      to: "api_pentest/core/prerequisite_detector.py"
      via: "PrerequisiteChecker instantiation and check_all() call after classifier.classify_all()"
      pattern: "PrerequisiteChecker.*check_all"
    - from: "api_pentest/runner.py"
      to: "api_pentest/scenarios/base_scenario.py"
      via: "prerequisite_results passed to scenario.setup()"
      pattern: "prerequisite_results"
    - from: "api_pentest/scenarios/s02_rate_limiting.py"
      to: "api_pentest/scenarios/base_scenario.py"
      via: "self.get_prerequisite('rate_limiting') call in _test_header_bypass()"
      pattern: "get_prerequisite.*rate_limiting"
---

<objective>
Build the prerequisite detection system and gate S02's header_bypass_attempt test behind rate-limit detection, eliminating 4 false positives against VAmPI.

Purpose: S02 currently reports "Rate limit bypass via X-Forwarded-For/X-Real-IP/X-Originating-IP/X-Client-IP" against VAmPI, which has no rate limiting. These are false positives because there is nothing to bypass. This plan adds detection of whether rate limiting exists before testing bypass.

Output: PrerequisiteDetector module, BaseScenario helpers, S02 gating, runner integration. The 4 S02 FPs are eliminated.
</objective>

<execution_context>
@/home/abdulr7man/.claude/get-shit-done/workflows/execute-plan.md
@/home/abdulr7man/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-prerequisite-aware-testing/04-RESEARCH.md

@api_pentest/core/models.py
@api_pentest/scenarios/base_scenario.py
@api_pentest/scenarios/s02_rate_limiting.py
@api_pentest/runner.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create prerequisite detector module and add BaseScenario helpers</name>
  <files>
    api_pentest/core/prerequisite_detector.py
    api_pentest/scenarios/base_scenario.py
  </files>
  <action>
Create NEW file `api_pentest/core/prerequisite_detector.py` with:

1. `DetectionStatus` enum with three values: PRESENT, ABSENT, UNCERTAIN.

2. `PrerequisiteResult` dataclass with fields: control_name (str), status (DetectionStatus), reason (str), evidence_summary (str, default ""), endpoint (str, default "").

3. `ControlDetector` ABC with:
   - `__init__(self, http_client, endpoints, config=None, token=None)` storing all as instance attributes
   - Abstract `detect(self) -> list[PrerequisiteResult]`
   - Helper `_get_auth_token(self) -> str | None` that returns `self.token.authorization_header if self.token else None`

4. `RateLimitDetector(ControlDetector)` with:
   - `DETECTION_BURST_SIZE = 15` class constant
   - `detect()` method: selects a probe endpoint (prefer GET via `_select_probe_endpoint()`), sends DETECTION_BURST_SIZE identical requests via `self.http.request()`, counts 429 responses, also checks for rate limit headers via `_check_rate_limit_headers()`. Returns PRESENT if any 429 or rate limit headers found, ABSENT if none, UNCERTAIN if no endpoints available.
   - `_select_probe_endpoint()`: prefers GET endpoints, falls back to first endpoint, returns None if empty.
   - `_check_rate_limit_headers(evidence)`: checks response header names (case-insensitive) for "ratelimit", "rate-limit", "x-rate", "retry-after". Returns bool.

5. `CORSDetector(ControlDetector)` with:
   - `detect()`: tests up to 5 endpoints by sending requests with `Origin: https://detect-cors.example.com` header. If any response contains `access-control-allow-origin` header (case-insensitive), returns PRESENT. If none do, returns ABSENT. Returns UNCERTAIN if no endpoints.

6. `CSPDetector(ControlDetector)` with:
   - `detect()`: tests up to 5 endpoints, checks for `content-security-policy` header (case-insensitive). Returns PRESENT/ABSENT/UNCERTAIN same pattern as CORS.

7. `PrerequisiteChecker` facade class:
   - `__init__(self, http_client, endpoints, config=None, oauth_handler=None)`: stores args, acquires token from oauth_handler if present.
   - `check_all(self) -> dict[str, PrerequisiteResult]`: instantiates all three detectors, runs each, collects results into a dict keyed by control_name. If a detector returns multiple results, use the first one (API-level detection). Logs each detection result at info level: "[Prerequisites] {control}: {status.value} - {reason}".

IMPORTANT: Use the existing `PentestHttpClient.request()` method for all HTTP calls. Do NOT import requests directly. The http_client handles timeouts, SSL, and evidence capture.

IMPORTANT: For CORS and CSP detection, the detectors send real HTTP requests (not just inspecting cached data). The CORS detector adds an Origin header. All three use the same http_client passed from the runner.

Then MODIFY `api_pentest/scenarios/base_scenario.py`:

1. Add `self.prerequisite_results: dict = {}` in `__init__()`.

2. Add `prerequisite_results: dict | None = None` parameter to `setup()` (after response_learner). Store it: `self.prerequisite_results = prerequisite_results or {}`.

3. Add helper method `get_prerequisite(self, control_name: str)`:
   - Returns `self.prerequisite_results.get(control_name)` or None.

4. Add helper method `add_skip_result(self, test_name: str, reason: str, control: str, endpoint_name: str = "")`:
   - Logs at info level: `[{self.SCENARIO_ID}] Skipping {test_name}: {reason} (precondition: {control} not detected)`
   - Calls `self.add_result(test_name=test_name, status=TestStatus.SKIP, details=f"Precondition not met: {reason}", endpoint_name=endpoint_name)`

IMPORTANT: Import `DetectionStatus` from prerequisite_detector in base_scenario.py is NOT needed. The get_prerequisite method returns the raw PrerequisiteResult; callers import DetectionStatus themselves.
  </action>
  <verify>
Run `python -c "from api_pentest.core.prerequisite_detector import PrerequisiteChecker, DetectionStatus, PrerequisiteResult; print('OK')"` succeeds.
Run `python -c "from api_pentest.scenarios.base_scenario import BaseScenario; print('OK')"` succeeds.
  </verify>
  <done>
prerequisite_detector.py exists with DetectionStatus, PrerequisiteResult, RateLimitDetector, CORSDetector, CSPDetector, and PrerequisiteChecker. BaseScenario has get_prerequisite() and add_skip_result() methods. setup() accepts prerequisite_results parameter.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire runner integration and gate S02 header_bypass_attempt</name>
  <files>
    api_pentest/runner.py
    api_pentest/scenarios/s02_rate_limiting.py
  </files>
  <action>
MODIFY `api_pentest/runner.py`:

1. Add import at top: `from api_pentest.core.prerequisite_detector import PrerequisiteChecker`

2. In `__init__()`, add `self.prerequisite_results: dict = {}` alongside existing instance variables.

3. In `run()`, after `classifier.classify_all()` and before the scenario loop (before the "Determine which scenarios to run" comment), add prerequisite detection:
```python
# Detect security control prerequisites before running scenarios
prereq_checker = PrerequisiteChecker(
    http_client=self.http,
    endpoints=self.endpoints,
    config=self.config,
    oauth_handler=self.oauth_a,
)
self.prerequisite_results = prereq_checker.check_all()
```

4. In the scenario setup call inside the loop (line ~194-201), add `prerequisite_results=self.prerequisite_results` to the `scenario.setup()` call.

MODIFY `api_pentest/scenarios/s02_rate_limiting.py`:

1. Add import at top: `from api_pentest.core.prerequisite_detector import DetectionStatus`

2. In `_test_header_bypass()`, after the existing endpoint check (the `if not ep: ... return` block at lines 205-208), add the prerequisite gate:
```python
# Check if rate limiting exists before testing bypass
rate_limit_prereq = self.get_prerequisite("rate_limiting")
if rate_limit_prereq and rate_limit_prereq.status == DetectionStatus.ABSENT:
    self.add_skip_result(
        test_name="header_bypass_attempt",
        reason=rate_limit_prereq.reason,
        control="rate_limiting",
        endpoint_name=ep.full_name,
    )
    return
```

This goes AFTER the `if not ep` check and BEFORE `bypass_headers_list`. The remaining S02 tests (burst_requests, response_time_degradation, rate_limit_header_check) are NOT gated -- they are detection/informational tests where finding "no rate limiting" IS the legitimate finding.

IMPORTANT: Do NOT gate burst_requests, response_time_degradation, or rate_limit_header_check. Only header_bypass_attempt gets the prerequisite check.
  </action>
  <verify>
Run `python -c "from api_pentest.runner import PentestRunner; print('OK')"` succeeds.
Run `python -c "from api_pentest.scenarios.s02_rate_limiting import S02RateLimiting; print('OK')"` succeeds.
Verify the gate exists: `grep -n "Precondition not met" api_pentest/scenarios/s02_rate_limiting.py` shows the skip result in _test_header_bypass.
Verify runner wires prerequisites: `grep -n "prerequisite" api_pentest/runner.py` shows PrerequisiteChecker usage and setup() parameter.
  </verify>
  <done>
Runner creates PrerequisiteChecker after classification, passes results to all scenarios via setup(). S02._test_header_bypass() checks rate_limiting prerequisite and skips with logged reason when ABSENT. The 4 VAmPI FPs (X-Forwarded-For, X-Real-IP, X-Originating-IP, X-Client-IP bypass findings) are eliminated.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from api_pentest.core.prerequisite_detector import PrerequisiteChecker, DetectionStatus, PrerequisiteResult, RateLimitDetector, CORSDetector, CSPDetector; print('All imports OK')"` passes
2. `python -c "from api_pentest.runner import PentestRunner; from api_pentest.scenarios.s02_rate_limiting import S02RateLimiting; print('Integration OK')"` passes
3. `grep -c "prerequisite_results" api_pentest/runner.py` returns 2+ (declaration + setup call)
4. `grep "DetectionStatus.ABSENT" api_pentest/scenarios/s02_rate_limiting.py` confirms gate exists
5. `grep "burst_requests\|response_time_degradation\|rate_limit_header_check" api_pentest/scenarios/s02_rate_limiting.py | grep -v "Precondition"` confirms the other 3 S02 tests are NOT gated
</verification>

<success_criteria>
- PrerequisiteDetector module exists with three-state detection for rate limiting, CORS, and CSP
- BaseScenario has get_prerequisite() and add_skip_result() helpers
- Runner creates PrerequisiteChecker after classification and passes results to scenarios
- S02._test_header_bypass() is gated by rate_limiting prerequisite (ABSENT = skip)
- S02's other three tests (burst_requests, response_time_degradation, rate_limit_header_check) remain ungated
- All imports resolve without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-prerequisite-aware-testing/04-01-SUMMARY.md`
</output>
